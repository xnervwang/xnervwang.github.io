<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="XNERV SURVEYS" type="application/atom+xml">
  <meta name="google-site-verification" content="google819a2e66056c8144">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'VK1UJWKNY9',
      apiKey: '7b99451966536b0cd610a773068159a0',
      indexName: 'xnerv.wang',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="If you use source control, you’re on your way towards understanding memory ordering, an important consideration when writing lock-free code in C, C++ and other languages. In my last post, I wrote abou">
<meta property="og:type" content="article">
<meta property="og:title" content="Memory Barriers Are Like Source Control Operations（转载）">
<meta property="og:url" content="https://xnerv.wang/memory-barriers-are-like-source-control-perations/index.html">
<meta property="og:site_name" content="XNERV SURVEYS">
<meta property="og:description" content="If you use source control, you’re on your way towards understanding memory ordering, an important consideration when writing lock-free code in C, C++ and other languages. In my last post, I wrote abou">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/cpu-diagram.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/source-control-analogy.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/marked-example2-2.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/iriw-state.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/barrier-types.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/loadload.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/storestore.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/get-back-to-later.png">
<meta property="og:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/storeload.png">
<meta property="article:published_time" content="2012-07-10T07:00:00.000Z">
<meta property="article:modified_time" content="2023-08-21T02:24:21.066Z">
<meta property="article:author" content="Xnerv Wang (xnervwang)">
<meta property="article:tag" content="转载">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Memory Barrier">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xnerv.wang/assets/memory-barriers-are-like-source-control-perations/cpu-diagram.png">

<link rel="canonical" href="https://xnerv.wang/memory-barriers-are-like-source-control-perations/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.css">
  <title>Memory Barriers Are Like Source Control Operations（转载） | XNERV SURVEYS</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90038341-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-90038341-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fa4c42961138739a56782aee8127449f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <!--a href="https://github.com/xnervwang" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="/assets/forkme.png" alt="Fork me on GitHub" data-canonical-src="/assets/forkme_right_darkblue.png"></a-->
    <a target="_blank" rel="noopener" href="https://github.com/xnervwang" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XNERV SURVEYS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">God's in his heaven.<br/>All's right with the world.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="https://leetcode.xnerv.wang/" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xnerv.wang/memory-barriers-are-like-source-control-perations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/portraits/nerv.png">
      <meta itemprop="name" content="Xnerv Wang (xnervwang)">
      <meta itemprop="description" content="Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XNERV SURVEYS">
    </span>
      <header class="post-header">

        <h2 class="post-title" itemprop="name headline">
          Memory Barriers Are Like Source Control Operations（转载）
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2012-07-10 00:00:00" itemprop="dateCreated datePublished" datetime="2012-07-10T00:00:00-07:00">2012-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>If you use source control, you’re on your way towards understanding memory ordering, an important consideration when writing lock-free code in C, C++ and other languages.</p>
<p>In my last post, I wrote about <a target="_blank" rel="noopener" href="http://preshing.com/20120625/memory-ordering-at-compile-time">memory ordering at compile time</a>, which forms one half of the memory ordering puzzle. This post is about the other half: memory ordering at runtime, on the processor itself. Like compiler reordering, processor reordering is invisible to a single-threaded program. It only becomes apparent when <a target="_blank" rel="noopener" href="http://preshing.com/20120612/an-introduction-to-lock-free-programming">lock-free techniques</a> are used – that is, when shared memory is manipulated without any mutual exclusion between threads. However, unlike compiler reordering, the effects of processor reordering are <a target="_blank" rel="noopener" href="http://preshing.com/20120515/memory-reordering-caught-in-the-act">only visible in multicore and multiprocessor systems</a>.</p>
<a id="more"></a>
<p>You can enforce correct memory ordering on the processor by issuing any instruction which acts as a <strong>memory barrier</strong>. In some ways, this is the only technique you need to know, because when you use such instructions, compiler ordering is taken care of automatically. Examples of instructions which act as memory barriers include (but are not limited to) the following:</p>
<ul>
<li>Certain inline assembly directives in GCC, such as the PowerPC-specific <code>asm volatile(&quot;lwsync&quot; ::: &quot;memory&quot;)</code></li>
<li>Any <a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684122.aspx">Win32 Interlocked operation</a>, except on Xbox 360</li>
<li>Many operations on <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/atomic/atomic">C++11 atomic types</a>, such as <code>load(std::memory_order_acquire)</code></li>
<li>Operations on POSIX mutexes, such as <a target="_blank" rel="noopener" href="http://linux.die.net/man/3/pthread_mutex_lock"><code>pthread_mutex_lock</code></a></li>
</ul>
<p>Just as there are many instructions which act as memory barriers, there are many different types of memory barriers to know about. Indeed, not all of the above instructions produce the same kind of memory barrier – leading to another possible area of confusion when writing lock-free code. In an attempt to clear things up to some extent, I’d like to offer an analogy which I’ve found helpful in understanding the vast majority (but not all) of possible memory barrier types.</p>
<p>To begin with, consider the architecture of a typical multicore system. Here’s a device with two cores, each having 32 KiB of private L1 data cache. There’s 1 MiB of L2 cache shared between both cores, and 512 MiB of main memory.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/cpu-diagram.png" alt="cpu diagram"/>
</center>
<p>A multicore system is a bit like a group of programmers collaborating on a project using a bizarre kind of source control strategy. For example, the above dual-core system corresponds to a scenario with just two programmers. Let’s name them Larry and Sergey.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/source-control-analogy.png" alt="source control analogy"/>
</center>
<p>On the right, we have a shared, central repository – this represents a combination of main memory and the shared L2 cache. Larry has a complete working copy of the repository on his local machine, and so does Sergey – these (effectively) represent the L1 caches attached to each CPU core. There’s also a scratch area on each machine, to privately keep track of registers and/or local variables. Our two programmers sit there, feverishly editing their working copy and scratch area, all while making decisions about what to do next based on the data they see – much like a thread of execution running on that core.</p>
<p>Which brings us to the source control strategy. In this analogy, the source control strategy is very strange indeed. As Larry and Sergey modify their working copies of the repository, their modifications are constantly <strong>leaking</strong> in the background, to and from the central repository, at totally random times. Once Larry edits the file X, his change will leak to the central repository, but there’s no guarantee about when it will happen. It might happen immediately, or it might happen much, much later. He might go on to edit other files, say Y and Z, and those modifications might leak into the respository <em>before</em> X gets leaked. In this manner, stores are effectively reordered on their way to the repository.</p>
<p>Similarly, on Sergey’s machine, there’s no guarantee about the timing or the order in which those changes leak <em>back</em> from the repository into <em>his</em> working copy. In this manner, loads are effectively reordered on their way out of the repository.</p>
<p>Now, if each programmer works on completely separate parts of the repository, neither programmer will be aware of these background leaks going on, or even of the other programmer’s existence. That would be analogous to running two independent, single-threaded processes. In this case, the <a target="_blank" rel="noopener" href="http://preshing.com/20120625/memory-ordering-at-compile-time">cardinal rule of memory ordering</a> is upheld.</p>
<p>The analogy becomes more useful once our programmers start working on the same parts of the repository. Let’s revisit the example I gave <a target="_blank" rel="noopener" href="http://preshing.com/20120515/memory-reordering-caught-in-the-act">in an earlier post</a>. X and Y are global variables, both initially 0:</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/marked-example2-2.png" alt="marked example 2-2"/>
</center>
<p>Think of X and Y as files which exist on Larry’s working copy of the repository, Sergey’s working copy, and the central repository itself. Larry writes 1 to his working copy of X and Sergey writes 1 to his working copy of Y at roughly the same time. If neither modification has time to leak to the repository and back before each programmer looks up his working copy of the <em>other</em> file, they’ll end up with both r1 = 0 and r2 = 0. This result, which may have seemed counterintuitive at first, actually becomes pretty obvious in the source control analogy.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/iriw-state.png" alt="iriw state"/>
</center>
<h2 id="Types-of-Memory-Barrier"><a class="header-anchor" href="#Types-of-Memory-Barrier"></a>Types of Memory Barrier</h2>
<p>Fortunately, Larry and Sergey are not entirely at the mercy of these random, unpredictable leaks happening in the background. They also have the ability to issue special instructions, called fence instructions, which act as memory barriers. For this analogy, it’s sufficient to define four types of memory barrier, and thus four different fence instructions. Each type of memory barrier is named after the type of memory reordering it’s designed to prevent: for example, <code>#StoreLoad</code> is designed to prevent the reordering of a store followed by a load.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/barrier-types.png" alt="barrier types"/>
</center>
<p>As <a target="_blank" rel="noopener" href="http://g.oswego.edu/dl/jmm/cookbook.html">Doug Lea points out</a>, these four categories map pretty well to specific instructions on real CPUs – though not exactly. Most of the time, a real CPU instruction acts as some combination of the above barrier types, possibly in addition to other effects. In any case, once you understand these four types of memory barriers in the source control analogy, you’re in a good position to understand a large number of instructions on real CPUs, as well as several higher-level programming language constructs.</p>
<h3 id="LoadLoad"><a class="header-anchor" href="#LoadLoad"></a>#LoadLoad</h3>
<p>A LoadLoad barrier effectively prevents reordering of loads performed before the barrier with loads performed after the barrier.</p>
<p>In our analogy, the <code>#LoadLoad</code> fence instruction is basically equivalent to a <strong>pull</strong> from the central repository. Think <code>git pull</code>, <code>hg pull</code>, <code>p4 sync</code>, <code>svn update</code> or <code>cvs update</code>, all acting on the entire repository. If there are any merge conflicts with his local changes, let’s just say they’re resolved randomly.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/loadload.png" alt="loadload"/>
</center>
<p>Mind you, there’s no guarantee that <code>#LoadLoad</code> will pull the latest, or head, revision of the entire repository! It could very well pull an older revision than the head, as long as that revision is <em>at least as new as the newest value which leaked from the central repository into his local machine</em>.</p>
<p>This may sound like a weak guarantee, but it’s still a perfectly good way to prevent seeing stale data. Consider the classic example, where Sergey checks a shared flag to see if some data has been published by Larry. If the flag is true, he issues a <code>#LoadLoad</code> barrier before reading the published value:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsPublished)                   <span class="comment">// Load and check shared flag</span></span><br><span class="line">&#123;</span><br><span class="line">    LOADLOAD_FENCE();              <span class="comment">// Prevent reordering of loads</span></span><br><span class="line">    <span class="keyword">return</span> Value;                  <span class="comment">// Load published value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Obviously, this example depends on having the <code>IsPublished</code> flag leak into Sergey’s working copy by itself. It doesn’t matter exactly when that happens; once the leaked flag has been observed, he issues a <code>#LoadLoad</code> fence to prevent reading some value of <code>Value</code> which is older than the flag itself.</p>
<h3 id="StoreStore"><a class="header-anchor" href="#StoreStore"></a>#StoreStore</h3>
<p>A StoreStore barrier effectively prevents reordering of stores performed before the barrier with stores performed after the barrier.</p>
<p>In our analogy, the <code>#StoreStore</code> fence instruction corresponds to a <strong>push</strong> to the central repository. Think <code>git push</code>, <code>hg push</code>, <code>p4 submit</code>, <code>svn commit</code> or <code>cvs commit</code>, all acting on the entire repository.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/storestore.png" alt="storestore"/>
</center>
<p>As an added twist, let’s suppose that <code>#StoreStore</code> instructions are <strong>not instant</strong>. They’re performed in a delayed, asynchronous manner. So, even though Larry executes a <code>#StoreStore</code>, we can’t make any assumptions about when all his previous stores finally become visible in the central repository.</p>
<p>This, too, may sound like a weak guarantee, but again, it’s perfectly sufficient to prevent Sergey from seeing any stale data published by Larry. Returning to the same example as above, Larry needs only to publish some data to shared memory, issue a <code>#StoreStore</code> barrier, then set the shared flag to true:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value = x;                         <span class="comment">// Publish some data</span></span><br><span class="line">STORESTORE_FENCE();</span><br><span class="line">IsPublished = <span class="number">1</span>;                   <span class="comment">// Set shared flag to indicate availability of data</span></span><br></pre></td></tr></table></figure>
<p>Again, we’re counting on the value of <code>IsPublished</code> to leak from Larry’s working copy over to Sergey’s, all by itself. Once Sergey detects that, he can be confident he’ll see the correct value of <code>Value</code>. What’s interesting is that, for this pattern to work, <code>Value</code> does not even need to be an atomic type; it could just as well be a huge structure with lots of elements.</p>
<h3 id="LoadStore"><a class="header-anchor" href="#LoadStore"></a>#LoadStore</h3>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/get-back-to-later.png" alt="get back to later"/>
</center>
<p>Unlike <code>#LoadLoad</code> and <code>#StoreStore</code>, there’s no clever metaphor for <code>#LoadStore</code> in terms of source control operations. The best way to understand a <code>#LoadStore</code> barrier is, quite simply, in terms of instruction reordering.</p>
<p>Imagine Larry has a set of instructions to follow. Some instructions make him load data from his private working copy into a register, and some make him store data from a register back into the working copy. Larry has the ability to juggle instructions, but only in specific cases. Whenever he encounters a load, he looks ahead at any stores that are coming up after that; if the stores are <em>completely unrelated</em> to the current load, then he’s allowed to skip ahead, do the stores first, then come back afterwards to finish up the load. In such cases, the cardinal rule of memory ordering – never modify the behavior of a single-threaded program – is still followed.</p>
<p>On a real CPU, such instruction reordering might happen on certain processors if, say, there is a cache miss on the load followed by a cache hit on the store. But in terms of understanding the analogy, such hardware details don’t really matter. Let’s just say Larry has a boring job, and this is one of the few times when he’s allowed to get creative. Whether or not he chooses to do it is completely unpredictable. Fortunately, this is a relatively inexpensive type of reordering to prevent; when Larry encounters a <code>#LoadStore</code> barrier, he simply refrains from such reordering around that barrier.</p>
<p>In our analogy, it’s valid for Larry to perform this kind of LoadStore reordering even when there is a <code>#LoadLoad</code> or <code>#StoreStore</code> barrier between the load and the store. However, on a real CPU, instructions which act as a <code>#LoadStore</code> barrier typically act as at least one of those other two barrier types.</p>
<h3 id="StoreLoad"><a class="header-anchor" href="#StoreLoad"></a>#StoreLoad</h3>
<p>A StoreLoad barrier ensures that all stores performed before the barrier are visible to other processors, and that all loads performed after the barrier receive the latest value that is visible at the time of the barrier. In other words, it effectively prevents reordering of all stores before the barrier against all loads after the barrier, respecting the way a <a target="_blank" rel="noopener" href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#sequential-consistency">sequentially consistent</a> multiprocessor would perform those operations.</p>
<p><code>#StoreLoad</code> is unique. It’s the only type of memory barrier that will prevent the result r1 = r2 = 0 in the example given in <a target="_blank" rel="noopener" href="http://preshing.com/20120515/memory-reordering-caught-in-the-act">Memory Reordering Caught in the Act</a>; the same example I’ve repeated earlier in this post.</p>
<p>If you’ve been following closely, you might wonder: How is <code>#StoreLoad</code> different from a <code>#StoreStore</code> followed by a <code>#LoadLoad</code>? After all, a <code>#StoreStore</code> pushes changes to the central repository, while <code>#LoadLoad</code> pulls remote changes back. However, those two barrier types are insufficient. Remember, the push operation may be delayed for an arbitrary number of instructions, and the pull operation might not pull from the head revision. This hints at why the PowerPC’s <code>lwsync</code> instruction – which acts as all three <code>#LoadLoad</code>, <code>#LoadStore</code> and <code>#StoreStore</code> memory barriers, but not <code>#StoreLoad</code> – is insufficient to prevent r1 = r2 = 0 in that example.</p>
<p>In terms of the analogy, a <code>#StoreLoad</code> barrier could be achieved by pushing all local changes to the central repostitory, waiting for that operation to complete, then pulling the absolute latest head revision of the repository. On most processors, instructions that act as a <code>#StoreLoad</code> barrier tend to be more expensive than instructions acting as the other barrier types.</p>
<center>
<img src="/assets/memory-barriers-are-like-source-control-perations/storeload.png" alt="storeload"/>
</center>
<p>If we throw a <code>#LoadStore</code> barrier into that operation, which shouldn’t be a big deal, then what we get is a full memory fence – acting as all four barrier types at once. <a target="_blank" rel="noopener" href="http://g.oswego.edu/dl/jmm/cookbook.html">As Doug Lea also points out</a>, it just so happens that on all current processors, every instruction which acts as a <code>#StoreLoad</code> barrier also acts as a full memory fence.</p>
<h2 id="How-Far-Does-This-Analogy-Get-You"><a class="header-anchor" href="#How-Far-Does-This-Analogy-Get-You"></a>How Far Does This Analogy Get You?</h2>
<p>As I’ve mentioned previously, <a target="_blank" rel="noopener" href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#different-processors-have">every processor has different habits</a> when it comes to memory ordering. The x86/64 family, in particular, has a strong memory model; it’s known to keep memory reordering to a minimum. PowerPC and ARM have weaker memory models, and the Alpha is famous for being in a league of its own. Fortunately, the analogy presented in this post corresponds to a <a target="_blank" rel="noopener" href="http://preshing.com/20120930/weak-vs-strong-memory-models">weak memory model</a>. If you can wrap your head around it, and enforce correct memory ordering using the fence instructions given here, you should be able to handle most CPUs.</p>
<p>The analogy also corresponds pretty well to the abstract machine targeted by both C++11 (formerly known as C++0x) and C11. Therefore, if you write lock-free code using the standard library of those languages while keeping the above analogy in mind, it’s more likely to function correctly on any platform.</p>
<p>In this analogy, I’ve said that each programmer represents a single thread of execution running on a separate core. On a real operating system, threads tend to move between different cores over the course of their lifetime, but the analogy still works. I’ve also alternated between examples in machine language and examples written in C/C++. Obviously, we’d prefer to stick with C/C++, or another high-level language; this is possible because again, any operation which acts as a memory barrier also prevents <a target="_blank" rel="noopener" href="http://preshing.com/20120625/memory-ordering-at-compile-time">compiler reordering</a>.</p>
<p>I haven’t written about every type of memory barrier yet. For instance, there are also <a target="_blank" rel="noopener" href="http://www.mjmwired.net/kernel/Documentation/memory-barriers.txt#305">data dependency barriers</a>. I’ll describe those further in a future post. Still, the four types given here are the big ones.</p>
<p>If you’re interested in how CPUs work under the hood – things like stores buffers, cache coherency protocols and other hardware implementation details – and why they perform memory reordering in the first place, I’d recommend the <a target="_blank" rel="noopener" href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf">fine</a> <a target="_blank" rel="noopener" href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">work</a> of Paul McKenney &amp; David Howells. Indeed, I suspect most programmers who have successfully written lock-free code have at least a passing familiarity with such hardware details.</p>
<hr>
<p><strong>本文地址：<a href="http://xnerv.wang/memory-barriers-are-like-source-control-perations/">http://xnerv.wang/memory-barriers-are-like-source-control-perations/</a></strong><br>
转载自：<a target="_blank" rel="noopener" href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">Memory Barriers Are Like Source Control Operations</a></p>

    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="分享这篇文章"
      
      
        data-wechat-qrcode-helper="请扫描二维码"
      
    >
    </div>
  </div>
  <script src="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.js"></script>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag"># 转载</a>
              <a href="/tags/OS/" rel="tag"># OS</a>
              <a href="/tags/Memory-Barrier/" rel="tag"># Memory Barrier</a>
          </div>

        

      </footer>
    
  </article>
  
  
  

  </div>

  <!--hr/>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- xnerv.wang bottom ad -->
    <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-5173793122443057"
        data-ad-slot="1774750366"
        data-ad-format="auto"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <hr/-->


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Types-of-Memory-Barrier"><span class="nav-text">Types of Memory Barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LoadLoad"><span class="nav-text">#LoadLoad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StoreStore"><span class="nav-text">#StoreStore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LoadStore"><span class="nav-text">#LoadStore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StoreLoad"><span class="nav-text">#StoreLoad</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-Far-Does-This-Analogy-Get-You"><span class="nav-text">How Far Does This Analogy Get You?</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xnerv Wang (xnervwang)"
      src="/portraits/nerv.png">
  <p class="site-author-name" itemprop="name">Xnerv Wang (xnervwang)</p>
  <div class="site-description" itemprop="description">Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">167</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2008 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-eye"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xnerv Wang (xnervwang)</span>
</div>

<div>
  <span>God's in his heaven. All's right with the world.</span>
</div>

        








  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=60335024";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "60335024");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>


        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  

  


  <!-- baidu tuijian -->
  <div id="hm_t_123"></div>
</body>
</html>
