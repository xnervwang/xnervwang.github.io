<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="XNERV SURVEYS" type="application/atom+xml">
  <meta name="google-site-verification" content="google819a2e66056c8144">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'VK1UJWKNY9',
      apiKey: '7b99451966536b0cd610a773068159a0',
      indexName: 'xnerv.wang',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="可执行文件格式综述 相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。 不管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用">
<meta property="og:type" content="article">
<meta property="og:title" content="UNIX&#x2F;LINUX 平台可执行文件格式分析（转载）">
<meta property="og:url" content="https://xnerv.wang/analysis-of-unix-linux-platform-executable-file-format/index.html">
<meta property="og:site_name" content="XNERV SURVEYS">
<meta property="og:description" content="可执行文件格式综述 相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。 不管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-11-14T02:21:00.000Z">
<meta property="article:modified_time" content="2023-08-21T02:24:19.863Z">
<meta property="article:author" content="Xnerv Wang (xnervwang)">
<meta property="article:tag" content="转载">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="COFF">
<meta property="article:tag" content="linker">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xnerv.wang/analysis-of-unix-linux-platform-executable-file-format/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.css">
  <title>UNIX/LINUX 平台可执行文件格式分析（转载） | XNERV SURVEYS</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90038341-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-90038341-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fa4c42961138739a56782aee8127449f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <!--a href="https://github.com/xnervwang" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="/assets/forkme.png" alt="Fork me on GitHub" data-canonical-src="/assets/forkme_right_darkblue.png"></a-->
    <a target="_blank" rel="noopener" href="https://github.com/xnervwang" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XNERV SURVEYS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">God's in his heaven.<br/>All's right with the world.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="https://leetcode.xnerv.wang/" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xnerv.wang/analysis-of-unix-linux-platform-executable-file-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/portraits/nerv.png">
      <meta itemprop="name" content="Xnerv Wang (xnervwang)">
      <meta itemprop="description" content="Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XNERV SURVEYS">
    </span>
      <header class="post-header">

        <h2 class="post-title" itemprop="name headline">
          UNIX/LINUX 平台可执行文件格式分析（转载）
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-13 18:21:00" itemprop="dateCreated datePublished" datetime="2017-11-13T18:21:00-08:00">2017-11-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="可执行文件格式综述"><a class="header-anchor" href="#可执行文件格式综述"></a>可执行文件格式综述</h2>
<p>相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。</p>
<p>不管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用外部文件定义的符号（变量和函数），因此重定位信息和符号信息也是需要的。一些辅助信息是可选的，如调试信息、硬件信息等。基本上任意一种可执行文件格式都是按区间保存上述信息，称为段（Segment）或节（Section）。不同的文件格式中段和节的含义可能有细微区别，但根据上下文关系可以很清楚的理解，这不是关键问题。最后，可执行文件通常都有一个文件头部以描述本文件的总体结构。</p>
<p>相对可执行文件有三个重要的概念：编译（compile）、连接（link，也可称为链接、联接）、加载（load）。源程序文件被编译成目标文件，多个目标文件被连接成一个最终的可执行文件，可执行文件被加载到内存中运行。因为本文重点是讨论可执行文件格式，因此加载过程也相对重点讨论。下面是LINUX平台下ELF文件加载过程的一个简单描述。</p>
<a id="more"></a>
<ol>
<li>
<p>内核首先读ELF文件的头部，然后根据头部的数据指示分别读入各种数据结构，找到标记为可加载（loadable）的段，并调用函数 mmap()把段内容加载到内存中。在加载之前，内核把段的标记直接传递给 mmap()，段的标记指示该段在内存中是否可读、可写，可执行。显然，文本段是只读可执行，而数据段是可读可写。这种方式是利用了现代操作系统和处理器对内存的保护功能。著名的Shellcode（ <a href="#artrelatedtopics">参考资料 17</a>）的编写技巧则是突破此保护功能的一个实际例子。</p>
</li>
<li>
<p>内核分析出ELF文件标记为 PT_INTERP 的段中所对应的动态连接器名称，并加载动态连接器。现代 LINUX 系统的动态连接器通常是 /lib/ld-linux.so.2，相关细节在后面有详细描述。</p>
</li>
<li>
<p>内核在新进程的堆栈中设置一些标记-值对，以指示动态连接器的相关操作。</p>
</li>
<li>
<p>内核把控制传递给动态连接器。</p>
</li>
<li>
<p>动态连接器检查程序对外部文件（共享库）的依赖性，并在需要时对其进行加载。</p>
</li>
<li>
<p>动态连接器对程序的外部引用进行重定位，通俗的讲，就是告诉程序其引用的外部变量/函数的地址，此地址位于共享库被加载在内存的区间内。动态连接还有一个延迟（Lazy）定位的特性，即只在&quot;真正&quot;需要引用符号时才重定位，这对提高程序运行效率有极大帮助。</p>
</li>
<li>
<p>动态连接器执行在ELF文件中标记为 .init 的节的代码，进行程序运行的初始化。在早期系统中，初始化代码对应函数 <code>_init(void)</code>(函数名强制固定)，在现代系统中，则对应形式为</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">__attribute((constructor))</span><br><span class="line">init_function(void)</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中函数名为任意。</p>
<p>8：动态连接器把控制传递给程序，从 ELF 文件头部中定义的程序进入点开始执行。在 a.out 格式和ELF格式中，程序进入点的值是显式存在的，在 COFF 格式中则是由规范隐含定义。</p>
<p>从上面的描述可以看出，加载文件最重要的是完成两件事情：加载程序段和数据段到内存；进行外部定义符号的重定位。重定位是程序连接中一个重要概念。我们知道，一个可执行程序通常是由一个含有 main() 的主程序文件、若干目标文件、若干共享库（Shared Libraries）组成。（注：采用一些特别的技巧，也可编写没有 main 函数的程序，请参阅 <a href="#artrelatedtopics">参考资料 2</a>）一个 C 程序可能引用共享库定义的变量或函数，换句话说就是程序运行时必须知道这些变量/函数的地址。在静态连接中，程序所有需要使用的外部定义都完全包含在可执行程序中，而动态连接则只在可执行文件中设置相关外部定义的一些引用信息，真正的重定位是在程序运行之时。静态连接方式有两个大问题：如果库中变量或函数有任何变化都必须重新编译连接程序；如果多个程序引用同样的变量/函数，则此变量/函数会在文件/内存中出现多次，浪费硬盘/内存空间。比较两种连接方式生成的可执行文件的大小，可以看出有明显的区别。</p>
<h2 id="a-out-文件格式分析"><a class="header-anchor" href="#a-out-文件格式分析"></a>a.out 文件格式分析</h2>
<p>a.out 格式在不同的机器平台和不同的 UNIX 操作系统上有轻微的不同，例如在 MC680x0 平台上有 6 个 section。下面我们讨论的是最&quot;标准&quot;的格式。</p>
<p>a.out 文件包含 7 个 section，格式如下：</p>
<table>
<thead>
<tr>
<th>exec header（执行头部，也可理解为文件头部）</th>
</tr>
</thead>
<tbody>
<tr>
<td>text segment（文本段）</td>
</tr>
<tr>
<td>data segment(数据段)</td>
</tr>
<tr>
<td>text relocations(文本重定位段)</td>
</tr>
<tr>
<td>data relocations（数据重定位段）</td>
</tr>
<tr>
<td>symbol table（符号表）</td>
</tr>
<tr>
<td>string table（字符串表）</td>
</tr>
</tbody>
</table>
<p>执行头部的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_midmag;    <span class="comment">/* 魔数和其它信息 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_text;      <span class="comment">/* 文本段的长度 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_data;      <span class="comment">/* 数据段的长度 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_bss;       <span class="comment">/* BSS段的长度 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_syms;      <span class="comment">/* 符号表的长度 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_entry;     <span class="comment">/* 程序进入点 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_trsize;    <span class="comment">/* 文本重定位表的长度 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>   a_drsize;    <span class="comment">/* 数据重定位表的长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件头部主要描述了各个 section 的长度，比较重要的字段是 a_entry（程序进入点），代表了系统在加载程序并初试化各种环境后开始执行程序代码的入口。这个字段在后面讨论的 ELF 文件头部中也有出现。由 a.out 格式和头部数据结构我们可以看出，a.out 的格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、BSS），而且每个 section 的顺序是固定的。这种结构缺乏扩展性，如不能包含&quot;现代&quot;可执行文件中常见的调试信息，最初的 UNIX 黑客对 a.out 文件调试使用的工具是 adb，而 adb 是一种机器语言调试器！</p>
<p>a.out 文件中包含符号表和两个重定位表，这三个表的内容在连接目标文件以生成可执行文件时起作用。在最终可执行的 a.out 文件中，这三个表的长度都为 0。a.out 文件在连接时就把所有外部定义包含在可执行程序中，如果从程序设计的角度来看，这是一种硬编码方式，或者可称为模块之间是强藕和的。在后面的讨论中，我们将会具体看到ELF格式和动态连接机制是如何对此进行改进的。</p>
<p>a.out 是早期UNIX系统使用的可执行文件格式，由<code>AT&amp;T</code>设计，现在基本上已被 ELF 文件格式代替。a.out 的设计比较简单，但其设计思想明显的被后续的可执行文件格式所继承和发扬。可以参阅 <a href="#artrelatedtopics">参考资料 16</a> 和阅读 <a href="#artrelatedtopics">参考资料 15</a> 源代码加深对 a.out 格式的理解。 <a href="#artrelatedtopics">参考资料 12</a> 讨论了如何在&quot;现代&quot;的红帽LINUX运行 a.out 格式文件。</p>
<h2 id="COFF-文件格式分析"><a class="header-anchor" href="#COFF-文件格式分析"></a>COFF 文件格式分析</h2>
<p>COFF 格式比 a.out 格式要复杂一些，最重要的是包含一个节段表(section table)，因此除了 .text，.data，和 .bss 区段以外，还可以包含其它的区段。另外也多了一个可选的头部，不同的操作系统可一对此头部做特定的定义。</p>
<p>COFF 文件格式如下：</p>
<table>
<thead>
<tr>
<th>File Header(文件头部)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Optional Header(可选文件头部)</td>
</tr>
<tr>
<td>Section 1 Header(节头部)</td>
</tr>
<tr>
<td>………</td>
</tr>
<tr>
<td>Section n Header(节头部)</td>
</tr>
<tr>
<td>Raw Data for Section 1(节数据)</td>
</tr>
<tr>
<td>Raw Data for Section n(节数据)</td>
</tr>
<tr>
<td>Relocation Info for Sect. 1(节重定位数据)</td>
</tr>
<tr>
<td>Relocation Info for Sect. n(节重定位数据)</td>
</tr>
<tr>
<td>Line Numbers for Sect. 1(节行号数据)</td>
</tr>
<tr>
<td>Line Numbers for Sect. n(节行号数据)</td>
</tr>
<tr>
<td>Symbol table(符号表)</td>
</tr>
<tr>
<td>String table(字符串表)</td>
</tr>
</tbody>
</table>
<p>文件头部的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">filehdr</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>  f_magic;    <span class="comment">/* 魔数 */</span></span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">short</span>  f_nscns;    <span class="comment">/* 节个数 */</span></span><br><span class="line">       <span class="keyword">long</span>            f_timdat;   <span class="comment">/* 文件建立时间 */</span></span><br><span class="line">       <span class="keyword">long</span>            f_symptr;   <span class="comment">/* 符号表相对文件的偏移量 */</span></span><br><span class="line">       <span class="keyword">long</span>            f_nsyms;    <span class="comment">/* 符号表条目个数 */</span></span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">short</span>  f_opthdr;   <span class="comment">/* 可选头部长度 */</span></span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">short</span>  f_flags;    <span class="comment">/* 标志 */</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>COFF 文件头部中魔数与其它两种格式的意义不太一样，它是表示针对的机器类型，例如 0x014c 相对于 I386 平台，而 0x268 相对于 Motorola 68000系列等。当 COFF 文件为可执行文件时，字段 f_flags 的值为 F_EXEC（0X00002），同时也表示此文件没有未解析的符号，换句话说，也就是重定位在连接时就已经完成。由此也可以看出，原始的 COFF 格式不支持动态连接。为了解决这个问题以及增加一些新的特性，一些操作系统对 COFF 格式进行了扩展。Microsoft 设计了名为 PE（Portable Executable）的文件格式，主要扩展是在 COFF 文件头部之上增加了一些专用头部，具体细节请参阅 <a href="#artrelatedtopics">参考资料 18</a>，某些 UNIX 系统也对 COFF 格式进行了扩展，如 XCOFF（extended common object file format）格式，支持动态连接，请参阅 <a href="#artrelatedtopics">参考资料 5</a>。</p>
<p>紧接文件头部的是可选头部，COFF 文件格式规范中规定可选头部的长度可以为 0，但在 LINUX 系统下可选头部是必须存在的。下面是 LINUX 下可选头部的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span>   magic[<span class="number">2</span>];                <span class="comment">/* 魔数 */</span></span><br><span class="line">        <span class="keyword">char</span>   vstamp[<span class="number">2</span>];               <span class="comment">/* 版本号 */</span></span><br><span class="line">        <span class="keyword">char</span>   tsize[<span class="number">4</span>];                <span class="comment">/* 文本段长度 */</span></span><br><span class="line">        <span class="keyword">char</span>   dsize[<span class="number">4</span>];                <span class="comment">/* 已初始化数据段长度 */</span></span><br><span class="line">        <span class="keyword">char</span>   bsize[<span class="number">4</span>];                <span class="comment">/* 未初始化数据段长度 */</span></span><br><span class="line">        <span class="keyword">char</span>   entry[<span class="number">4</span>];                <span class="comment">/* 程序进入点 */</span></span><br><span class="line">        <span class="keyword">char</span>   text_start[<span class="number">4</span>];       <span class="comment">/* 文本段基地址 */</span></span><br><span class="line">        <span class="keyword">char</span>   data_start[<span class="number">4</span>];       <span class="comment">/* 数据段基地址 */</span></span><br><span class="line">&#125;</span><br><span class="line">COFF_AOUTHDR;</span><br></pre></td></tr></table></figure>
<p>字段 magic 为 0413 时表示 COFF 文件是可执行的，注意到可选头部中显式定义了程序进入点，标准的 COFF 文件没有明确的定义程序进入点的值，通常是从 .text 节开始执行，但这种设计并不好。</p>
<p>前面我们提到，COFF 格式比 a.out 格式多了一个节段表，一个节头条目描述一个节数据的细节，因此 COFF 格式能包含更多的节，或者说可以根据实际需要，增加特定的节，具体表现在 COFF 格式本身的定义以及稍早提及的 COFF 格式扩展。我个人认为，节段表的出现可能是 COFF 格式相对 a.out 格式最大的进步。下面我们将简单描述 COFF 文件中节的数据结构，因为节的意义更多体现在程序的编译和连接上，所以本文不对其做更多的描述。此外，ELF 格式和 COFF格式对节的定义非常相似，在随后的 ELF 格式分析中，我们将省略相关讨论。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COFF_scnhdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">char</span>    s_name[<span class="number">8</span>];                  <span class="comment">/* 节名称 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_paddr[<span class="number">4</span>];             <span class="comment">/* 物理地址 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_vaddr[<span class="number">4</span>];             <span class="comment">/* 虚拟地址 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_size[<span class="number">4</span>];                  <span class="comment">/* 节长度 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_scnptr[<span class="number">4</span>];                <span class="comment">/* 节数据相对文件的偏移量 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_relptr[<span class="number">4</span>];                <span class="comment">/* 节重定位信息偏移量 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_lnnoptr[<span class="number">4</span>];               <span class="comment">/* 节行信息偏移量 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_nreloc[<span class="number">2</span>];                <span class="comment">/* 节重定位条目数 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_nlnno[<span class="number">2</span>];             <span class="comment">/* 节行信息条目数 */</span></span><br><span class="line">        <span class="keyword">char</span>    s_flags[<span class="number">4</span>];             <span class="comment">/* 段标记 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意：LINUX系统中头文件coff.h中对字段s_paddr的注释是&quot;physical address&quot;，但似乎应该理解为&quot;节被加载到内存中所占用的空间长度&quot;。字段s_flags标记该节的类型，如文本段、数据段、BSS段等。在COFF的节中也出现了行信息，行信息描述了二进制代码与源代码的行号之间的对映关系，在调试时很有用。</p>
<p><a href="#artrelatedtopics">参考资料 19</a>是一份对COFF格式详细描述的中文资料，更详细的内容请参阅 <a href="#artrelatedtopics">参考资料 20</a>。</p>
<h2 id="ELF文件格式分析"><a class="header-anchor" href="#ELF文件格式分析"></a>ELF文件格式分析</h2>
<p>ELF文件有三种类型： 可重定位文件：也就是通常称的目标文件，后缀为.o。 共享文件：也就是通常称的库文件，<a target="_blank" rel="noopener" href="http://xn--siqw5lms6b.so">后缀为.so</a>。 可执行文件：本文主要讨论的文件格式，总的来说，可执行文件的格式与上述两种文件的格式之间的区别主要在于观察的角度不同：一种称为连接视图（Linking View），一种称为执行视图（Execution View）。</p>
<p>首先看看ELF文件的总体布局：</p>
<table>
<thead>
<tr>
<th>ELF header(ELF头部)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Program header table(程序头表)</td>
</tr>
<tr>
<td>Segment1（段1）</td>
</tr>
<tr>
<td>Segment2（段2）</td>
</tr>
<tr>
<td>………</td>
</tr>
<tr>
<td>Sengmentn（段n）</td>
</tr>
<tr>
<td>Setion header table(节头表，可选)</td>
</tr>
</tbody>
</table>
<p>段由若干个节(Section)构成,节头表对每一个节的信息有相关描述。对可执行程序而言，节头表是可选的。 <a href="#artrelatedtopics">参考资料 1</a>中作者谈到把节头表的所有数据全部设置为0，程序也能正确运行！ELF头部是一个关于本文件的路线图（road map），从总体上描述文件的结构。下面是ELF头部的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];     <span class="comment">/* 魔数和相关信息 */</span></span><br><span class="line">        Elf32_Half    e_type;                 <span class="comment">/* 目标文件类型 */</span></span><br><span class="line">        Elf32_Half    e_machine;              <span class="comment">/* 硬件体系 */</span></span><br><span class="line">        Elf32_Word    e_version;              <span class="comment">/* 目标文件版本 */</span></span><br><span class="line">        Elf32_Addr    e_entry;                <span class="comment">/* 程序进入点 */</span></span><br><span class="line">        Elf32_Off     e_phoff;                <span class="comment">/* 程序头部偏移量 */</span></span><br><span class="line">        Elf32_Off     e_shoff;                <span class="comment">/* 节头部偏移量 */</span></span><br><span class="line">        Elf32_Word    e_flags;                <span class="comment">/* 处理器特定标志 */</span></span><br><span class="line">        Elf32_Half    e_ehsize;               <span class="comment">/* ELF头部长度 */</span></span><br><span class="line">        Elf32_Half    e_phentsize;            <span class="comment">/* 程序头部中一个条目的长度 */</span></span><br><span class="line">        Elf32_Half    e_phnum;                <span class="comment">/* 程序头部条目个数  */</span></span><br><span class="line">        Elf32_Half    e_shentsize;            <span class="comment">/* 节头部中一个条目的长度 */</span></span><br><span class="line">        Elf32_Half    e_shnum;                <span class="comment">/* 节头部条目个数 */</span></span><br><span class="line">        Elf32_Half    e_shstrndx;             <span class="comment">/* 节头部字符表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>
<p>下面我们对ELF头表中一些重要的字段作出相关说明，完整的ELF定义请参阅 <a href="#artrelatedtopics">参考资料6</a>和 <a href="#artrelatedtopics">参考资料 7</a>。</p>
<p>e_ident[0]-e_ident[3]包含了ELF文件的魔数，依次是0x7f、‘E’、‘L’、‘F’。注意，任何一个ELF文件必须包含此魔数。 <a href="#artrelatedtopics">参考资料 3</a>中讨论了利用程序、工具、/Proc文件系统等多种查看ELF魔数的方法。e_ident[4]表示硬件系统的位数，1代表32位，2代表64位。e_ident[5]表示数据编码方式，1代表小印第安排序（最大有意义的字节占有最低的地址），2代表大印第安排序（最大有意义的字节占有最高的地址）。e_ident[6]指定ELF头部的版本，当前必须为1。e_ident[7]到e_ident[14]是填充符，通常是0。ELF格式规范中定义这几个字节是被忽略的，但实际上是这几个字节完全可以可被利用。如病毒Lin/Glaurung.676/666（ <a href="#artrelatedtopics">参考资料 1</a>）设置e_ident[7]为0x21,表示本文件已被感染；或者存放可执行代码（ <a href="#artrelatedtopics">参考资料 2</a>）。ELF头部中大多数字段都是对子头部数据的描述，其意义相对比较简单。值得注意的是某些病毒可能修改字段e_entry（程序进入点）的值，以指向病毒代码，例如上面提到的病毒Lin/Glaurung.676/666。</p>
<p>一个实际可执行文件的文件头部形式如下：（利用命令readelf）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">Magic:   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">Class:                             ELF32</span><br><span class="line">Data:                              <span class="number">2&#x27;</span>s complement, little endian</span><br><span class="line">Version:                           <span class="number">1</span> (current)</span><br><span class="line">OS/ABI:                            UNIX - System V</span><br><span class="line">ABI Version:                       <span class="number">0</span></span><br><span class="line">Type:                              EXEC (Executable file)</span><br><span class="line">Machine:                           Intel <span class="number">80386</span></span><br><span class="line">Version:                           <span class="number">0x1</span></span><br><span class="line">Entry point address:               <span class="number">0x80483cc</span></span><br><span class="line">Start of program headers:          <span class="number">52</span> (bytes into file)</span><br><span class="line">Start of section headers:          <span class="number">14936</span> (bytes into file)</span><br><span class="line">Flags:                             <span class="number">0x0</span></span><br><span class="line">Size of <span class="keyword">this</span> header:               <span class="number">52</span> (bytes)</span><br><span class="line">Size of program headers:           <span class="number">32</span> (bytes)</span><br><span class="line">Number of program headers:         <span class="number">6</span></span><br><span class="line">Size of section headers:           <span class="number">40</span> (bytes)</span><br><span class="line">Number of section headers:         <span class="number">34</span></span><br><span class="line">Section header <span class="built_in">string</span> table index: <span class="number">31</span></span><br></pre></td></tr></table></figure>
<p>紧接ELF头部的是程序头表，它是一个结构数组，包含了ELF头表中字段e_phnum定义的条目，结构描述一个段或其他系统准备执行该程序所需要的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      Elf32_Word  p_type;               <span class="comment">/* 段类型 */</span></span><br><span class="line">      Elf32_Off   p_offset;             <span class="comment">/* 段位置相对于文件开始处的偏移量 */</span></span><br><span class="line">      Elf32_Addr  p_vaddr;              <span class="comment">/* 段在内存中的地址 */</span></span><br><span class="line">      Elf32_Addr  p_paddr;              <span class="comment">/* 段的物理地址 */</span></span><br><span class="line">      Elf32_Word  p_filesz;             <span class="comment">/* 段在文件中的长度 */</span></span><br><span class="line">      Elf32_Word  p_memsz;              <span class="comment">/* 段在内存中的长度 */</span></span><br><span class="line">      Elf32_Word  p_flags;              <span class="comment">/* 段的标记 */</span></span><br><span class="line">      Elf32_Word  p_align;              <span class="comment">/* 段在内存中对齐标记 */</span></span><br><span class="line">  &#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure>
<p>在详细讨论可执行文件程序头表之前，首先查看一个实际文件的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">PHDR           0x000034 0x08048034 0x08048034 0x000c0 0x000c0 R E 0x4</span><br><span class="line">INTERP         0x0000f4 0x080480f4 0x080480f4 0x00013 0x00013 R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib/ld-linux.so.2]</span><br><span class="line">    LOAD           0x000000 0x08048000 0x08048000 0x00684 0x00684 R E 0x1000</span><br><span class="line">    LOAD           0x000684 0x08049684 0x08049684 0x00118 0x00130 RW  0x1000</span><br><span class="line">    DYNAMIC        0x000690 0x08049690 0x08049690 0x000c8 0x000c8 RW  0x4</span><br><span class="line">    NOTE           0x000108 0x08048108 0x08048108 0x00020 0x00020 R   0x4</span><br><span class="line">    Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.ABI-tag .<span class="built_in">hash</span> .dynsym .dynstr .gnu.version</span><br><span class="line">           .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame</span><br><span class="line">   03     .data .dynamic .ctors .dtors .jcr .got .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">05     .note.ABI-tag</span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        080480f4 0000f4 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048108 000108 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .<span class="built_in">hash</span>             HASH            08048128 000128 000040 04   A  4   0  4</span><br><span class="line">  [ 4] .dynsym           DYNSYM          08048168 000168 0000b0 10   A  5   1  4</span><br><span class="line">  [ 5] .dynstr           STRTAB          08048218 000218 00007b 00   A  0   0  1</span><br><span class="line">  [ 6] .gnu.version      VERSYM          08048294 000294 000016 02   A  4   0  2</span><br><span class="line">  [ 7] .gnu.version_r    VERNEED         080482ac 0002ac 000030 00   A  5   1  4</span><br><span class="line">  [ 8] .rel.dyn          REL             080482dc 0002dc 000008 08   A  4   0  4</span><br><span class="line">  [ 9] .rel.plt          REL             080482e4 0002e4 000040 08   A  4   b  4</span><br><span class="line">  [10] .init             PROGBITS        08048324 000324 000017 00  AX  0   0  4</span><br><span class="line">  [11] .plt              PROGBITS        0804833c 00033c 000090 04  AX  0   0  4</span><br><span class="line">  [12] .text             PROGBITS        080483cc 0003cc 0001f8 00  AX  0   0  4</span><br><span class="line">  [13] .fini             PROGBITS        080485c4 0005c4 00001b 00  AX  0   0  4</span><br><span class="line">  [14] .rodata           PROGBITS        080485e0 0005e0 00009f 00   A  0   0 32</span><br><span class="line">  [15] .eh_frame         PROGBITS        08048680 000680 000004 00   A  0   0  4</span><br><span class="line">  [16] .data             PROGBITS        08049684 000684 00000c 00  WA  0   0  4</span><br><span class="line">  [17] .dynamic          DYNAMIC         08049690 000690 0000c8 08  WA  5   0  4</span><br><span class="line">  [18] .ctors            PROGBITS        08049758 000758 000008 00  WA  0   0  4</span><br><span class="line">  [19] .dtors            PROGBITS        08049760 000760 000008 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049768 000768 000004 00  WA  0   0  4</span><br><span class="line">  [21] .got              PROGBITS        0804976c 00076c 000030 04  WA  0   0  4</span><br><span class="line">  [22] .bss              NOBITS          0804979c 00079c 000018 00  WA  0   0  4</span><br><span class="line">  [23] .comment          PROGBITS        00000000 00079c 000132 00      0   0  1</span><br><span class="line">  [24] .debug_aranges    PROGBITS        00000000 0008d0 000098 00      0   0  8</span><br><span class="line">  [25] .debug_pubnames   PROGBITS        00000000 000968 000040 00      0   0  1</span><br><span class="line">  [26] .debug_info       PROGBITS        00000000 0009a8 001cc6 00      0   0  1</span><br><span class="line">  [27] .debug_abbrev     PROGBITS        00000000 00266e 0002cc 00      0   0  1</span><br><span class="line">  [28] .debug_line       PROGBITS        00000000 00293a 0003dc 00      0   0  1</span><br><span class="line">  [29] .debug_frame      PROGBITS        00000000 002d18 000048 00      0   0  4</span><br><span class="line">  [30] .debug_str        PROGBITS        00000000 002d60 000bcd 01  MS  0   0  1</span><br><span class="line">  [31] .shstrtab         STRTAB          00000000 00392d 00012b 00      0   0  1</span><br><span class="line">  [32] .symtab           SYMTAB          00000000 003fa8 000740 10     33  56  4</span><br><span class="line">  [33] .strtab           STRTAB          00000000 0046e8 000467 00      0   0  1</span><br></pre></td></tr></table></figure>
<p>对一个ELF可执行程序而言，一个基本的段是标记p_type为PT_INTERP的段，它表明了运行此程序所需要的程序解释器（/lib/ld-linux.so.2），实际上也就是动态连接器（dynamic linker）。最重要的段是标记p_type为PT_LOAD的段，它表明了为运行程序而需要加载到内存的数据。查看上面实际输入，可以看见有两个可LOAD段，第一个为只读可执行（FLg为R E）,第二个为可读可写（Flg为RW）。段1包含了文本节.text，注意到ELF文件头部中程序进入点的值为0x80483cc，正好是指向节.text在内存中的地址。段二包含了数据节.data，此数据节中数据是可读可写的，相对的只读数据节.rodata包含在段1中。ELF格式可以比COFF格式包含更多的调试信息，如上面所列出的形式为.debug_xxx的节。在I386平台LINUX系统下，用命令file查看一个ELF可执行程序的可能输出是：a.out: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.2.5, dynamically linked (uses shared libs), not stripped。</p>
<p>ELF文件中包含了动态连接器的全路径，内核定位&quot;正确&quot;的动态连接器在内存中的地址是&quot;正确&quot;运行可执行文件的保证， <a href="#artrelatedtopics">参考资料 13</a>讨论了如何通过查找动态连接器在内存中的地址以达到颠覆（Subversiver）动态连接机制的方法。</p>
<p>最后我们讨论ELF文件的动态连接机制。每一个外部定义的符号在全局偏移表(Global Offset Table GOT)中有相应的条目,如果符号是函数则在过程连接表(Procedure Linkage Table PLT)中也有相应的条目，且一个PLT条目对应一个GOT条目。对外部定义函数解析可能是整个ELF文件规范中最复杂的，下面是函数符号解析过程的一个描述。</p>
<ol>
<li>
<p>代码中调用外部函数func,语句形式为call 0xaabbccdd,地址0xaabbccdd实际上就是符号func在PLT表中对应的条目地址（假设地址为标号.PLT2）。</p>
</li>
<li>
<p>PLT表的形式如下</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PLT0: pushl   4(%ebx)    /* GOT表的地址保存在寄存器ebx中 */</span><br><span class="line">jmp     *8(%ebx)</span><br><span class="line">nop; nop</span><br><span class="line">nop; nop</span><br><span class="line">.PLT1:  jmp     *name1@GOT(%ebx)</span><br><span class="line">pushl   <span class="variable">$offset</span></span><br><span class="line">jmp     .PLT0@PC</span><br><span class="line">.PLT2:  jmp     *func@GOT(%ebx)</span><br><span class="line">pushl   <span class="variable">$offset</span></span><br><span class="line">jmp     .PLT0@PC</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>查看标号.PLT2的语句,实际上是跳转到符号func在GOT表中对应的条目。</p>
</li>
<li>
<p>在符号没有重定位前，GOT表中此符号对应的地址为标号.PLT2的下一条语句，即是pushl $offset，其中$offset是符号func的重定位偏移量。注意到这是一个二次跳转。</p>
</li>
<li>
<p>在符号func的重定位偏移量压栈后,控制跳到PLT表的第一条目，把GOT[1]的内容压栈，并跳转到GOT[2]对应的地址。</p>
</li>
<li>
<p>GOT[2]对应的实际上是动态符号解析函数的代码，在对符号func的地址解析后，会把func在内存中的地址设置到GOT表中此符号对应的条目中。</p>
</li>
<li>
<p>当第二次调用此符号时，GOT表中对应的条目已经包含了此符号的地址，就可直接调用而不需要利用PLT表进行跳转。</p>
</li>
</ol>
<p>动态连接是比较复杂的，但为了获得灵活性的代价通常就是复杂性。其最终目的是把GOT表中条目的值修改为符号的真实地址，这也可解释节.got包含在可读可写段中。</p>
<p>动态连接是一个非常重要的进步，这意味着库文件可以被升级、移动到其他目录等等而不需要重新编译程序（当然，这不意味库可以任意修改，如函数入参的个数、数据类型应保持兼容性）。从很大程度上说，动态连接机制是ELF格式代替a.out格式的决定性原因。如果说面对对象的编程本质是面对接口（interface）的编程，那么动态连接机制则是这种思想的地一个非常典型的应用，具体的讲，动态连接机制与设计模式中的桥接（BRIDGE）方法比较类似，而它的LAZY特性则与代理（PROXY）方法非常相似。动态连接操作的细节描述请参阅 <a href="#artrelatedtopics">参考资料 8，9，10，11</a>。通过阅读命令readelf、objdump 的源代码以及 <a href="#artrelatedtopics">参考资料 14</a>中所提及的相关软件源代码，可以对ELF文件的格式有更彻底的了解。</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>不同时期的可执行文件格式深刻的反映了技术进步的过程，技术进步通常是针对解决存在的问题和适应新的环境。早期的UNIX系统使用a.out格式，随着操作系统和硬件系统的进步，a.out格式的局限性越来越明显。新的可执行文件格式COFF在UNIX System VR3中出现，COFF格式相对a.out格式最大变化是多了一个节头表（section head table），能够在包含基础的文本段、数据段、BSS段之外包含更多的段，但是COFF对动态连接和C++程序的支持仍然比较困难。为了解决上述问题，UNIX系统实验室(UNIX SYSTEM Laboratories USL) 开发出ELF文件格式，它被作为应用程序二进制接口（Application binary Interface ABI）的一部分，其目的是替代传统的a.out格式。例如，ELF文件格式中引入初始化段.init和结束段.fini（分别对应构造函数和析构函数）则主要是为了支持C++程序。1994年6月ELF格式出现在LINUX系统上，现在ELF格式作为UNIX/LINUX最主要的可执行文件格式。当然我们完全有理由相信，在将来还会有新的可执行文件格式出现。</p>
<p>上述三种可执行文件格式都很好的体现了设计思想中分层的概念，由一个总的头部刻画了文件的基本要素，再由若干子头部/条目刻画了文件的若干细节。比较一下可执行文件格式和以太数据包中以太头、IP头、TCP头的设计，我想我们能很好的感受分层这一重要的设计思想。 <a href="#artrelatedtopics">参考资料 21</a>从全局的角度讨论了各种文件的格式，并提出一个比较夸张的结论：Everything Is Byte!</p>
<p>最后的题外话：大多数资料中对a.out格式的评价较低，常见的词语有黑暗年代（dark ages）、丑陋（ugly）等等，当然，从现代的观点来看，的确是比较简单，但是如果没有曾经的简单何来今天的精巧？正如我们今天可以评价石器时代的技术是ugly,那么将来的人们也可以嘲讽今天的技术是非常ugly。我想我们也许应该用更平和的心态来对曾经的技术有一个公正的评价。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2>
<p>（原文中未提供参考资料的链接）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/38117710/2258530">What’s the difference of section and segment in ELF file format</a></p>
<div class="post-text" itemprop="text">
<p><strong>Section is static, segment is dynamic</strong></p>
<p>The quote is correct, but to actually understand it the difference, you should try to understand the fields of the section header and program header (segment) entries, and how they are be used by the linker (sections) and operating system (segment).</p>
<p>Particularly important informations are (besides lengths):</p>
<ul>
<li>section: tell the linker if a section is either:
<ul>
<li>raw data to be loaded into memory, e.g. <code>.data</code>, <code>.text</code>, etc.</li>
<li>or formatted metadata about other sections, that will be used by the linker, but disappear at runtime e.g. <code>.symtab</code>, <code>.srttab</code>, <code>.rela.text</code></li>
</ul>
</li>
<li>segment: tells the operating system:
<ul>
<li>where should a segment be loaded into virtual memory</li>
<li>what permissions the segments have (read, write, execute). Remember that this can be efficiently enforced by the processor: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18431261/how-does-x86-paging-work">How does x86 paging work?</a></li>
</ul>
</li>
</ul>
<p>I have written a tutorial that covers that in more detail at: <a target="_blank" rel="noopener" href="http://www.cirosantilli.com/elf-hello-world/">http://www.cirosantilli.com/elf-hello-world/</a></p>
<p><strong>Does a segment contain one or more sections?</strong></p>
<p>Yes, and it is the linker that puts sections into segments.</p>
<p>In Binutils, how sections are put into segments by <code>ld</code> is determined by a text file called a <em>linker script</em>. Docs: <a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/ld/Scripts.html">https://sourceware.org/binutils/docs/ld/Scripts.html</a></p>
<p>You can get the default one with <code>ld --verbose</code>, and set a custom one with <code>-T</code>.</p>
<p>For example, my default Ubuntu 17.04 linker script contains:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text           :</span><br><span class="line">&#123;</span><br><span class="line">  *(.text.unlikely .text.*_unlikely .text.unlikely.*)</span><br><span class="line">  *(.text.exit .text.exit.*)</span><br><span class="line">  *(.text.startup .text.startup.*)</span><br><span class="line">  *(.text.hot .text.hot.*)</span><br><span class="line">  *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>which tells the linker to put sections named <code>.text.unlikely</code>, <code>.text.*_unlikely</code>, <code>.text.exit</code>, etc. in the <code>.text</code> segment.</p>
<p>OS development is a case where custom scripts are useful, minimal example: <a target="_blank" rel="noopener" href="https://github.com/cirosantilli/x86-bare-metal-examples/blob/d217b180be4220a0b4a453f31275d38e697a99e0/linker.ld">https://github.com/cirosantilli/x86-bare-metal-examples/blob/d217b180be4220a0b4a453f31275d38e697a99e0/linker.ld</a></p>
<p>Once the executable is linked, it is only possible to know which section went to which segment if the linker stores the optional section header in the executable: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23018496/where-is-the-section-to-segment-mapping-stored-in-elf-files">Where is the “Section to segment mapping” stored in ELF files?</a></p>
<hr>
<p><strong>本文地址：<a href="http://xnerv.wang/analysis-of-unix-linux-platform-executable-file-format/">http://xnerv.wang/analysis-of-unix-linux-platform-executable-file-format/</a></strong><br>
转载自：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-excutff/">UNIX/LINUX 平台可执行文件格式分析</a></p>

    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="分享这篇文章"
      
      
        data-wechat-qrcode-helper="请扫描二维码"
      
    >
    </div>
  </div>
  <script src="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.js"></script>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag"># 转载</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/COFF/" rel="tag"># COFF</a>
              <a href="/tags/linker/" rel="tag"># linker</a>
          </div>

        

      </footer>
    
  </article>
  
  
  

  </div>

  <!--hr/>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- xnerv.wang bottom ad -->
    <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-5173793122443057"
        data-ad-slot="1774750366"
        data-ad-format="auto"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <hr/-->


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%BB%BC%E8%BF%B0"><span class="nav-text">可执行文件格式综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-out-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-text">a.out 文件格式分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COFF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-text">COFF 文件格式分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90"><span class="nav-text">ELF文件格式分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xnerv Wang (xnervwang)"
      src="/portraits/nerv.png">
  <p class="site-author-name" itemprop="name">Xnerv Wang (xnervwang)</p>
  <div class="site-description" itemprop="description">Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">167</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2008 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-eye"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xnerv Wang (xnervwang)</span>
</div>

<div>
  <span>God's in his heaven. All's right with the world.</span>
</div>

        








  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=60335024";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "60335024");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>


        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  

  


  <!-- baidu tuijian -->
  <div id="hm_t_123"></div>
</body>
</html>
