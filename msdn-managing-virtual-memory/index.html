<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="XNERV SURVEYS" type="application/atom+xml">
  <meta name="google-site-verification" content="google819a2e66056c8144">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: 'VK1UJWKNY9',
      apiKey: '7b99451966536b0cd610a773068159a0',
      indexName: 'xnerv.wang',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Randy Kath Microsoft Developer Network Technology Group Created: January 20, 1993 Abstract Determining which function or set of functions to use for managing memory in your application is difficult wi">
<meta property="og:type" content="article">
<meta property="og:title" content="(MSDN) Managing Virtual Memory">
<meta property="og:url" content="https://xnerv.wang/msdn-managing-virtual-memory/index.html">
<meta property="og:site_name" content="XNERV SURVEYS">
<meta property="og:description" content="Randy Kath Microsoft Developer Network Technology Group Created: January 20, 1993 Abstract Determining which function or set of functions to use for managing memory in your application is difficult wi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xnerv.wang/assets/msdn-managing-virtual-memory/1.gif">
<meta property="og:image" content="https://xnerv.wang/assets/msdn-managing-virtual-memory/2.gif">
<meta property="article:published_time" content="2017-11-14T21:58:00.000Z">
<meta property="article:modified_time" content="2023-08-21T02:24:20.221Z">
<meta property="article:author" content="Xnerv Wang (xnervwang)">
<meta property="article:tag" content="转载">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="MSDN">
<meta property="article:tag" content="Memory Management">
<meta property="article:tag" content="Virtual Memory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xnerv.wang/assets/msdn-managing-virtual-memory/1.gif">

<link rel="canonical" href="https://xnerv.wang/msdn-managing-virtual-memory/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.css">
  <title>(MSDN) Managing Virtual Memory | XNERV SURVEYS</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90038341-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-90038341-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fa4c42961138739a56782aee8127449f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <!--a href="https://github.com/xnervwang" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="/assets/forkme.png" alt="Fork me on GitHub" data-canonical-src="/assets/forkme_right_darkblue.png"></a-->
    <a target="_blank" rel="noopener" href="https://github.com/xnervwang" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XNERV SURVEYS</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">God's in his heaven.<br/>All's right with the world.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="https://leetcode.xnerv.wang/" rel="noopener" target="_blank"><i class="fa fa-fw fa-book"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xnerv.wang/msdn-managing-virtual-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/portraits/nerv.png">
      <meta itemprop="name" content="Xnerv Wang (xnervwang)">
      <meta itemprop="description" content="Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XNERV SURVEYS">
    </span>
      <header class="post-header">

        <h2 class="post-title" itemprop="name headline">
          (MSDN) Managing Virtual Memory
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-14 13:58:00" itemprop="dateCreated datePublished" datetime="2017-11-14T13:58:00-08:00">2017-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index">
                    <span itemprop="name">Windows</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Randy Kath<br>
Microsoft Developer Network Technology Group</p>
<p>Created: January 20, 1993</p>
<h2 id="Abstract"><a class="header-anchor" href="#Abstract"></a>Abstract</h2>
<p>Determining which function or set of functions to use for managing memory in your application is difficult without a solid understanding of how each group of functions works and the overall impact they each have on the operating system. In an effort to simplify these decisions, this technical article focuses on the virtual memory management functions: which ones are available, how they are used, and how their use affects the operating system. The following topics are discussed in this article:</p>
<ul>
<li>Reserving, committing, and freeing virtual memory</li>
<li>Changing protection on pages of virtual memory</li>
<li>Locking pages of virtual memory</li>
<li>Querying a process’s virtual memory</li>
</ul>
<p>A sample application called ProcessWalker accompanies this technical article on the Microsoft Developer Network CD. This sample application is useful for exploring the virtual address space of a process. It also employs the use of virtual memory functions for implementing a linked list structure.</p>
<a id="more"></a>
<h2 id="Introduction"><a class="header-anchor" href="#Introduction"></a>Introduction</h2>
<p>This is one of three related technical articles—“Managing Virtual Memory,” “Managing Memory-Mapped Files,” and “Managing Heap Memory”—that explain how to manage memory in applications for Windows. In each article, this introduction identifies the basic memory components in the Windows programming model and indicates which article to reference for specific areas of interest.</p>
<p>The first version of the Microsoft Windows operating system introduced a method of managing dynamic memory based on a single <em>global heap</em>, which all applications and the system share, and multiple, private <em>local heaps</em>, one for each application. Local and global memory management functions were also provided, offering extended features for this new memory management system. More recently, the Microsoft C run-time (CRT) libraries were modified to include capabilities for managing these heaps in Windows using native CRT functions such as <strong>malloc</strong> and <strong>free</strong>. Consequently, developers are now left with a choice—learn the new application programming interface (API) provided as part of Windows or stick to the portable, and typically familiar, CRT functions for managing memory in applications written for Windows.</p>
<p>The Windows API offers three groups of functions for managing memory in applications: memory-mapped file functions, heap memory functions, and virtual memory functions.</p>
<p><img src="/assets/msdn-managing-virtual-memory/1.gif" alt=""></p>
<p><strong>Figure 1. The Windows API provides different levels of memory management for versatility in application programming.</strong></p>
<p>In all, six sets of memory management functions exist in Windows, as shown in Figure 1, all of which were designed to be used independently of one another. So, which set of functions should you use? The answer to this question depends greatly on two things: the type of memory management you want and how the functions relevant to it are implemented in the operating system. In other words, are you building a large database application where you plan to manipulate subsets of a large memory structure? Or maybe you’re planning some simple dynamic memory structures, such as linked lists or binary trees? In both cases, you need to know which functions offer the features best suited to your intention and exactly how much of a resource hit occurs when using each function.</p>
<p>Table 1 categorizes the memory management function groups and indicates which of the three technical articles in this series describes each group’s behavior. Each technical article emphasizes the impact these functions have on the system by describing the behavior of the system in response to using the functions.</p>
<p><strong>Table 1. Memory Management Functions</strong></p>
<table>
<thead>
<tr>
<th>Memory set</th>
<th>System resource affected</th>
<th>Related technical article</th>
</tr>
</thead>
<tbody>
<tr>
<td>Virtual memory functions</td>
<td>A process’ virtual address space<br/>System pagefile<br/>System memory<br/>Hard disk space</td>
<td>“Managing Virtual Memory”</td>
</tr>
<tr>
<td>Memory-mapped file functions</td>
<td>A process’s virtual address space<br/>System pagefile<br/>Standard file I/O<br/>System memory<br/>Hard disk space</td>
<td>“Managing Memory-Mapped Files”</td>
</tr>
<tr>
<td>Heap memory functions</td>
<td>A process’s virtual address space<br/>System memory<br/>Process heap resource structure</td>
<td>“Managing Heap Memory”</td>
</tr>
<tr>
<td>Global heap memory functions</td>
<td>A process’s heap resource structure</td>
<td>“Managing Heap Memory”</td>
</tr>
<tr>
<td>Local heap memory functions</td>
<td>A process’s heap resource structure</td>
<td>“Managing Heap Memory”</td>
</tr>
<tr>
<td>C run-time reference library</td>
<td>A process’s heap resource structure</td>
<td>“Managing Heap Memory”</td>
</tr>
</tbody>
</table>
<h2 id="Windows-Memory-System-Overview"><a class="header-anchor" href="#Windows-Memory-System-Overview"></a>Windows Memory System Overview</h2>
<p>Windows employs a page-based virtual memory system that uses linear addressing. Internally, the system manages all memory in segments called <em>pages</em>. Each page of physical memory is backed by either a pagefile for volatile pages of memory or a disk file for read-only memory pages. There can be as many as 16 separate pagefiles at a time. Code, resources, and other read-only data are backed directly by the files from which they originated.</p>
<p>Windows NT provides an independent, 2 gigabyte (GB) user address space for each application (process) in the system. To the application, it appears that there is 2 GB of memory available, regardless of the amount of physical memory that is actually available. When an application requests more memory than is available, Windows NT satisfies the request by paging noncritical pages of memory—from this and/or other processes—to a pagefile and freeing those physical pages of memory. Conceptually, the global heap no longer exists in Windows NT. Instead, each process has a private 32-bit address space from which all of the memory for the process is allocated—including code, resources, data, DLLs (dynamic-link libraries), and dynamic memory. Realistically, the system is still limited by whatever hardware resources are available, but the management of available resources is performed independently of the applications in the system.</p>
<h2 id="Virtual-Memory"><a class="header-anchor" href="#Virtual-Memory"></a>Virtual Memory</h2>
<p>Windows NT makes a distinction between memory and address space. Each process is attributed 2 GB of user address space no matter how much physical memory is actually available for the process. Also, all processes use the same range of linear 32-bit addresses ranging from 0000000016-7FFFFFFF16, regardless of what memory is available. Windows NT takes care of paging memory to and from disk at appropriate times so that each process is sure to be able to address the memory it needs. Although two processes may attempt to access memory at the same <em>virtual address</em> simultaneously, the Windows NT virtual memory manager actually represents these two memory locations at different physical locations where neither is likely to coincide with the original virtual address. This is virtual memory.</p>
<p>Because of virtual memory, an application is able to manage its own address space without having to consider the impact on other processes in the system. The memory manager in Windows NT is responsible for seeing that all applications have enough physical memory to operate effectively at any given moment. Applications for the Windows NT operating system do not have to be concerned with sharing system memory with other applications as they did in Windows version 3.1 or earlier. Yet even with their own address space, applications still have the ability to share memory with other applications.</p>
<p>One benefit of distinguishing between memory and address space is the capability it provides to applications for loading extremely large files into memory. Instead of having to read a large file into memory, Windows NT provides support for the application to reserve the range of addresses that the file needs. Then, sections of the file can be viewed (physically read into memory) as needed. The same can be done for large allocations of dynamic memory through virtual memory support.</p>
<p>In previous versions of Windows, an application had to allocate memory before being able to manipulate the addresses in that memory. In Windows NT, the address space of each process is already allocated; whether there is any memory associated with the addresses in the address space is a different issue. The virtual memory management functions provide low-level support for independently managing both the addresses and memory of a process.</p>
<p>The key virtual memory functions are:</p>
<ul>
<li>VirtualAlloc and VirtualFree</li>
<li>VirtualLock and VirtualUnlock</li>
<li>VirtualQuery or VirtualQueryEx</li>
<li>VirtualProtect or VirtualProtectEx</li>
</ul>
<p>Each function is grouped with its counterpart if it has one. Memory is allocated using <strong>VirtualAlloc</strong> and, once allocated, must be freed with <strong>VirtualFree</strong>. Similarly, pages that have been locked with <strong>VirtualLock</strong> must be unlocked with <strong>VirtualUnlock</strong> when no longer needed. <strong>VirtualQuery</strong> and <strong>VirtualProtect</strong> have no counterparts, but they both have complementary functions (indicated by the <strong>Ex</strong> extension on the function names) that allow them to be used on processes other than the calling process, if the calling process has the appropriate privilege to do so. These functions are explained below in their appropriate context.</p>
<h2 id="Free-Reserved-and-Committed-Virtual-Memory"><a class="header-anchor" href="#Free-Reserved-and-Committed-Virtual-Memory"></a>Free, Reserved, and Committed Virtual Memory</h2>
<p>Every address in a process can be thought of as either free, reserved, or committed at any given time. A process begins with all addresses free, meaning they are free to be committed to memory or reserved for future use. Before any free address may be used, it must first be allocated as reserved or committed. Attempting to access an address that is either reserved or free generates an access violation exception.</p>
<p>The entire 2 GB of addresses in a process are either free for use, reserved for future use, or committed to specific memory (in use). Figure 2 represents a hypothetical process consisting of free, reserved, and committed addresses.</p>
<p><img src="/assets/msdn-managing-virtual-memory/2.gif" alt=""></p>
<p><strong>Figure 2. A process’s 2 GB of virtual address space is divided into regions of free, reserved, and committed memory locations.</strong></p>
<h3 id="Reserved-Addresses"><a class="header-anchor" href="#Reserved-Addresses"></a>Reserved Addresses</h3>
<p>When reserving addresses in a process, no pages of physical memory are committed, and perhaps more importantly, no space is reserved in the pagefile for backing the memory. Also, reserving a range of addresses is no guarantee that at a later time there will be physical memory available to commit to those addresses. Rather, it is simply saving a specific free address range until needed, protecting the addresses from other allocation requests. Without this type of protection, routine operations such as loading a DLL or resource could occupy specific addresses and jeopardize their availability for later use.</p>
<p>Reserving addresses is a quick operation, completely independent of the size of the address range being reserved. Whether reserving a 1 GB or a 4K range of addresses, the function is relatively speedy. This is not surprising considering that no resources are allocated during the operation. The function merely makes an entry into the process’s virtual address descriptor (VAD) tree.</p>
<p>To reserve a range of addresses, invoke the <strong>VirtualAlloc</strong> function as shown in the following code fragment:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reserve a 10 MB range of addresses */</span></span><br><span class="line">lpBase = VirtualAlloc (<span class="literal">NULL</span>,</span><br><span class="line">                       <span class="number">10485760</span>,</span><br><span class="line">                       MEM_RESERVE,</span><br><span class="line">                       PAGE_NOACCESS);</span><br></pre></td></tr></table></figure>
<p>As shown here, a value of NULL used for the first parameter, <em>lpAddress</em>, directs the function to reserve the range of addresses at whichever location is most convenient. Alternatively, a specific address could have been passed indicating a precise starting address for the reserved range. Either way, the return value to this function indicates the address at the beginning of the reserved range of addresses, unless the function is unable to complete the request. Then, the return value for the <strong>VirtualAlloc</strong> function is an error-status value.</p>
<p>The second parameter indicates the range of addresses the function should allocate. This value can be anywhere from one page to 2 GB in size, but <strong>VirtualAlloc</strong> is actually constrained to a smaller range than that. The minimum size that can be reserved is 64K, and the maximum that can be reserved is the largest contiguous range of free addresses in the process. Requesting one page of reserved addresses results in a 64K address range. Conversely, requesting 2 GB will certainly fail because it is not possible to have that much address space free at any given time. (Remember that the act of loading an application consumes part of the initial 2 GB address space.)</p>
<blockquote>
<p><strong>Note</strong><br>
Windows NT builds a safeguard into every process’s address space. Both the upper and lower 65,536 bytes of each process are permanently reserved by the system. These portions of the address space are reserved to trap stray pointers—pointers that attempt to address memory in the range 0000000016-0000FFFF16 or 7FFF000016-7FFFFFFF16. Not coincidentally, it is easy to detect pointers in this range by simply ignoring the lower four nibbles (the rightmost two bytes) in these addresses. Essentially, a pointer is invalid if the upper four nibbles are 000016 or 7FFF16; all other values represent valid addresses.</p>
</blockquote>
<p>The final two parameters in the <strong>VirtualAlloc</strong> function, <em>dwAllocationType</em> and <em>dwProtect</em>, are used to determine how to allocate the addresses and the protection to associate with them. Addresses can be allocated as either type MEM_COMMIT or MEM_RESERVE. PAGE_READONLY, PAGE_READWRITE, and PAGE_NOACCESS are the three protections that can be applied to virtual memory. Reserved addresses are always PAGE_NOACCESS, a default enforced by the system no matter what value is passed to the function. Committed pages can be either read-only, read-write, or no-access.</p>
<h3 id="Committed-Memory"><a class="header-anchor" href="#Committed-Memory"></a>Committed Memory</h3>
<p>To use reserved addresses, memory must first be committed to the addresses. Committing memory to addresses is similar to reserving it—call <strong>VirtualAlloc</strong> with the <em>dwAllocation</em> parameter equal to MEM_COMMIT. At this point, resources become committed to addresses. Memory can be committed as little as one page at a time. The maximum amount of memory that can be committed is based solely on the maximum range of contiguous free or reserved addresses (but not a combination of both), regardless of the amount of physical memory available to the system.</p>
<p>When memory is committed, physical pages of memory are allocated and space is reserved in a pagefile. That is, pages of committed memory always exist as either physical pages of memory or as pages that have been paged to the pagefile on disk. It is also possible that, while committing a chunk of memory, part or all of that memory will not reside in physical memory initially. Some pages of memory reside initially in the pagefile until accessed. Once pages of memory are committed, the virtual memory manager treats them like all other pages of memory in the system.</p>
<p>In the Windows NT virtual memory system, page tables are used to access physical pages of memory. Each page table is itself a page of memory, like committed pages. Occasionally, when committing memory, additional pages must be allocated for page tables at the same time. So a request to commit a page of memory can require one page commitment for a page table, one page for the requested page, and two pages of space in the pagefile to back each of these pages. Consequently, the time it takes <strong>VirtualAlloc</strong> to complete a memory-commit request varies widely, depending on the state of the system and the size of the request.</p>
<p>The following example demonstrates how to commit a specific page of reserved addresses from the previous example to a page of memory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Commit memory for 3rd page of addresses. */</span></span><br><span class="line">lpPage3 = VirtualAlloc (lpBase + (<span class="number">2</span> * <span class="number">4096</span>),</span><br><span class="line">                        <span class="number">4096</span>,</span><br><span class="line">                        MEM_COMMIT,</span><br><span class="line">                        PAGE_READWRITE);</span><br></pre></td></tr></table></figure>
<p>Notice that instead of specifying NULL for <em>lpAddress</em>, a specific address is given to indicate exactly which page of reserved addresses becomes committed to memory. Also, this page of memory is initially given PAGE_READWRITE protection instead of PAGE_NOACCESS as in the previous example. The return address from the function is the virtual address of the first pages of committed addresses.</p>
<h3 id="Freeing-Virtual-Memory"><a class="header-anchor" href="#Freeing-Virtual-Memory"></a>Freeing Virtual Memory</h3>
<p>Once addresses have been allocated as either reserved or committed, <strong>VirtualFree</strong> is the only way to release them—that is, return them to free addresses. <strong>VirtualFree</strong> can also be used to decommit committed pages and, at the same time, return the addresses to reserved status. When decommitting addresses, all physical memory and pagefile space associated with the addresses is released. The following example demonstrates how to decommit the page of memory committed in the previous example.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Decommit memory for 3rd page of addresses. */</span></span><br><span class="line">VirtualFree (lpBase + (<span class="number">2</span> * <span class="number">4096</span>),</span><br><span class="line">             <span class="number">4096</span>,</span><br><span class="line">             MEM_DECOMMIT,</span><br><span class="line">             PAGE_NOACCESS);</span><br></pre></td></tr></table></figure>
<p>Only addresses that are committed can be decommitted. This is important to remember when you need to decommit a large range of addresses. Say, for example, you have a range of addresses where several subsets of the addresses are committed and others are reserved. The only way to make the entire range reserved is to independently decommit each subset of committed addresses one by one. Attempting to decommit the entire range of addresses will fail because reserved addresses cannot be decommitted.</p>
<p>Conversely, the same range of addresses can be freed in one fell swoop. It doesn’t matter what the state of an address is when the address is freed. The following example demonstrates freeing the 10 MB range of addresses reserved in the first example.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free entire 10 MB range of addresses. */</span></span><br><span class="line">VirtualFree (lpBase,</span><br><span class="line">             <span class="number">10485760</span>,</span><br><span class="line">             MEM_RELEASE,</span><br><span class="line">             PAGE_NOACCESS);</span><br></pre></td></tr></table></figure>
<h2 id="Changing-Protection-on-Pages-of-Virtual-Memory"><a class="header-anchor" href="#Changing-Protection-on-Pages-of-Virtual-Memory"></a>Changing Protection on Pages of Virtual Memory</h2>
<p>Use the <strong>VirtualProtect</strong> function as a method for changing the protection on committed pages of memory. An application can, for example, commit a page of addresses as PAGE_READWRITE and immediately fill the page with data. Then, the protection on the page could be changed to PAGE_READONLY, effectively protecting the data from being overwritten by any thread in the process. The following example uses the <strong>VirtualProtect</strong> function to make an inaccessible page available.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Change page protection to read/write. */</span></span><br><span class="line">VirtualProtect (lpStack + <span class="number">4096</span>,</span><br><span class="line">                <span class="number">4096</span>,</span><br><span class="line">                PAGE_READWRITE,</span><br><span class="line">                lpdwOldProt);</span><br></pre></td></tr></table></figure>
<p>Consider the following as a context for using this function. A data-buffering application receives a varying flow of data. Depending on specific hardware configurations and other software applications competing for CPU time, the flow of data may at times exceed the capability of the process. To prevent this from happening, the application designs a memory system that initially commits some pages of memory for a buffer. The application then protects the upper page of memory with PAGE_NOACCESS protection so that any attempt to access this memory generates an exception. The application also surrounds this code with an exception handler to handle access violations.</p>
<p>When an access violation exception occurs, the application is able to determine that the buffer is approaching its upper limit. It responds by changing the protection on the page to PAGE_READWRITE, allowing the buffer to receive any additional data and continue uninterrupted. At the same time, the application spawns another thread to slow the data flow until the buffer is back down to a reasonable operating range. When things are back to normal, the upper page is returned to PAGE_NOACCESS and the additional thread goes away. This scenario describes how combining page protection and exception handling can be used to provide unique memory management opportunities.</p>
<h2 id="Locking-Pages-of-Virtual-Memory"><a class="header-anchor" href="#Locking-Pages-of-Virtual-Memory"></a>Locking Pages of Virtual Memory</h2>
<p>Processes in Windows NT have a minimal set of pages called a <em>working set</em> that, in order for the process to run properly, must be present in memory when running. Windows NT assigns a default number of pages to a process at startup and gradually tunes that number to achieve a balanced optimum performance among all active processes in the system. When a process is running (actually, when the threads of a process are running), Windows NT works hard at making sure that the process has its working set of pages resident in physical memory at all times.</p>
<p>Processes in Windows NT are granted subtle influence into this system behavior with the <strong>VirtualLock</strong> and <strong>VirtualUnlock</strong> functions. Essentially, a process can establish specific pages to lock into its working set. However, this does not give the process free reign over its working set. It cannot affect the number of pages that make up its working set (the system adjusts the working set for each process routinely), and it cannot control when the working set is in memory and when it is not. The maximum number of pages that can be locked into a process’s working set at one time is limited to 32. An application could do more harm than good by locking pages of committed memory into the working set because doing so may force other critical pages in the process to become replaced. In that case, the pages could become paged to disk, causing page faults to occur whenever they were accessed. Then the process would spend much of its CPU allotment just paging critical pages in and out of memory.</p>
<p>Below is an example that locks a range of addresses into memory when the process is running.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock critical addresses into memory. */</span></span><br><span class="line">VirtualLock (lpCriticalData, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>Notice the range of addresses being locked into memory in this example is less than one page. It is not necessary for the entire range to be in a single page of memory. The net result is that the entire page of memory containing the data for the addresses, not just the data for the addresses indicated, is locked into memory. If the data straddles a page boundary, both pages are locked.</p>
<h2 id="Querying-a-Process’s-Virtual-Memory"><a class="header-anchor" href="#Querying-a-Process’s-Virtual-Memory"></a>Querying a Process’s Virtual Memory</h2>
<p>Given a process’s 2 GB of address space, managing the entire range of addresses would be difficult without the ability to query address information. Because the addresses themselves are represented independent of the memory that may or may not be committed to them, querying them is simply a matter of accessing the data structure that maintains their state. In Windows NT, this structure is the virtual address descriptor tree mentioned earlier. Windows exposes the capability of “walking the VAD structure” in the <strong>VirtualQuery</strong> and <strong>VirtualQueryEx</strong> functions. Again, the <strong>Ex</strong> suffix indicates which function can be called from one process to query another—if the calling process has the security privilege necessary to perform this function. The following example is extracted from the ProcessWalker sample:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Query next region of memory in child process. */</span></span><br><span class="line">VirtualQueryEx (hChildProcess,</span><br><span class="line">                lpMem,</span><br><span class="line">                lpList,</span><br><span class="line">                <span class="keyword">sizeof</span> (MEMORY_BASIC_INFORMATION));</span><br></pre></td></tr></table></figure>
<p>The ProcessWalker application’s primary function is to walk a process’s address space, identifying each of its distinct address regions and representing specific state information about each region. It does this by enumerating each region one at a time from the bottom of the process to the top. <em>lpMem</em> is used to indicate the location of each region. Initially it is set to 0, and after returning from each query of a new region, it is incremented by the size of the region it queried. This process is repeated until <em>lpMem</em> reaches the upper system reserved area.</p>
<p><em>lpList</em> is a pointer to a <strong>MEMORY_BASIC_INFORMATION</strong> structure to be filled in by the <strong>VirtualQueryEx</strong> function. When the function returns, this structure represents information about the region queried. The structure has the following members:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MEMORY_BASIC_INFORMATION</span> &#123;</span> <span class="comment">/* mbi */</span></span><br><span class="line">    PVOID BaseAddress;       <span class="comment">/* Base address of region    */</span></span><br><span class="line">    PVOID AllocationBase;    <span class="comment">/* Allocation base address   */</span></span><br><span class="line">    DWORD AllocationProtect; <span class="comment">/* Initial access protection */</span></span><br><span class="line">    DWORD RegionSize;        <span class="comment">/* Size in bytes of region   */</span></span><br><span class="line">    DWORD State;             <span class="comment">/* Committed, reserved, free */</span></span><br><span class="line">    DWORD Protect;           <span class="comment">/* Current access protection */</span></span><br><span class="line">    DWORD Type;              <span class="comment">/* Type of pages             */</span></span><br><span class="line">&#125; MEMORY_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>
<p>The <strong>VirtualQuery</strong> function returns this state information for any contiguous address region. The function determines the lower bound of the region and the size of the region, along with the exact state of the addresses in the region. The address it uses to determine the region can be any address in the region. So, if you wish to determine how much stack space has been committed at any given time, follow these steps:</p>
<ol>
<li>Get the thread context for the thread in question.</li>
<li>Call the <strong>VirtualQuery</strong> function, supplying the address of the stack pointer in the thread context information as the <em>lpMem</em> parameter in the function.<br>
The query returns the size of the committed memory and the address of the base of the stack in the <strong>MEMORY_BASIC_INFORMATION</strong> structure in the form of the <em>RegionSize</em> and <em>BaseAddress</em>, respectively.</li>
</ol>
<p>Regions of memory, as defined by <strong>VirtualQuery</strong>, are a contiguous range of addresses whose protection, type, and base allocation are the same. The type and protection values are described earlier in this technical article. The base allocation is the <em>lpAddress</em> parameter value that is used when the entire region of memory was first allocated via the <strong>VirtualAlloc</strong> function. It is represented in the <strong>MEMORY_BASIC_INFORMATION</strong> structure as the <strong>AllocationBase</strong> field.</p>
<p>When free addresses become either reserved or committed, their base allocation is determined at that time. A region of memory is not static by any means. Once a single page in a region of reserved addresses becomes committed, the region is broken into one or more reserved regions and one committed region. This continues as pages of memory change state. Similarly, when one of several PAGE_READWRITE committed pages is changed to PAGE_READONLY protection, the region is broken into multiple, smaller regions.</p>
<h2 id="Conclusion"><a class="header-anchor" href="#Conclusion"></a>Conclusion</h2>
<p>The virtual memory management functions in Windows offer direct management of virtual memory in Windows NT. Each process’s 2 GB user address space is divided into regions of memory that are either reserved, committed, or free virtual addresses. A region is defined as a contiguous range of addresses in which the protection, type, and base allocation of each address is the same. Within each region are one or more pages of addresses that also carry protection and pagelock flag status bits.</p>
<p>The virtual memory management functions provide capabilities for applications to alter the state of pages in the virtual address space. An application can change the type of memory from committed to reserved or change the protection from PAGE_READWRITE to PAGE_READONLY to prevent access to a region of addresses. An application can lock a page into the working set for a process to minimize paging for a critical page of memory. The virtual memory functions are considered low-level functions, meaning they are relatively fast but they lack many high-level features.</p>
<hr>
<p><strong>Article link: <a href="http://xnerv.wang/msdn-managing-virtual-memory/">http://xnerv.wang/msdn-managing-virtual-memory/</a></strong><br>
Reprinted from: <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/ms810627.aspx">(MSDN) Managing Virtual Memory</a></p>

    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="分享这篇文章"
      
      
        data-wechat-qrcode-helper="请扫描二维码"
      
    >
    </div>
  </div>
  <script src="//cdn.jsdelivr.net/npm/social-share.js@1/dist/js/social-share.min.js"></script>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag"># 转载</a>
              <a href="/tags/Windows/" rel="tag"># Windows</a>
              <a href="/tags/MSDN/" rel="tag"># MSDN</a>
              <a href="/tags/Memory-Management/" rel="tag"># Memory Management</a>
              <a href="/tags/Virtual-Memory/" rel="tag"># Virtual Memory</a>
          </div>

        

      </footer>
    
  </article>
  
  
  

  </div>

  <!--hr/>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- xnerv.wang bottom ad -->
    <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-5173793122443057"
        data-ad-slot="1774750366"
        data-ad-format="auto"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <hr/-->


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-Memory-System-Overview"><span class="nav-text">Windows Memory System Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-Memory"><span class="nav-text">Virtual Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Free-Reserved-and-Committed-Virtual-Memory"><span class="nav-text">Free, Reserved, and Committed Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reserved-Addresses"><span class="nav-text">Reserved Addresses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Committed-Memory"><span class="nav-text">Committed Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Freeing-Virtual-Memory"><span class="nav-text">Freeing Virtual Memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Changing-Protection-on-Pages-of-Virtual-Memory"><span class="nav-text">Changing Protection on Pages of Virtual Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locking-Pages-of-Virtual-Memory"><span class="nav-text">Locking Pages of Virtual Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Querying-a-Process%E2%80%99s-Virtual-Memory"><span class="nav-text">Querying a Process’s Virtual Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xnerv Wang (xnervwang)"
      src="/portraits/nerv.png">
  <p class="site-author-name" itemprop="name">Xnerv Wang (xnervwang)</p>
  <div class="site-description" itemprop="description">Xnerv Wang (xnervwang) 的技术博客，主要涉及C/C++、数据库引擎开发、文件系统、TCP/IP与网络、分布式系统和Linux等领域，也会偶尔刷一刷LeetCode等题库。毕业于南京大学软件学院，曾经在腾讯、百度、微软上海等大型互联网企业工作，目前奋斗在微软西雅图，从事Azure上的MySQL/PostgreSQL开源数据库云服务开发。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">167</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2008 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-eye"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xnerv Wang (xnervwang)</span>
</div>

<div>
  <span>God's in his heaven. All's right with the world.</span>
</div>

        








  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=60335024";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "60335024");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>


        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  

  


  <!-- baidu tuijian -->
  <div id="hm_t_123"></div>
</body>
</html>
