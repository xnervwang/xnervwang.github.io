<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XNERV SURVEYS</title>
  
  <subtitle>God&#39;s in his heaven.&lt;br/&gt;All&#39;s right with the world.</subtitle>
  <link href="https://xnerv.wang/atom.xml" rel="self"/>
  
  <link href="https://xnerv.wang/"/>
  <updated>2023-08-21T02:40:00.360Z</updated>
  <id>https://xnerv.wang/</id>
  
  <author>
    <name>Xnerv Wang (xnervwang)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用VSCode代替Atom作为Markdown编辑器</title>
    <link href="https://xnerv.wang/use-vscode-instead-of-atom-as-markdown/"/>
    <id>https://xnerv.wang/use-vscode-instead-of-atom-as-markdown/</id>
    <published>2020-06-01T05:06:00.000Z</published>
    <updated>2023-08-21T02:40:00.360Z</updated>
    
    <content type="html"><![CDATA[<p>从大学开始我就有做编程笔记的习惯。最开始是写在txt文件中直接放本地硬盘，也因此由于不小心格式化硬盘而丢了一些原始的笔记。后来在云笔记开始兴起之后，使用过几年的为知笔记。再加上为知笔记有直接保存网页的插件，因此我也将浏览器收藏夹中收集的一些技术网页直接保存到了为知笔记中，避免了网页失效而造成的知识丢失（其实现在的技术博客会被套娃式地转载好多次，就算删除原始文章也基本能找到了。。。）。随着积累的没看过的网页越来越多，消耗的速度完全跟不上增长的速度，也慢慢开始总结和消化收集的网页上的知识，记录下要点并标注来源URL，因此开始转向了Markdown。我喜欢上Markdown的另一个原因是我有点很多码农都有的编程洁癖，对于富文本总是想调整好每一处的格式、颜色和字体，因此支持富文本的Word、网络云笔记啥的简直就是我的噩梦，而Markdown则拯救了我这样的强迫症。</p><p>几年前，为了找了一款可以在Windows平台上运行的满意的Markdown编辑器，我曾经试用和对比了能找到的几款Markdown编辑器。</p><p>作业部落的Cmd Markdown是当时我接触的完成度最高的Markdown编辑器，插入图片非常方便，各种辅助功能都已经事先做好，不需要自己去做一大堆的配置和安装插件，并且最大的特点是笔记会云同步备份在服务器上。我用过一段时间的Cmd Markdown，但最终还是迁走了。最大的原因是笔记是保存在编辑器的数据文件中，而不是以明文的md文件直接保存在本地。这让我有点不安，哪一天如果这个编辑器出了bug打不开程序，或者这编辑器背后的公司破产，我的数据可能就此付之一炬，而我没有任何办法导出我的文件。</p><p>马克飞翔是印象笔记Evernote的一个Markdown插件。我对马克飞翔的印象是UI做得很好，各种功能也很齐全。然而缺点跟Cmd Markdown是一样的，由于印象笔记的文件也是保存在数据文件中的，无法通过其它文本工具直接编辑。而我更希望将文件直接放在我的硬盘里，可以通过各种文本工具进行编辑。</p><p>我还用过一个叫做Typora的比较有特色的的Markdown编辑器。大多数的Markdown编辑器是将界面一分为二，左边写Markdown源码，右边是最终效果Preview，当然一般左边的编辑栏也会有一些基本的语法高亮。但Typora则是将两个界面整合在了一起，同时可以在源码视图和结果视图中进行切换。老实说这样的做法有利有弊，纯粹看个人喜好。Typora至今应该仍不支持File Tree，也就是说一次只能编辑一个文档，如果要同时编辑多个Markdown文档就需要同时打开多个Typora进程。我至今仍保留安装着Typora，并希望将来有机会能拿出来用用，虽然至今我仍未再次用过。</p><p>再后来，我开始使用github开源的Atom编辑器。有一个叫做Markdown Preview Enhanced的Atom插件，将一些常用的Markdown功能都整合到了一起，我非常喜欢这个插件。Atom应该是我使用时间最长且至今最为满意的Markdown编辑器了，配合各种Atom插件非常顺手，各种Markdown效果也基本满足我的需求。然后我再用Seafile搭建了个人云存储，将Markdown文件放在个人云盘里。</p><p>不知道是不是由于微软收购了github和微软大力推广VSCode的缘故，感觉Atom最近几年的更新已经很少了，而且经常会出现插件加载失败的问题。例如Atom官网论坛上的18年的帖子<a href="https://discuss.atom.io/t/is-atom-dead/55346">Is atom dead?</a>和19年的帖子<a href="https://discuss.atom.io/t/is-atom-dead-again/70550/23">Is atom dead, again?</a>都在讨论这个问题，相信不只是我的个人猜测。</p><p>而最后让我下定决心离开Atom的则是<a href="https://github.com/shd101wyy/markdown-preview-enhanced/issues/1380">Markdown Preview Enhanced not working in Atom 1.47.0 #1380</a>。我最爱的Markdown Preview Enhanced由于Atom的bug而彻底不能使用，但目前看来Atom方面的修复还遥遥无期。</p><p>很久以前我曾尝试过用VSCode写Markdown。当时Markdown Preview Enhanced还不支持VSCode，因此我在整合了一堆Markdown的插件后仍觉得效果不佳，因此放弃。不知道是不是Markdown Preview Enhanced的作者也察觉到了Atom正在走向死亡，因此也开始支持VSCode平台。在试用了最新的VSCode + Markdown Preview Enhanced后，我发现原本在Atom上常用的功能，在VSCode上都能找到，例如：</p><ul><li>Atom上可以用Tree View浏览目录结构，而VSCode自带File Explorer左侧边栏。</li><li>Atom上有Project Manager插件可以在左侧边栏上同时打开多个目录，这样我就可以将多个Markdown目录同时加入进来。而VSCode也支持Workspace的概念，可以将多个目录加入进来。</li><li>VSCode有和Atom类似的file-icons插件，可以在左侧边栏上针对不同类型的文件显示不同的icon便于区分。</li><li>VSCode自带minimap/autosave功能，而Atom上则是通过安装插件实现。</li><li>VSCode可以登录微软账号或github账号同步插件和配置。Atom则是通过安装插件实现，配置保存在指定Gist。但根据我使用了几年的体验，如果有多台电脑同步配置的情况下，经常会出现一些问题，因此我从去年开始屏蔽了Atom上的同步插件。</li><li>但遗憾的是，像Cmd Markdown等编辑器所支持的TOC大纲（就是有一个单独的窗口或者下拉菜单显示各级标题，类似Word的左侧边栏的大纲视图），在VSCode和Atom中都没有相应的插件可以支持，而只是可以在文章中插入TOC链接。我所希望的是有一个插件可以在VSCode的左侧边栏上可以显示TOC大纲，但目前暂未发现有这样的插件。</li></ul><hr><p><strong>本文地址：<a href="http://xnerv.wang/use-vscode-instead-of-atom-as-markdown/">http://xnerv.wang/use-vscode-instead-of-atom-as-markdown/</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从大学开始我就有做编程笔记的习惯。最开始是写在txt文件中直接放本地硬盘，也因此由于不小心格式化硬盘而丢了一些原始的笔记。后来在云笔记开始兴起之后，使用过几年的为知笔记。再加上为知笔记有直接保存网页的插件，因此我也将浏览器收藏夹中收集的一些技术网页直接保存到了为知笔记中，避</summary>
      
    
    
    
    <category term="程序员生活" scheme="https://xnerv.wang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="程序员生活" scheme="https://xnerv.wang/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B4%BB/"/>
    
    <category term="VSCode" scheme="https://xnerv.wang/tags/VSCode/"/>
    
    <category term="Atom" scheme="https://xnerv.wang/tags/Atom/"/>
    
    <category term="Markdown" scheme="https://xnerv.wang/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux X-Window的一些名词深究</title>
    <link href="https://xnerv.wang/linux-xwindow-investigation/"/>
    <id>https://xnerv.wang/linux-xwindow-investigation/</id>
    <published>2020-05-06T06:25:00.000Z</published>
    <updated>2023-08-21T02:40:00.139Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对X-Window、Xrdp、KDE、VNC等词半懂不懂，因此大致地调查了下。这篇文章包括了一些我自己的总结，因此可能有一些地方有不准确之处，敬请谅解。参考了<a href="http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php">http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php</a>。</p><p><strong>X-Window/X Protocol</strong>：在<a href="https://jin-yang.github.io/post/linux-xwindows-introduce.html">XWindow 简介</a>中有比较好的解释，这其实是一套图形接口（协议）。不同于Windows已经将图形接口与操作系统完全融为一体的做法，Linux的图形接口是可选的。而X-Window就是这样的一种图形接口。这个图形接口是属于CS架构的（client/server）。X Server负责画面的绘制和显示，以及接收用户的输入并传到给X Client。X Client负责处理传递过来的用户输入并决定呈现数据，然后由X Server来进行绘制。这与通常的对于CS架构的理解是相反的，与用户直接沟通的其实是X Server。</p><p>X-Window是一种协议，因此还需要具体的实现，例如Xfree86、Xorg，Xming和Xnest。</p><p><strong>X11R6</strong>：X Protocol version 11 Release 6（X协议第11版第六次发行）。</p><span id="more"></span><p><strong>Window Manager（WM）</strong>：个人看法，每一个窗口程序可能就对应一个（或多个？）X Client，而WM就是管理这些窗口移动、窗口大小和重叠显示的管理程序，常见的WM有GNOME、KDE、XFCE。</p><p><strong>远程桌面</strong>：当你从另一台电脑上（主要是Windows）上想要通过图形化界面操作远程Linux时需要用到。常见的图形化远程桌面连接协议是RDP和VNC。Windows远程桌面用的就是RDP。RDP和VNC的区别可以参考<a href="https://blog.csdn.net/Cheese_pop/article/details/102958997">VNC与RDP的区别</a>。VNC主要传图像，适用于瘦客户端。RDP主要传指令，适用于低速网络。此外微软还有一项针对RDP的增强技术RemoteFX。</p><p>常见的VNC服务器软件有vnc4server、TightVNC，RealVNC等。</p><p>常见的VNC客户端有RealVNC Viewer、Ultra VNC等。</p><p>而如果你想用Windows自带的远程桌面连接Linux机器时，就必须用RDP协议了。需要在Linux上装兼容RDP的服务器，例如<a href="https://wiki.archlinux.org/index.php/Xrdp">Xrdp</a>。Xrdp使用Xvnc，X11rdp或xorgxrdp作为后端（<a href="https://blog.csdn.net/Robinsone/article/details/46686531">XRDP与VNC的关系</a>）。如果在Windows Hyper-V中安装Ubuntu等，在登录的时候就需要从几个选项中选择一个后端。根据<a href="https://www.linuxquestions.org/questions/ubuntu-63/what-is-x11rdp-4175556435/">What is x11rdp?</a>和<a href="https://tigervnc.org/doc/Xvnc.html">Xvnc</a>中所提到的，X11rdp和Xvnc都属于X Server，用于显示“虚拟屏幕”，而不是物理屏幕。而<a href="https://wiki.archlinux.org/index.php/Xorg">Xorg</a>中证实了Xorg是X-Window的一种实现，那感觉Xorg和Xvnc等并不是同一个层面上的概念，Xorg包括了X Server和X Client，而Xvnc只是X Server的一种实现。同时Xvnc对于用户而言又是VNC Server。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/linux-xwindow-investigation/">http://xnerv.wang/linux-xwindow-investigation/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直以来对X-Window、Xrdp、KDE、VNC等词半懂不懂，因此大致地调查了下。这篇文章包括了一些我自己的总结，因此可能有一些地方有不准确之处，敬请谅解。参考了&lt;a href=&quot;http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php&quot;&gt;http://cn.linux.vbird.org/linux_basic/0590xwindow_1.php&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X-Window/X Protocol&lt;/strong&gt;：在&lt;a href=&quot;https://jin-yang.github.io/post/linux-xwindows-introduce.html&quot;&gt;XWindow 简介&lt;/a&gt;中有比较好的解释，这其实是一套图形接口（协议）。不同于Windows已经将图形接口与操作系统完全融为一体的做法，Linux的图形接口是可选的。而X-Window就是这样的一种图形接口。这个图形接口是属于CS架构的（client/server）。X Server负责画面的绘制和显示，以及接收用户的输入并传到给X Client。X Client负责处理传递过来的用户输入并决定呈现数据，然后由X Server来进行绘制。这与通常的对于CS架构的理解是相反的，与用户直接沟通的其实是X Server。&lt;/p&gt;
&lt;p&gt;X-Window是一种协议，因此还需要具体的实现，例如Xfree86、Xorg，Xming和Xnest。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X11R6&lt;/strong&gt;：X Protocol version 11 Release 6（X协议第11版第六次发行）。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://xnerv.wang/categories/Linux/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="Linux" scheme="https://xnerv.wang/tags/Linux/"/>
    
    <category term="图形界面" scheme="https://xnerv.wang/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    
    <category term="X-Window" scheme="https://xnerv.wang/tags/X-Window/"/>
    
    <category term="X协议" scheme="https://xnerv.wang/tags/X%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="远程桌面" scheme="https://xnerv.wang/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>在美国第一次购买和使用树莓派时遇到的一些问题</title>
    <link href="https://xnerv.wang/the-first-time-to-buy-and-use-raspberry-in-usa/"/>
    <id>https://xnerv.wang/the-first-time-to-buy-and-use-raspberry-in-usa/</id>
    <published>2020-04-29T00:43:00.000Z</published>
    <updated>2023-08-21T02:40:00.357Z</updated>
    
    <content type="html"><![CDATA[<p>新买了一个Raspberry Pi 4 Model B，第一次使用树莓派，遇到一些问题，记录下来希望对自己和他人所有帮助。</p><h2 id="买什么套装"><a class="header-anchor" href="#买什么套装"></a>买什么套装</h2><p>虽然在我买的时候2GB款的树莓派4B税前价格是35刀，但是亚马逊上是不直接卖板子的，一些要捆绑一些配件像Micro SD卡、电源、散热片、Micro HDMI线啥的。众所周知美国这边的各种线卖的巨贵无比，国内淘宝9块9包邮的线，在这边可能就是20刀不包税。而像CanaKit等可以直接卖板子的网站，则一般需要6到7刀左右的邮费。最后我还是在亚马逊上买了一个包括电源和三块散热片的套装，税前45刀左右。</p><p>树莓派4B的电源线是5V3A Type-C接口，我看了一下现在手机的充电线大多是5V2A这个样子，据说只要别接太多额外负载，手机充电线也是可以的。散热片不确定是否是必须的，我在不接散热片的情况下尽跑翻墙代理程序的时候在45摄氏度左右，但西雅图这边气温比较低，夏天最高温度也就32到34摄氏度左右。如果是在国内温度比较高的地区，建议还是贴散热片比较保险。</p><p>盒子的话淘宝20块就能买个很好的了，美国这边差不多20刀不包税。估计盒子会对散热造成一定负面影响，因此还是建议至少贴散热片。另外我一直在找有没有能装下一个2.5英寸或者3.5英寸硬盘的树莓派盒子，但是淘宝和亚马逊上都没有找到，移动硬盘只能单独放盒子外面，通过USB和树莓派连接在一起了。</p><p>如果是把树莓派作为翻墙代理等服务器用途的话，Micro HDMI不是必须的，我下面会讲到怎么远程初始化树莓派。</p><span id="more"></span><h2 id="没有Micro-HDMI线"><a class="header-anchor" href="#没有Micro-HDMI线"></a>没有Micro HDMI线</h2><p>第一次知道有Micro HDMI接口，所以很显然我没有这种线。电脑大多使用的都是普通大小的HDMI线。在美国买线相当划不来，一个这样的线得一、二十刀。所以我通过网线将树莓派接在路由器上，然后通过远程SSH的方式连接到树莓派上进行配置。</p><p>但是需要注意的是，虽然安装树莓派系统有两种方式（<a href="https://zhuanlan.zhihu.com/p/59027897">如何给树莓派安装操作系统</a>）：<br>方式一：将NOOBS写入Micro SD卡<br>方式二：直接将操作系统镜像写入Micro SD卡</p><p>但方式一应该是需要将树莓派连接显示器才能操作安装程序的，所以我用的第二种方式，直接将操作系统Raspbian镜像写入Micro SD卡。树莓派上有一个Micro SD卡读卡器，需要将安装了Raspbian的Micro SD卡插入这里。</p><p>此外，树莓派4B的SSH默认是关闭的，在写入镜像完成后，还需要通过电脑在Micro SD里创建一个文件名为SSH的空文件。然后将Micro SD卡插入树莓派卡槽，通电后SSH Server才会启动，这样才能通过SSH Client连接上去。</p><p>然后问题来了，SSH连接的时候如何得知树莓派的IP？如果是自己家，你有路由器的管理密码的话，登录进去找找看所有连接上来的设备，看有没有类似Raspberry名字的设备连接上来。如果没有路由器的管理密码或者想偷懒的话，可以参考<a href="https://blog.wangpengpeng.site/2020/02/28/%E5%A6%82%E4%BD%95%E8%BF%99%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%A0%91%E8%8E%93%E6%B4%BEIP%EF%BC%9F/#%E6%9C%80%E5%AE%9E%E9%99%85%E9%83%BD%E5%8A%9E%E6%B3%95">如何这没有显示器的情况下获取树莓派IP？</a>这篇文章，或者用ipscan等局域网内IP扫描工具直接扫描所有IP。</p><h2 id="启用WIFI"><a class="header-anchor" href="#启用WIFI"></a>启用WIFI</h2><p>按照从网上找到的一些教程（例如<a href="https://www.cirmall.com/articles/27944">树莓派4B，3B+和3B，如何配置WiFi和蓝牙</a>），我在执行<code>sudo iwlist wlan0 scan</code>的时候遇到了类似<code>interface doesnt support scanning</code>的错误信息。在执行<code>sudo ifconfig wlan0 up</code>的时候，则遇到了<code>SIOCSIFFLAGS: Operation not possible due to RF-kill</code>的错误信息。据查rfkill是管理WIFI和蓝牙功能的一个软开关，跟控制耗电相关。根据<a href="https://blog.csdn.net/fickyou/article/details/50885824">SIOCSIFFLAGS: Operation not possible due to RF-kill</a>关闭了相关的设置后解决问题。</p><h2 id="通过蓝牙SSH"><a class="header-anchor" href="#通过蓝牙SSH"></a>通过蓝牙SSH</h2><p>参考了一下文章但目前暂时未能解决这个问题，主要的问题是我的笔记本检测不到树莓派的蓝牙信号，虽然我的手机能够检测到树莓派的蓝牙。通过蓝牙SSH并不是刚需，等以后如果我能解决这个问题的时候再补完这一部分。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/the-first-time-to-buy-and-use-raspberry-in-usa/">http://xnerv.wang/the-first-time-to-buy-and-use-raspberry-in-usa/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;新买了一个Raspberry Pi 4 Model B，第一次使用树莓派，遇到一些问题，记录下来希望对自己和他人所有帮助。&lt;/p&gt;
&lt;h2 id=&quot;买什么套装&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#买什么套装&quot;&gt;&lt;/a&gt;买什么套装&lt;/h2&gt;
&lt;p&gt;虽然在我买的时候2GB款的树莓派4B税前价格是35刀，但是亚马逊上是不直接卖板子的，一些要捆绑一些配件像Micro SD卡、电源、散热片、Micro HDMI线啥的。众所周知美国这边的各种线卖的巨贵无比，国内淘宝9块9包邮的线，在这边可能就是20刀不包税。而像CanaKit等可以直接卖板子的网站，则一般需要6到7刀左右的邮费。最后我还是在亚马逊上买了一个包括电源和三块散热片的套装，税前45刀左右。&lt;/p&gt;
&lt;p&gt;树莓派4B的电源线是5V3A Type-C接口，我看了一下现在手机的充电线大多是5V2A这个样子，据说只要别接太多额外负载，手机充电线也是可以的。散热片不确定是否是必须的，我在不接散热片的情况下尽跑翻墙代理程序的时候在45摄氏度左右，但西雅图这边气温比较低，夏天最高温度也就32到34摄氏度左右。如果是在国内温度比较高的地区，建议还是贴散热片比较保险。&lt;/p&gt;
&lt;p&gt;盒子的话淘宝20块就能买个很好的了，美国这边差不多20刀不包税。估计盒子会对散热造成一定负面影响，因此还是建议至少贴散热片。另外我一直在找有没有能装下一个2.5英寸或者3.5英寸硬盘的树莓派盒子，但是淘宝和亚马逊上都没有找到，移动硬盘只能单独放盒子外面，通过USB和树莓派连接在一起了。&lt;/p&gt;
&lt;p&gt;如果是把树莓派作为翻墙代理等服务器用途的话，Micro HDMI不是必须的，我下面会讲到怎么远程初始化树莓派。&lt;/p&gt;</summary>
    
    
    
    <category term="树莓派" scheme="https://xnerv.wang/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="树莓派" scheme="https://xnerv.wang/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Raspberry" scheme="https://xnerv.wang/tags/Raspberry/"/>
    
  </entry>
  
  <entry>
    <title>为什么PostgreSQL要使用OS缓存？</title>
    <link href="https://xnerv.wang/why-pg-uses-os-cache/"/>
    <id>https://xnerv.wang/why-pg-uses-os-cache/</id>
    <published>2020-01-02T02:47:00.000Z</published>
    <updated>2023-08-21T02:40:00.047Z</updated>
    
    <content type="html"><![CDATA[<p>与MySQL等开源数据库不同的是，PostgreSQL（PG）并不使用O_DIRECT来写data文件，而是依赖于OS缓存，并且强调在设置shared buffer在大小时不能过大，否则会造成过于频繁的swap而导致IO性能下降。这与MySQL等数据库的buffer pool size越大性能越好的指导原则是相反的。并且PG依赖于OS缓存的这一特性也给提供PostgreSQL云服务造成了很多问题。例如云服务要求multiple tenants资源隔离，也就是说跑在同一个VM上的多个PG servers相互之间不能互相影响，但共用OS缓存显然会造成资源竞争。不知道Docker是否可以进行OS缓存的资源隔离，但现阶段还还依赖于Service Fabric架构的Azure PG显然得自己解决这个问题，也因此造成了架构设计上不得不考虑OS缓存的隔离。</p><p>从<a href="http://www.interdb.jp/pg/pgsql02.html">The Internals of PostgreSQL: Chapter 2 Process and Memory Architecture</a>这篇文章看来，与MySQL使用多线程或线程池和架构不同的是，PG使用的是多进程架构。多进程模型在Windows平台上会造成很大的性能问题，这暂且不提。但多进程之间是共用的shared buffer。既然如此，那就应该不是寄希望于OS缓存来便于多进程之间共享shared buffer吧。</p><span id="more"></span><p><img src="/assets/why-pg-uses-os-cache/1.png" alt=""></p><p><img src="/assets/why-pg-uses-os-cache/2.png" alt=""></p><p><a href="http://liuyangming.tech/10-2019/INNODB-vs-PgSQL-buffer.html">PgSQL和MySQL的bufferpool探讨</a>这篇文章提出了一种猜想，认为由于PostgreSQL是诞生在实验室中，主要为了研究数据库内核原理，那么使用buffer io能够减少IO栈的代码开发，进而能够减少额外的debug。这种说法是有可能的、虽然PG的代码比MySQL的干净太多，MySQL的代码中经常有类似xxx_function，xxx_function2，another_xxx_function2这种奇怪的函数名字，而且毫无注释完全不明所以。但是PG很明显在工程化和成熟度上不如MySQL。文章中提到PG中有这么一段代码：</p><p><img src="/assets/why-pg-uses-os-cache/3.png" alt=""></p><p>也就是说PG依赖于OS缓存来减少日志归档和流复制中的文件IO读取次数。但这应该仅限于WAL xlog文件。对于shared buffer pool，是什么原因使得还需要保留这种double buffering的设计呢？</p><p><a href="http://www.interdb.jp/pg/pgsql08.html">The Internals of PostgreSQL: Chapter 8 Buffer Manager</a>提到可以参考<a href="https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">Why we are going to have to go DirectIO</a>这篇讨论和<a href="https://lwn.net/Articles/580542/">Thread summary: the Linux kernel and PostgreSQL</a>这篇文章。目前看来，应该还是PG的storage layer实现上过于简陋，效率上存在很大的问题，不足以脱离OS缓存而独自运行。这也印证了<a href="http://liuyangming.tech/10-2019/INNODB-vs-PgSQL-buffer.html">PgSQL和MySQL的bufferpool探讨</a>这篇文章的说法。<a href="https://madusudanan.com/blog/understanding-postgres-caching-in-depth/#OSCaching">Understanding caching in Postgres - An in-depth guide</a>这里也提到，PG依赖于OS缓存来调度写请求，这恐怕也是PG storage layer本身缺乏相应调度机制的一种表现。</p><p><a href="https://lwn.net/Articles/591723/">PostgreSQL pain points</a>中也有提到flow fsync和double buffering等问题，看起来PG的developers依赖于Linux kernel提供相应的解决方案。我不知道这是否是一种正确的方向，毕竟这种与特定OS紧耦合的方案也就限制了PG在其它OS平台上运行的能力。但是考虑到现在PG本来就在Windows上跑得很差像个demo，如果PG本身的开发力量不够的话，也许这也算是一种解决方案吧。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/why-pg-uses-os-cache/">http://xnerv.wang/why-pg-uses-os-cache/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与MySQL等开源数据库不同的是，PostgreSQL（PG）并不使用O_DIRECT来写data文件，而是依赖于OS缓存，并且强调在设置shared buffer在大小时不能过大，否则会造成过于频繁的swap而导致IO性能下降。这与MySQL等数据库的buffer pool size越大性能越好的指导原则是相反的。并且PG依赖于OS缓存的这一特性也给提供PostgreSQL云服务造成了很多问题。例如云服务要求multiple tenants资源隔离，也就是说跑在同一个VM上的多个PG servers相互之间不能互相影响，但共用OS缓存显然会造成资源竞争。不知道Docker是否可以进行OS缓存的资源隔离，但现阶段还还依赖于Service Fabric架构的Azure PG显然得自己解决这个问题，也因此造成了架构设计上不得不考虑OS缓存的隔离。&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;http://www.interdb.jp/pg/pgsql02.html&quot;&gt;The Internals of PostgreSQL: Chapter 2 Process and Memory Architecture&lt;/a&gt;这篇文章看来，与MySQL使用多线程或线程池和架构不同的是，PG使用的是多进程架构。多进程模型在Windows平台上会造成很大的性能问题，这暂且不提。但多进程之间是共用的shared buffer。既然如此，那就应该不是寄希望于OS缓存来便于多进程之间共享shared buffer吧。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="PostgreSQL" scheme="https://xnerv.wang/tags/PostgreSQL/"/>
    
    <category term="PG" scheme="https://xnerv.wang/tags/PG/"/>
    
  </entry>
  
  <entry>
    <title>如果阿里月饼黑客事件发生在谷歌会怎样？前Google人亲述他抢了50件T-shirt的故事（转载）</title>
    <link href="https://xnerv.wang/google-50-tshirt/"/>
    <id>https://xnerv.wang/google-50-tshirt/</id>
    <published>2020-01-02T01:47:00.000Z</published>
    <updated>2023-08-21T02:40:00.380Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者吴卓浩，前Google中国用户体验团队负责人。微信公众号、知乎号：uxbang</em></p><p>2016年中秋节，被阿里的月饼门刷屏了。知乎上有人发起了讨论，“如果这样的事发生在Google会怎样”——如果也和阿里一样，我看着柜子里的差不多50件Google T-shirt，一头汗。</p><p>月饼事件的热闹，在于各种人都能从各种角度做各种分析评论。但是无论真相如何，上半场已经结束，希望那几位兄弟们吸取教训、但不要被吓怕，接下来的发展一定会有自己的精彩；而下半场才刚刚开始，对这几位兄弟来说是，对阿里，对整个行业，甚至对更大的体系，都是。</p><p>不论对于一个普通员工，还是对于一个公司的老大，公司 VS 个人，文化 VS 制度，永远是无法回避的问题，而且是没有标准解答的问题。比如，为了提高工作效率：</p><p>在一个初创公司中经常是没有标准流程的效率更高，而在一个大公司中是有标准流程效率更高；</p><p>在一个内容创作型的公司中，追随热点、快速响应的效率更高，而在一个产品研发型的公司中，做好计划、理清流程的效率更高；</p><p>在一个业务稳定成熟的公司中，以KPI推动工作效率更高，而在一个业务快速创新的公司中，以OKR推动工作效率更高；</p><span id="more"></span><p>创始人能力强，开始时亲力亲为效率高，可是如果不能接下来把中层建立培养起来，公司发展效率就不会高；</p><p>个别员工能力强，单兵作战效率高，可是如果不能把个体能力变为团队能力，团队战斗效率就不会高；</p><p>事事靠老大拿主意，眼前完成任务效率高，可是如果不能让员工形成独立思考能力，老大累死也不会得到真正的效率；</p><p>用制度管人，能马上见效的效率高，可是如果不能让员工形成文化上的认同和判断力，压力有多大反弹就会有多强；</p><p><img src="/assets/google-50-tshirt/1.jpg" alt="谁动了我的月饼"></p><p>公司本身也是一个产品，一个由创始人、员工、利益相关方、用户共同设计、不断迭代的产品，一直在路上、不断更成熟、永远不完美的产品。对我来说，如果在公司 中的人做的事情出了问题，无论是出于善意、恶意或者无意，首先需要反思的是公司的组织、制度、流程本身，最重要的是以此为契机改进公司本身。</p><p>过去的十多年，在我所服务或者创立的公司中，我也有不少请员工离开的经历，但每次都会深深自责反思，因为没有不合适的员工，只有不合适的工作，而把TA带进 来、放在不合适的位置上的人，是我。甚至当员工在工作上出现失误，造成公司不小的损失，我只会严肃的让员工明白事情的严重性、如何改进公司的系统来避免问 题再次发生，而损失由自己去承担，因为我能承担，而员工的经济状况无法承担。</p><p>在Google的面试中，除了对于工作能力的各项判断，最后还 有特别的一项：这个人是否Googley？Googley是Google自创的一个词，这个问题的含义是，这个人像不像Google人？对Googley 这个词，Google没有官方的定义，它具体的含义没人知道、却又人人明白；就像判例法，没有人去自上而下规定Google人应该怎么做，但是大家都互相 耳濡目染的学会要怎么做。</p><p>所以，当新来的刚毕业的大学生沉醉于零食间，没有人会去鄙视；当有人带朋友来蹭饭，公司提醒如果人多要提前和厨房 说、否则会影响到其他同事吃不上饭（接待旅游团，以此挣钱，显然是另一回事，这已经是靠出售公司资源谋私利，在任何文化下都不会被允许）。因为 Google人相信留在Google的同伴总归会变得Googley。</p><p>当员工为了抢每周补充的免费T-shirt，写程序、装监控摄像头， 是开放出一个邮件列表，让以此为乐的同事都能参与；当员工班车出现问题的时候，员工会自发组织起来，跨部门协作，以工程研发的方式做数据采集、写算法程 序，达成真正满足大多数人的解决方案。因为在Google，为全世界用户设计和开发产品，也正是这么做的呀！</p><p>开头所说的Google T-shirt，是我2006-2010年间收藏的，其实还不止这些，有的已经被亲朋好友强行索要走。Google有印制T-shirt庆祝产品上线或者 活动发布的文化，用户体验部门几乎是跨产品跨部门协作最多的，自然就获得了更多沾光的机会。每次整理这些T-shirt，都忍不住回想起背后的一个个人和 故事，心里暖暖的。这也是Google文化的强大之处，无论在不在Google，无论当时是因为什么原因离开Google，（曾经的）Google人都被 心中的Google文化仅仅团结在一起。</p><p>谢谢Google不会因为我抢了这么多T-shirt开除我！：）</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/google-50-tshirt/">http://xnerv.wang/google-50-tshirt/</a></strong><br>转载自：<a href="https://www.techug.com/post/google-50-tshirt.html">如果阿里月饼黑客事件发生在谷歌会怎样？前Google人亲述他抢了50件T-shirt的故事</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文作者吴卓浩，前Google中国用户体验团队负责人。微信公众号、知乎号：uxbang&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2016年中秋节，被阿里的月饼门刷屏了。知乎上有人发起了讨论，“如果这样的事发生在Google会怎样”——如果也和阿里一样，我看着柜子里的差不多50件Google T-shirt，一头汗。&lt;/p&gt;
&lt;p&gt;月饼事件的热闹，在于各种人都能从各种角度做各种分析评论。但是无论真相如何，上半场已经结束，希望那几位兄弟们吸取教训、但不要被吓怕，接下来的发展一定会有自己的精彩；而下半场才刚刚开始，对这几位兄弟来说是，对阿里，对整个行业，甚至对更大的体系，都是。&lt;/p&gt;
&lt;p&gt;不论对于一个普通员工，还是对于一个公司的老大，公司 VS 个人，文化 VS 制度，永远是无法回避的问题，而且是没有标准解答的问题。比如，为了提高工作效率：&lt;/p&gt;
&lt;p&gt;在一个初创公司中经常是没有标准流程的效率更高，而在一个大公司中是有标准流程效率更高；&lt;/p&gt;
&lt;p&gt;在一个内容创作型的公司中，追随热点、快速响应的效率更高，而在一个产品研发型的公司中，做好计划、理清流程的效率更高；&lt;/p&gt;
&lt;p&gt;在一个业务稳定成熟的公司中，以KPI推动工作效率更高，而在一个业务快速创新的公司中，以OKR推动工作效率更高；&lt;/p&gt;</summary>
    
    
    
    <category term="程序员生活" scheme="https://xnerv.wang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="程序员生活" scheme="https://xnerv.wang/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E6%B4%BB/"/>
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="阿里月饼" scheme="https://xnerv.wang/tags/%E9%98%BF%E9%87%8C%E6%9C%88%E9%A5%BC/"/>
    
  </entry>
  
  <entry>
    <title>让 CPU 告诉你硬盘和网络到底有多慢（转载）</title>
    <link href="https://xnerv.wang/how-slow-is-disk-and-network/"/>
    <id>https://xnerv.wang/how-slow-is-disk-and-network/</id>
    <published>2019-12-28T08:29:00.000Z</published>
    <updated>2023-08-21T02:40:00.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p>经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。</p><p>最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。</p><p>希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。</p><p>注：所有的数据都是来自<a href="https://gist.github.com/hellerbarde/2843375">这个地址</a>。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，<a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html">这个网址</a>给出了不同年份一些指标的数值。</p><span id="more"></span><h2 id="数据"><a class="header-anchor" href="#数据"></a>数据</h2><ul><li><p>先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 2.6*10^9 个指令，每个指令只需要 0.38ns（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 1s，因为 1s 大概是人类能感知的最小时间单位。<br><img src="/assets/how-slow-is-disk-and-network/1.jpg" alt=""></p></li><li><p>一级缓存读取时间为 0.5ns，换算成人类时间大约是 1.3s，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。</p></li><li><p>分支预测错误需要耗时 5ns，换算成人类时间大约是 13s，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如<a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">这个得分非常高的 stackoverflow 问题</a>。</p></li><li><p>二级缓存时间就比较久了，大约在 7ns，换算成人类时间大约是 18.2s，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。</p></li></ul><p><strong>小知识</strong>：为什么需要多层的 CPU 缓存呢？<a href="https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/">这篇文章通过一个通俗易懂的例子给出了讲解</a>。</p><ul><li><p>我们继续，互斥锁的加锁和解锁时间需要 25ns，换算成人类时间大约是 65s，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。</p></li><li><p>然后就到了内存，每次内存寻址需要 100ns，换算成人类时间是 260s，也就是4分多钟，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。看起来还不算坏，不多要从内存中读取一段数据需要的时间会更多。到了内存之后，时间就变了一个量级，CPU 和内存之间的速度瓶颈被称为<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck">冯诺依曼瓶颈</a>。</p></li><li><p>一次 CPU 上下文切换（系统调用）需要大约 1500ns，也就是 1.5us（这个数字参考了<a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">这篇文章</a>，采用的是单核 CPU 线程平均时间），换算成人类时间大约是 65分钟，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，<strong>这段时间里 CPU 没有做任何有用的计算</strong>，只是切换了两个不同进程的寄存器和内存状态；而且这个过程<strong>还破坏了缓存</strong>，让后续的计算更加耗时。</p></li><li><p>在 1Gbps 的网络上传输 2K 的数据需要 20us，换算成人类时间是 14.4小时，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。</p></li><li><p>SSD 随机读取耗时为 150us，换算成人类时间大约是 4.5天。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。I/O 设备 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 memcached 和 redis 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。</p></li><li><p>从内存中读取 1MB 的连续数据，耗时大约为 250us，换算成人类时间是 7.5天，这次假期升级到国庆七天国外游了。</p></li><li><p>同一个数据中心网络上跑一个来回需要 0.5ms，换算成人类时间大约是 15天，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。</p></li><li><p>从 SSD 读取 1MB 的顺序数据，大约需要 1ms，换算成人类时间是 1个月。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，<strong>SSD</strong> 已经很快啦，不信你看下面机械磁盘的表现。</p></li><li><p>磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 RPM(Revolutions Per Minute/每分钟转速) 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。</p></li><li><p>从磁盘读取 1MB 连续数据需要 20ms，换算成人类时间是 20个月。<strong>IO 设备是计算机系统的瓶颈</strong>，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。</p></li><li><p>而从世界上不同城市网络上走一个来回，平均需要 150ms（参考<a href="https://wondernetwork.com/pings/">世界各地 ping 报文的时间</a>），换算成人类时间是 12.5年。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，<a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDN</a> 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。</p></li><li><p>虚拟机重启一次大约要 4s 时间，换算成人类的时间是 3百多年。对于此，我想到了乔布斯要死命<a href="http://stevejobsdailyquote.com/2014/03/26/boot-time/">优化 Mac 系统开机启动时间</a>的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。</p></li><li><p>物理服务器重启一次需要 5min，换算成人类时间是 2万5千年，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。</p></li></ul><h2 id="参考资料"><a class="header-anchor" href="#参考资料"></a>参考资料</h2><ul><li><a href="https://www.akkadia.org/drepper/cpumemory.pdf">What Every Programmer Should Know About Memory</a></li><li><a href="http://duartes.org/gustavo/blog/post/getting-physical-with-memory/">Getting Physical With Memory</a></li></ul><hr><p><strong>本文地址：<a href="http://xnerv.wang/how-slow-is-disk-and-network/">http://xnerv.wang/how-slow-is-disk-and-network/</a></strong><br>转载自：<a href="https://cizixs.com/2017/01/03/how-slow-is-disk-and-network/">让 CPU 告诉你硬盘和网络到底有多慢</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。&lt;/p&gt;
&lt;p&gt;最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。&lt;/p&gt;
&lt;p&gt;希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。&lt;/p&gt;
&lt;p&gt;注：所有的数据都是来自&lt;a href=&quot;https://gist.github.com/hellerbarde/2843375&quot;&gt;这个地址&lt;/a&gt;。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，&lt;a href=&quot;https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html&quot;&gt;这个网址&lt;/a&gt;给出了不同年份一些指标的数值。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机硬件" scheme="https://xnerv.wang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="性能瓶颈" scheme="https://xnerv.wang/tags/%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/"/>
    
    <category term="CPU" scheme="https://xnerv.wang/tags/CPU/"/>
    
    <category term="内存访问" scheme="https://xnerv.wang/tags/%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE/"/>
    
    <category term="网络传输" scheme="https://xnerv.wang/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
    <category term="分支预测" scheme="https://xnerv.wang/tags/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/"/>
    
    <category term="硬盘" scheme="https://xnerv.wang/tags/%E7%A1%AC%E7%9B%98/"/>
    
    <category term="SSD" scheme="https://xnerv.wang/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>为什么Docker能运行不同的Linux发行版？</title>
    <link href="https://xnerv.wang/why-docker-has-ability-to-run-different-linux-distribution/"/>
    <id>https://xnerv.wang/why-docker-has-ability-to-run-different-linux-distribution/</id>
    <published>2019-12-26T07:58:00.000Z</published>
    <updated>2023-08-21T02:40:00.138Z</updated>
    
    <content type="html"><![CDATA[<p>结合<a href="https://stackoverflow.com/questions/18786209/what-is-the-relationship-between-the-docker-host-os-and-the-container-base-image">What is the relationship between the docker host OS and the container base image OS?</a>、<a href="https://stackoverflow.com/questions/32841982/how-can-docker-run-distros-with-different-kernels">How can Docker run distros with different kernels?</a>和[Why docker has ability to run different linux distribution?(<a href="https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution">https://stackoverflow.com/questions/25444099/why-docker-has-ability-to-run-different-linux-distribution</a>)这几篇文章看来，Docker实例和Host OS之间通讯的唯一桥梁就是Host OS的内核。挡在Fedora上跑一个Ubuntu 16.04的Docker实例时，Docker实例用的内核仍然是Fedora的内核，而不是Ubuntu 16.04所对应的的内核，因此有可能和原生的Ubuntu 16.04有一些内核上的区别。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/why-docker-has-ability-to-run-different-linux-distribution/">http://xnerv.wang/why-docker-has-ability-to-run-different-linux-distribution/</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;结合&lt;a href=&quot;https://stackoverflow.com/questions/18786209/what-is-the-relationship-between-the-docker-host-os-and-the-container-base-image&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://xnerv.wang/categories/Linux/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="Linux" scheme="https://xnerv.wang/tags/Linux/"/>
    
    <category term="Docker" scheme="https://xnerv.wang/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>关于MinGW和Cygwin的一些个人总结和推测</title>
    <link href="https://xnerv.wang/mingw-cygwin-summary-and-thinking/"/>
    <id>https://xnerv.wang/mingw-cygwin-summary-and-thinking/</id>
    <published>2019-12-25T23:40:00.000Z</published>
    <updated>2023-08-21T02:40:00.425Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对MinGW和Cygwin相关的一些名词的研究和推测，以求澄清一些似乎而非的概念，并记录当前已经弄清楚的一些问题，以及还需要进一步调研的一些细节。所有调研都基于Windows平台。</p><h2 id="关于MinGW和Cygwin的关系"><a class="header-anchor" href="#关于MinGW和Cygwin的关系"></a>关于MinGW和Cygwin的关系</h2><p>网上大部分博文复制粘贴的文章都是讨论MinGW和Cygwin的区别和优劣。而我主要是分析两者的联系，以及一些需要同时用到MinGW和Cygwin的交叉编译场景。</p><p>从<a href="https://en.wikipedia.org/wiki/MinGW">MinGW的维基百科</a>上看，Cygwin是提供一个模拟的POSIX层（cygwin1.dll）。我推测Cygwin也提供了一系列基于Cygwin的编译工具，在将需要移植的Linux代码在Cygwin上重新编译后，可以获得可以在Windows上直接运行的exe，而这个exe调用的还是POSIX风格的API，只不过这些API由cygwin1.dll提供模拟实现。而MinGW也提供了一系列编译工具，但MinGW-GCC是在编译时将代码中的POSIX API调用直接修改为对应的Windows API调用，从而不需要一个额外的dll转换层。需要额外提到的是，gcc的这种在编译时直接修改调用的API的行为不仅不少见，而且非常常见，在64位Linux上编译C++程序时，例如调用open这个函数，实际上在gcc编译后，调用的是libc中的open64函数，这个可以通过objdump导出外部依赖符号表来确认。另外就是，MinGW并不提供某些难以用Windows API实现的POSIX API，例如fork()，mmap()和ioctl()。</p><span id="more"></span><h2 id="MinGW和MinGW-w64"><a class="header-anchor" href="#MinGW和MinGW-w64"></a>MinGW和MinGW-w64</h2><p>MinGW（mingw32）据说更新太慢代码太老，因此另一帮人就新搞了一个MinGW-w64，据说老的MinGW不支持编译64位程序。不知道是不是这就意味着可以完全放弃掉MinGW而直接采用MinGW-x64？</p><p>在安装MinGW时需要选择线程模型：posix或win32。从<a href="https://stackoverflow.com/questions/17242516/mingw-w64-threads-posix-vs-win32">mingw-w64 threads: posix vs win32</a>看来，win32是在C++11之前MinGW-GCC搞的一套基于win32 threads模型的多线程库，而posix则是基于libwinpthreads，支持C++11的一些新的头文件。有另外一个单独的GitHub项目<a href="https://github.com/meganz/mingw-std-threads">mingw-std-threads</a>可以让win32模型也支持这些C++11头文件。</p><p>MinGW-w64可以安装在Windows上，可以安装在Linux上，甚至可以安装在Cygwin里（<a href="https://cygwin.com/install.html">而CygWin看起来只能安装在Windows中</a>）。MinGW（mingw32）好像有另外一个相关项目<a href="http://www.mingw.org/wiki/linuxcrossmingw">MinGW cross compiling environment</a>提供Linux安装，但感觉项目不是很活跃。并且从这篇<a href="https://mxe.cc/#history">更新日志</a>来看，似乎作者已经放弃更新并转向MinGW-w64。</p><h2 id="MSYS"><a class="header-anchor" href="#MSYS"></a>MSYS</h2><p>根据<a href="http://www.mingw.org/wiki/msys">MinGW官网对于MSYS的描述</a>，MSYS是对MinGW的补充，提供了bash，make， gawk和grep等GNU工具来辅助编译。从网上可以找到的一些MinGW编译入门文章来看，完全可以在Windows cmd环境中调用MinGW的gcc命令行去编译基于MinGW的Windows程序，并不是一定需要在bash环境中进行，但是像bash脚本这种应该还是需要bash环境的。另外据说<a href="https://github.com/msys2/msys2/wiki/History">MSYS是从Cygwin派生出来的分支</a>，本来我推测像MSYS中的gcc应该是运行在cygwin1.dll或者类似名字的dll模拟层上。但是检查了gcc的dll依赖关系：<br><img src="/assets/mingw-cygwin-summary-and-thinking/mingw-gcc-dep.png" alt=""></p><p>发现MinGW上的gcc最终似乎是直接依赖于Windows的dlls，并没有类似cygwin1.dll的东西。这种有点奇怪了，难道这个gcc是通过Cygwin上的MinGW-GCC用自举（bootstrapping）的方式创建出来的？找到关于MinGW-x64有关自举编译的一篇文章<a href="https://sourceforge.net/p/mingw-w64/wiki2/Native%20Win64%20compiler/">Creating a native Win64 compiler</a>，我怀疑MinGW是不是也是用的类似的自举编译gcc。</p><p>但是再看bash的话，bash.exe却还是依赖于msys1.0.dll以及其它一些msys开头的dlls。猜测这些dlls应该就是类似于cygwin1.dll的模拟层。MinGW和MSYS是通过同一个安装程序来安装，推测由于gcc.exe属于MinGW，而bash.exe属于MSYS，而只有MSYS的工具才需要依赖msys相关的dlls。检查安装路径后果然发现，gcc.exe是在<code>C:\MinGW\bin</code>下面，而bash.exe是在<code>C:\MinGW\msys\1.0\bin</code>下面，印证了我的想法。<br><img src="/assets/mingw-cygwin-summary-and-thinking/mingw-bash-dep.png" alt=""></p><p>此外结合<a href="https://zh.wikipedia.org/wiki/MinGW">MinGW的中文维基百科</a>和我自己的MinGW-w64安装经历，选择i686工具链时可以从DWARF和SJLJ这两种异常实现机制中二选一，而选择x86_64时需要从SEH和SJLJ中二选一。</p><h2 id="MSYS2"><a class="header-anchor" href="#MSYS2"></a>MSYS2</h2><p>回过头来再看看MSYS2。MSYS2似乎是配套MinGW-w64出现的，提供三种配置的模式：msys2，mingw64（使用mingw-w64 x86_64 toolchain工具链）和mingw32（使用mingw-w64 i686 toolchain工具链）。个人推测msys2模式编译出来的程序需要依赖msys2.0.dll，就像Cygwin下编译出来的程序一样。据说MSYS2相对于Cygwin的最大区别是移植了包管理工具Pacman。据说三种模式的主要区别是在$PATH中的搜索优先顺序不同，msys2只使用<code>/usr/local/bin</code>和<code>/usr/bin</code>下的工具，mingw64优先使用<code>/mingw64/bin</code>下的工具，mingw32优先使用<code>/mingw32/bin</code>下的工具。</p><p>类似于MinGW和MSYS，安装MSYS2的时候也会自动安装MinGW-w64。而且看起来在x64平台上是mingw64和mingw32会同时被安装。</p><p>我首先单独安装了MinGW-w64，看起来其中的gcc等工具也是直接依赖于Windows的dlls，并没有一个中间层dll。并且在安装的时候需要选择是用x86_64工具链还是i686工具链，以及异常的处理方式。这么看来安装MSYS2的话就可以同时拥有两种工具链了。安装MSYS2时并没有要求选择异常处理机制和所使用的线程库，根据<a href="https://sourceforge.net/p/mingw-w64/discussion/723797/thread/ef7d51a4/">What’s the difference between Mingw-builds and Mingw packages in Msys2</a>这个帖子中的讨论，看起来</p><blockquote><p>MSYS2 only provides posix thread model, dwarf for i686, seh for x86_64</p></blockquote><p>使用Pacman直接安装的gcc依赖于msys2系列的dlls。我估计这就类似于在Cygwin上直接安装gcc，会依赖于cygwin1.dll。如果要安装只依赖于Windows native dlls的gcc，应该安装mingw版本的gcc。<br><img src="/assets/mingw-cygwin-summary-and-thinking/msys2-usr-gcc-dep.png" alt=""></p><p>安装mingw-w64-i686-toolchain和mingw-w64-x86_64-toolchain则分别会在<code>mingw32\bin</code>和<code>mingw64\bin</code>目录下产生gcc.exe，并且只依赖于Windows dlls和libwinpthread-1.dll，看来这个就是MinGW-w64版本的gcc，可以生成不依赖于任何dll的Windows程序。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/mingw-cygwin-summary-and-thinking/">http://xnerv.wang/mingw-cygwin-summary-and-thinking/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要是对MinGW和Cygwin相关的一些名词的研究和推测，以求澄清一些似乎而非的概念，并记录当前已经弄清楚的一些问题，以及还需要进一步调研的一些细节。所有调研都基于Windows平台。&lt;/p&gt;
&lt;h2 id=&quot;关于MinGW和Cygwin的关系&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#关于MinGW和Cygwin的关系&quot;&gt;&lt;/a&gt;关于MinGW和Cygwin的关系&lt;/h2&gt;
&lt;p&gt;网上大部分博文复制粘贴的文章都是讨论MinGW和Cygwin的区别和优劣。而我主要是分析两者的联系，以及一些需要同时用到MinGW和Cygwin的交叉编译场景。&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;https://en.wikipedia.org/wiki/MinGW&quot;&gt;MinGW的维基百科&lt;/a&gt;上看，Cygwin是提供一个模拟的POSIX层（cygwin1.dll）。我推测Cygwin也提供了一系列基于Cygwin的编译工具，在将需要移植的Linux代码在Cygwin上重新编译后，可以获得可以在Windows上直接运行的exe，而这个exe调用的还是POSIX风格的API，只不过这些API由cygwin1.dll提供模拟实现。而MinGW也提供了一系列编译工具，但MinGW-GCC是在编译时将代码中的POSIX API调用直接修改为对应的Windows API调用，从而不需要一个额外的dll转换层。需要额外提到的是，gcc的这种在编译时直接修改调用的API的行为不仅不少见，而且非常常见，在64位Linux上编译C++程序时，例如调用open这个函数，实际上在gcc编译后，调用的是libc中的open64函数，这个可以通过objdump导出外部依赖符号表来确认。另外就是，MinGW并不提供某些难以用Windows API实现的POSIX API，例如fork()，mmap()和ioctl()。&lt;/p&gt;</summary>
    
    
    
    <category term="编译器" scheme="https://xnerv.wang/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="MinGW" scheme="https://xnerv.wang/tags/MinGW/"/>
    
    <category term="编译器" scheme="https://xnerv.wang/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="Cygwin" scheme="https://xnerv.wang/tags/Cygwin/"/>
    
  </entry>
  
  <entry>
    <title>编译Windows版的Seafile客户端</title>
    <link href="https://xnerv.wang/compile-windows-seafile-client/"/>
    <id>https://xnerv.wang/compile-windows-seafile-client/</id>
    <published>2019-12-23T20:20:00.000Z</published>
    <updated>2023-08-21T02:40:00.237Z</updated>
    
    <content type="html"><![CDATA[<p>Seafile是国内少有的做的还不错的开源产品之一。相信很多朋友都经历过几年前的各大云盘厂商大战然后纷纷衰落的这个过程。金山快盘应该是我用过的个人觉得最好的一款云盘了，和Windows GUI的集成也非常完美。可惜现如今各大云盘不是停止运营了就是今非昔比了。因此与其每天提心吊胆地担心自己宝贵的“资源”是不是会被某度网盘封杀，作为码农的我们何不自己动手来搭建一个私有云盘。Seafile的UI是基于Qt，考虑到可移植性和跨平台兼容性，虽然不能像金山快盘那样拥有一些Windows上的特效，例如在托盘上查看当前在上传/下载哪些文件，以及上传/下载的进度。但优势是多平台，在Linux、安卓，iOS上都有相应的客户端。</p><p>Seafile官网只提供了Linux版本客户端的编译方法，并没有提供Windows版本的步骤。搜索了官方论坛，虽然有不少人提问问过，但是官方并没有给出回答。只能说国内的开源的文档还需要进一步完善，遮遮掩掩不算是真正的开源。<a href="http://www.ilovecpp.com/2018/06/25/seafile-compile/">搭建seafile windows客户端的交叉编译环境</a>这篇文章给出了一种基于MinGW在Fedora上交叉编译Windows版本Seafile的方法。我曾尝试过在Ubuntu 18.04上重复这个步骤，但是因为一些packages的原因没能成功。不同的Linux发行版之间的package有一些区别。我也曾尝试过在Windows上的MinGW上交叉编译，但有一些packages死活找不到在Windows MinGW上对应的版本，而且编译时也有一些错误（Windows上的MinGW好像是跑在Cygwin上面的，也就是说Cygwin上的packages可能不全或者跟Fedora上有一些不同）。最终由于时间关系，我放弃了去弄清楚其中的原因，而是采用在Ubuntu上用docker安装Fedora镜像这种类似作弊的方法来重现这篇文章中的步骤。</p><span id="more"></span><p>基于<a href="http://www.ilovecpp.com/2018/06/25/seafile-compile/">搭建seafile windows客户端的交叉编译环境</a>这篇文章，我写了一些脚本来自动化整个编译流程以及打包流程，这些脚本我都放到了GitHub上：<a href="https://github.com/xnervwang/SeafileClientBuildTools">xnervwang/SeafileClientBuildTools</a>。脚本分成两种，一种是在Host环境（例如我的Ubuntu）上执行的，一种是在docker实例中执行的。先介绍一下各个脚本的作用：</p><ul><li><p><code>InitDockerVerification.sh</code>：这个脚本是在Host环境中执行的。会根据<code>Dockerfile</code>创建相应的Fedora docker image，并且在当前的Host目录创建三个文件夹：build, ms-build, ms-build64，分别用于存放编译出来的Linux版本的Seafile客户端，32位Windows客户端，64位Windows客户端。build, ms-build, ms-build64这三个目录会通过docker volume映射到docker实例内，从而便于docker实例和Host共享目录。</p></li><li><p><code>Dockerfile</code>：<code>InitDockerVerification.sh</code>在创建docker image时会使用该文件。这个<code>Dockerfile</code>指定docker镜像在创建时，会git clone我的git repo <a href="https://github.com/xnervwang/SeafileClientBuildTools">xnervwang/SeafileClientBuildTools</a>，然后运行其中的<code>InstallDevPackagesFedora.sh</code>安装编译所需要的一些packages。然后基于该docker镜像创建的docker实例会自动执行<code>DockerEntry.sh</code>。</p></li><li><p><code>RunDockerVerification.sh</code>：创建docker实例并启动。</p></li><li><p><code>DockerEntry.sh</code>：这个脚本被docker实例在启动时执行，会先更新本地的git repo，然后执行<code>OneKey.sh</code>。<code>OneKey.sh</code>会编译Linux版本的Seafile客户端，32位Windows客户端，64位Windows客户端。然后调用<code>ResolveDllDeps.py</code>这个脚本分别对三种客户端进行打包，打包后的产物分别位于build, ms-build, ms-build64这三个目录内。</p></li><li><p><code>ResolveDllDeps.py</code>：这是我写的一个比较有意思的脚本。可以自动递归分析binary所依赖的所有.so动态链接库文件，然后将这些.so文件都复制到打包目录中，从而便于发布。需要注意的是编译出来的Seafile客户端还依赖于qt5/plugins/imageformats和qt5/plugins/platforms这两个插件目录，但是我的这个脚本却无法从Seafile客户端的可执行文件推导出这样的依赖关系。我推测可能这两个插件目录中的插件是通过dlopen的方式动态加载的，因此不能通过静态分析获得依赖关系。所以我将这连个目录中的.so也加入到了第一级的binary列表中。</p></li><li><p><code>Makefile</code>：这个是在docker实例中，在<code>DockerEntry.sh</code>执行编译时所使用的的Makefile。</p></li><li><p><code>Toolchain-cross-linux.i686.cmake/Toolchain-cross-linux.x86_64.cmake</code>：MinGW编译工具所使用的配置文件，分别用于32位/64位Windows客户端。</p></li><li><p><code>DropDockerVerification.sh</code>：删除docker实例和相关的生成目录。</p></li></ul><p>因此，基本的使用方法就是，首先基于<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">docker官方文档</a>安装docker环境，然后git clone我的git repo，然后先执行<code>InitDockerVerification.sh</code>环境，然后以后就可以每次通过执行<code>RunDockerVerification.sh</code>来获取编译后的客户端，分别位于Host机器的build, ms-build, ms-build64这三个目录内。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/compile-windows-seafile-client/">http://xnerv.wang/compile-windows-seafile-client/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Seafile是国内少有的做的还不错的开源产品之一。相信很多朋友都经历过几年前的各大云盘厂商大战然后纷纷衰落的这个过程。金山快盘应该是我用过的个人觉得最好的一款云盘了，和Windows GUI的集成也非常完美。可惜现如今各大云盘不是停止运营了就是今非昔比了。因此与其每天提心吊胆地担心自己宝贵的“资源”是不是会被某度网盘封杀，作为码农的我们何不自己动手来搭建一个私有云盘。Seafile的UI是基于Qt，考虑到可移植性和跨平台兼容性，虽然不能像金山快盘那样拥有一些Windows上的特效，例如在托盘上查看当前在上传/下载哪些文件，以及上传/下载的进度。但优势是多平台，在Linux、安卓，iOS上都有相应的客户端。&lt;/p&gt;
&lt;p&gt;Seafile官网只提供了Linux版本客户端的编译方法，并没有提供Windows版本的步骤。搜索了官方论坛，虽然有不少人提问问过，但是官方并没有给出回答。只能说国内的开源的文档还需要进一步完善，遮遮掩掩不算是真正的开源。&lt;a href=&quot;http://www.ilovecpp.com/2018/06/25/seafile-compile/&quot;&gt;搭建seafile windows客户端的交叉编译环境&lt;/a&gt;这篇文章给出了一种基于MinGW在Fedora上交叉编译Windows版本Seafile的方法。我曾尝试过在Ubuntu 18.04上重复这个步骤，但是因为一些packages的原因没能成功。不同的Linux发行版之间的package有一些区别。我也曾尝试过在Windows上的MinGW上交叉编译，但有一些packages死活找不到在Windows MinGW上对应的版本，而且编译时也有一些错误（Windows上的MinGW好像是跑在Cygwin上面的，也就是说Cygwin上的packages可能不全或者跟Fedora上有一些不同）。最终由于时间关系，我放弃了去弄清楚其中的原因，而是采用在Ubuntu上用docker安装Fedora镜像这种类似作弊的方法来重现这篇文章中的步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式及存储" scheme="https://xnerv.wang/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="Windows" scheme="https://xnerv.wang/tags/Windows/"/>
    
    <category term="分布式及存储" scheme="https://xnerv.wang/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%82%A8/"/>
    
    <category term="Seafile" scheme="https://xnerv.wang/tags/Seafile/"/>
    
    <category term="MinGW" scheme="https://xnerv.wang/tags/MinGW/"/>
    
    <category term="Docker" scheme="https://xnerv.wang/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>TCP模型知识点总结</title>
    <link href="https://xnerv.wang/tcp-model-knowledge-summary/"/>
    <id>https://xnerv.wang/tcp-model-knowledge-summary/</id>
    <published>2019-11-17T01:02:00.000Z</published>
    <updated>2023-08-21T02:40:00.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议格式"><a class="header-anchor" href="#协议格式"></a>协议格式</h2><h3 id="IPv4"><a class="header-anchor" href="#IPv4"></a><a href="http://blog.csdn.net/ce123_zhouwei/article/details/17453033">IPv4</a></h3><p><img src="/assets/tcp-model-knowledge-summary/ipv4.jpg" alt="IPv4头"><br>IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。<br>IP层会丢弃传输中损坏的数据报，但是不产生错误消息，由上层去检测和重传。但是如果发生了分片，IP层应该能保证原子性。<br>在IP层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，即最大传送单元 MTU (Maximum Transfer Unit)。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）最好不能超过下面的数据链路层的MTU值，否则要分片。<br>增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销，实际上这些选项很少被使用。新的IP版本IPv6就将IP数据报的首部长度做成固定的。<br>IP包中只有首部检验和，由TCP和UDP报文各自包含自身的数据校验和。</p><span id="more"></span><h3 id="IPv6"><a class="header-anchor" href="#IPv6"></a>IPv6</h3><p><img src="/assets/tcp-model-knowledge-summary/ipv6.png" alt="IPv6头"></p><h4 id="IPv6的区别"><a class="header-anchor" href="#IPv6的区别"></a>IPv6的区别</h4><ul><li><p>首部长度<br>首部长度可变，IPv4首部的选项字段允许IP首部被扩展，由此导致数据报首部长度可变，故不能预先确定数据字段从何开始，同时也使路由器处理一个IP数据报所需时间差异很大(有的要处理选项，有的不需要)。基于此，IPv6采用固定40字节长度的报头长度(称基本报头)。IPv6如何实现IPv4选项字段类似的功能，答案是扩展报头，并由IPv6基本报头的下一个首部指向扩展报头(如果有的话)。路由器不处理扩展报头，提升了路由器处理效率。</p></li><li><p>分片/重组<br>IPv6，分片与重组只能在源与目的地上执行，不允许在中间路由器进行。分片与重组是个耗时的操作，将该功能从路由器转移到端系统，大大加快了网络中的IP转发速率。那，如果路由器收到IPv6数据报太大而不能转发到出链路上怎么办？该路由器丢弃该包，并向发送发发回一个&quot;分组太大&quot;的ICMP差错报文，于是发送发使用较小长度的IP数据报重发数据。</p></li><li><p>首部检查和<br>IPv4中由于TTL的递减，所以每经过一个路由器都需要重新计算校验和，导致路由器处理速度的低下。加之，传输层和链路层协议执行了检验操作，网络传输可靠性提升，所以IPv6不进行首部检查和，从而更快速处理IP分组。（但在网络传输的过程中，链路层packet是可能损坏的，考虑到厂商设备的多样性和高负载。所以TCP校验应该是关键，如果发现checksum不对，TCP可以要求对方重传丢失的内容。）</p></li></ul><h3 id="TCP头"><a class="header-anchor" href="#TCP头"></a>TCP头</h3><p><img src="/assets/tcp-model-knowledge-summary/tcp.jpg" alt="TCP头"><br>校验和是针对header和data计算出来的。TCP和UDP计算校验和时，都要加上一个12字节的伪首部。伪首部共有12字节，包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等。<br>TCP和UDP的报文都没有一个字段可以表明自身长度，这个长度是由IP包中的总长度来记录的。</p><p><a href="http://blog.csdn.net/wilsonpeng3/article/details/12869233">TCP报文段首部格式详解</a></p><blockquote><ul><li>TCP首部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。或者可以这么理解：就是表示TCP报文段中数据部分在整个TCP报文段中的位置。该字段的单位是32位字，即：4个字节。</li><li>选项部分：其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节（但要全零填充为4字节的整数倍）。</li><li>选项部分的应用：<ol><li>MSS最大报文段长度(Maxium Segment Size)：指明数据字段的最大长度，数据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS值指示自己期望对方发送TCP报文段时那个数据字段的长度。通信双方可以有不同的MSS值。如果未填写，默认采用536字节。MSS只出现在SYN报文中。即：MSS出现在SYN=1的报文段中。</li><li>窗口扩大选项(Windows Scaling)：由于TCP首部的窗口大小字段长度是16位，所以其表示的最大数是65535。但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口来满足性能和吞吐率，所以产生了这个窗口扩大选项。</li><li>SACK选择确认项(Selective Acknowledgements)：用来确保只重传缺少的报文段，而不是重传所有报文段。比如主机A发送报文段1、2、3，而主机B仅收到报文段1、3。那么此时就需要使用SACK选项来告诉发送方只发送丢失的数据。那么又如何指明丢失了哪些报文段呢？使用SACK需要两个功能字节。一个表示要使用SACK选项，另一个指明这个选项占用多少字节。描述丢失的报文段2，是通过描述它的左右边界报文段1、3来完成的。而这个1、3实际上是表示序列号，所以描述一个丢失的报文段需要64位即8个字节的空间。那么可以推算整个选项字段最多描述(40-2)/8=4个丢失的报文段。</li><li>时间戳选项（Timestamps）：可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文。</li><li>NOP(NO-Operation)：它要求选项部分中的每种选项长度必须是4字节的倍数，不足的则用NOP填充。同时也可以用来分割不同的选项字段。如窗口扩大选项和SACK之间用NOP隔开。</li></ol></li></ul></blockquote><h3 id="UDP"><a class="header-anchor" href="#UDP"></a>UDP</h3><p><a href="http://blog.csdn.net/wypblog/article/details/7494458">linux网络编程之：UDP数据包格式</a><br><img src="/assets/tcp-model-knowledge-summary/udp.jpg" alt="UCP头"></p><blockquote><p>UDP数据报格式有首部和数据两个部分。首部很简单，共8字节。包括：</p><ul><li>源端口（Source Port）：2字节，源端口号。</li><li>目的端口（Destination Port ）：2字节，目的端口号。</li><li>长度（Length）：2字节，UDP用户数据报的总长度，以字节为单位。</li><li>检验和（Checksum）：2字节，用于校验UDP数据报的数字段和包含UDP数据报首部的“伪首部”。其校验方法同IP分组首部中的首部校验和。</li></ul><p>伪首部，又称为伪包头（Pseudo Header）：是指在TCP的分段或UDP的数据报格式中，在数据报首部前面增加源IP地址、目的IP地址、IP分组的协议字段、TCP或UDP数据报的总长度等共12字节，所构成的扩展首部结构。此伪首部是一个临时的结构，它既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。</p></blockquote><p>UDP的校验和是可选的，如果校验码为 0 ,意味着发送者末产生校验码。这表示对于数据段不使用校验,因为 IP 只是对 IP 首部进行校验。</p><h4 id="RST"><a class="header-anchor" href="#RST"></a>RST</h4><p>产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在监听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息。而TCP则使用复位/重置连接。<br>RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接，并通知应用层连接复位。</p><h4 id="带外数据SO-OOBINLINE"><a class="header-anchor" href="#带外数据SO-OOBINLINE"></a><a href="http://blog.csdn.net/ordeder/article/details/43243425">带外数据SO_OOBINLINE</a></h4><p>其实就是一个指针指向正常数据中的一个字节的后一个字节位置。<br><a href="http://blog.chinaunix.net/uid-1728743-id-4945690.html">别用TCP的紧急数据</a>提到带外数据已经不建议使用。同时提到带外数据可以用于控制意图，这样就不用像FTP一样得单独开一个控制连接了。<br>TCP的紧急指针，一般都不建议使用，而且不同的TCP/IP实现，也不同，一般说如果你有紧急数据宁愿再建立一个新的TCP/IP连接发送数据，让对方紧急处理。但是，虽然sendUrgentData的参数data是int类型，但只有这个int类型的低字节被发送，其它的三个字节被忽略。<br>接收端如何处理这个数据存在一些模糊。有的平台和API把它和平常数据分开处理，然后大多数解决方案是把它放到普通数据队列，让应用自己去从队列中获取处理。</p><h2 id="一些TCP参数"><a class="header-anchor" href="#一些TCP参数"></a>一些TCP参数</h2><h3 id="tcp-max-syn-backlog"><a class="header-anchor" href="#tcp-max-syn-backlog"></a>tcp_max_syn_backlog</h3><p><a href="https://yq.aliyun.com/articles/4252?&amp;utm_campaign=sys&amp;utm_medium=market&amp;utm_source=edm_email&amp;msctype=email&amp;mscmsgid=111616021800142609">Linux TCP队列相关参数的总结</a></p><blockquote><p>建立连接涉及两个队列：<br>半连接队列，保存SYN_RECV状态的连接。队列长度由net.ipv4.tcp_max_syn_backlog设置。<br>accept队列，保存ESTABLISHED状态的连接。队列长度为min(net.core.somaxconn, backlog)。其中backlog是我们创建ServerSocket(intport, int backlog)时指定的参数，最终会传递给listen方法。</p></blockquote><p><a href="http://www.cnxct.com/something-about-phpfpm-s-backlog/">TCP SOCKET中backlog参数的用途是什么？</a><br>在linux 2.2以前，backlog大小包括了半连接状态和全连接状态两种队列大小。linux 2.2以后，分离为两个backlog来分别限制半连接SYN_RCVD状态的未完成连接队列大小跟全连接ESTABLISHED状态的已完成连接队列大小。互联网上常见的TCP SYN FLOOD恶意DOS攻击方式就是用/proc/sys/net/ipv4/tcp_max_syn_backlog来控制的。<br>在使用listen函数时，内核会根据传入参数的backlog跟系统配置参数/proc/sys/net/core/somaxconn中，二者取最小值，作为“ESTABLISHED状态之后，完成TCP连接，等待服务程序ACCEPT”的队列大小。在kernel 2.4.25之前，是写死在代码常量SOMAXCONN，默认值是128。在kernel 2.4.25之后，在配置文件/proc/sys/net/core/somaxconn (即 /etc/sysctl.conf 之类 )中可以修改。<br><img src="http://img2.cnxct.com/2015/06/tcp-sync-queue-and-accept-queue-small-1024x747.jpg" alt="tcp-sync-queue-and-accept-queue"></p><p><a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html">How TCP backlog works in Linux</a><br>backlog为0 时在linux上表明允许不受限制的连接数，这是一个缺陷，因为它可能会导致SYN Flooding(拒绝服务型攻击。</p><h3 id="tcp-tw-recycle-：BOOLEAN"><a class="header-anchor" href="#tcp-tw-recycle-：BOOLEAN"></a>tcp_tw_recycle ：BOOLEAN</h3><p>默认值是0。<br>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)。</p><h3 id="tcp-tw-reuse：BOOLEAN"><a class="header-anchor" href="#tcp-tw-reuse：BOOLEAN"></a>tcp_tw_reuse：BOOLEAN</h3><p>默认值是0。<br>该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)。</p><h3 id="tcp-max-orphans-：INTEGER"><a class="header-anchor" href="#tcp-max-orphans-：INTEGER"></a>tcp_max_orphans ：INTEGER</h3><p>缺省值是8192。<br>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768，但是很多防火墙修改的时候,，议该值修改为2000)。</p><h3 id="tcp-abort-on-overflow-：BOOLEAN"><a class="header-anchor" href="#tcp-abort-on-overflow-：BOOLEAN"></a>tcp_abort_on_overflow ：BOOLEAN</h3><p>缺省值是0。<br>当守护进程太忙而不能接受新的连接，就向对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail，apache这类服务的时候，这个可以很快让客户端终止连接，可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)。</p><h3 id="TCP-NODELAY"><a class="header-anchor" href="#TCP-NODELAY"></a>TCP_NODELAY</h3><p><a href="https://www.cnblogs.com/god-of-death/p/7154481.html">神秘的40毫秒延迟与TCP_NODELAY</a></p><blockquote><p>Nagle’s Algorithm 是为了提高带宽利用率设计的算法，其做法是合并小的TCP 包为一个，避免了过多的小报文的 TCP 头所浪费的带宽。如果开启了这个算法 （默认），则协议栈会累积数据直到以下两个条件之一满足的时候才真正发送出 去：</p><ul><li>积累的数据量到达最大的 TCP Segment Size。</li><li>收到了一个 Ack。<br>TCP Delayed Acknoledgement 也是为了类似的目的被设计出来的，它的作用就是延迟 Ack 包的发送，使得协议栈有机会合并多个 Ack，提高网络性能。<br>如果一个 TCP 连接的一端启用了 Nagle‘s Algorithm，而另一端启用了 TCP Delayed Ack，而发送的数据包又比较小，则可能会出现这样的情况：发送端在等待接收端对上一个packet 的 Ack 才发送当前的 packet，而接收端则正好延迟了 此 Ack 的发送，那么这个正要被发送的 packet 就会同样被延迟。当然 Delayed Ack 是有个超时机制的，而默认的超时正好就是 40ms。<br>现代的 TCP/IP 协议栈实现，默认几乎都启用了这两个功能，你可能会想，按我上面的说法，当协议报文很小的时候，岂不每次都会触发这个延迟问题？事实不是那样的。仅当协议的交互是发送端连续发送两个 packet，然后立刻 read 的时候才会出现问题。</li></ul></blockquote><p>Nagle算法主要是避免发送小的数据包，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的小分组，并在确认到来时以一个分组的方式发出去。</p><h3 id="SO-LINGER"><a class="header-anchor" href="#SO-LINGER"></a>SO_LINGER</h3><p>设置函数close()关闭TCP连接时的行为。缺省close()的行为是，如果有数据残留在socket发送缓冲区中则系统将继续发送这些数据给对方，等待被确认，然后返回。SO_LINGER选项用来改变此缺省设置。使用如下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger &#123;</span><br><span class="line">     int l_onoff; /* 0 = off, nozero = on */</span><br><span class="line">     int l_linger; /* linger time */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>l_onoff</th><th>l_linger</th><th>closesocket行为</th><th>发送队列</th><th>底层行为</th></tr></thead><tbody><tr><td>零</td><td>忽略</td><td>立即返回。</td><td>保持直至发送完成。</td><td>系统接管套接字并保证将数据发送至对端。</td></tr><tr><td>非零</td><td>零</td><td>立即返回。</td><td>立即放弃。</td><td>直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。</td></tr><tr><td>非零</td><td>非零</td><td>阻塞直到l_linger时间超时或数据发送完成。(套接字必须设置为阻塞)</td><td>在超时时间段内保持尝试发送，若超时则立即放弃。</td><td>超时则同第二种情况，若发送完成则皆大欢喜。</td></tr></tbody></table><p>第二种设置主要是为了避免主动断开连接方进入TIME_WAIT状态。丢失缓冲区中未丢失数据只是一种副作用。</p><h3 id="SO-REUSEADDR-SO-REUSEPORT"><a class="header-anchor" href="#SO-REUSEADDR-SO-REUSEPORT"></a>SO_REUSEADDR / SO_REUSEPORT</h3><p><a href="http://blog.csdn.net/yaokai_assultmaster/article/details/68951150">浅析套接字中SO_REUSEPORT和SO_REUSEADDR的区别</a></p><h3 id="SO-KEEPALIVE"><a class="header-anchor" href="#SO-KEEPALIVE"></a><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">SO_KEEPALIVE</a></h3><p>貌似是由发起连接方（客户端）主动发给服务端的，就是一个data size为0的packet，服务器收到这个packet也会回复一个同样data size为0的packet表明连接仍存活。</p><p><strong>SO_KEEPALIVE和心跳线程</strong><br>SO_KEEPALIVE是系统底层的机制，用于系统维护每一个tcp连接的。<br>心跳线程属于应用层，主要用于终端和服务器连接的检查。<br>即使SO_KEEPALIVE检测到连接正常，但并不能保证终端和服务器连接的正常。有一种情况，服务器进程死了，但它和客户端的tcp连接还连着（该连接由系统维护的）。<br>这就是SO_KEEPALIVE不能取代心跳线程的原因吧。</p><h2 id="TCP协议"><a class="header-anchor" href="#TCP协议"></a>TCP协议</h2><p><img src="http://coolshell.cn//wp-content/uploads/2009/09/tcp1.jpg" alt="TCP状态转换图"></p><h3 id="四次挥手"><a class="header-anchor" href="#四次挥手"></a>四次挥手</h3><p><img src="http://dl.iteye.com/upload/attachment/0077/3159/734c7efd-3d62-3946-a234-acdddff3b507.jpg" alt="四次挥手状态转换图"><br>其实也可以看成两次过程，任何一方发送FIN表明自己不会再发送数据。</p><h4 id="TIME-WAIT（涉及主动断开连接一方）"><a class="header-anchor" href="#TIME-WAIT（涉及主动断开连接一方）"></a>TIME_WAIT（涉及主动断开连接一方）</h4><p>TCP协议在关闭连接的四次握手过程中，<strong>最终的ACK</strong> 是由 <strong>主动关闭连接</strong> 的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。<br>因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态。<br>主动关闭的一方要负责处于TIME_WAIT状态中。MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。Windows使用的是2分钟，而Linux则是30秒。</p><h4 id="CLOSE-WAIT（涉及被动断开连接一方）"><a class="header-anchor" href="#CLOSE-WAIT（涉及被动断开连接一方）"></a>CLOSE_WAIT（涉及被动断开连接一方）</h4><p>在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。<br>出现大量CLOSE_WAIT的现象，主要原因是某种情况下对方关闭socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。</p><p><a href="http://blog.csdn.net/shootyou/article/details/6622226">服务器TIME_WAIT和CLOSE_WAIT详解和解决办法</a></p><h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3><p><img src="http://img.blog.csdn.net/20130801220438375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2ljb2ZpZWxk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="拥塞避免算法"></p><p>当cwnd&lt;ssthresh时，使用慢开始算法。<br>当cwnd&gt;ssthresh时，改用拥塞避免算法。<br>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p><h3 id="快重传和快恢复"><a class="header-anchor" href="#快重传和快恢复"></a>快重传和快恢复</h3><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p>快重传配合使用的还有快恢复算法，有以下两个要点:</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图：</li></ol><p><img src="http://img.blog.csdn.net/20130801220556750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2ljb2ZpZWxk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="快重传的示意图"></p><h3 id="随机早期检测RED"><a class="header-anchor" href="#随机早期检测RED"></a><a href="http://blog.csdn.net/sicofield/article/details/9708383">随机早期检测RED</a></h3><p>若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态。这在术语中称为全局同步。全局同步会使得网络的通信量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。<br>为避免发生网路中的全局同步现象，路由器采用随机早期检测(RED:randomearly detection)。</p><h3 id="msl、ttl及rtt的区别"><a class="header-anchor" href="#msl、ttl及rtt的区别"></a>msl、ttl及rtt的区别</h3><ol><li>MSL 是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。例如RIP协议用经过的最大路由节点数作为MSL。</li><li>IP头中有一个TTL域，TTL是 time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经 过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br>TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</li><li>RTT是客户到服务器往返所花时间（round-trip time，简称RTT），TCP含有动态估算RTT的算法。TCP还持续估算一个给定连接的RTT，这是因为RTT受网络传输拥塞程序的变化而变化。</li></ol><hr><p><strong>本文地址：<a href="http://xnerv.wang/tcp-model-knowledge-summary/">http://xnerv.wang/tcp-model-knowledge-summary/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;协议格式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#协议格式&quot;&gt;&lt;/a&gt;协议格式&lt;/h2&gt;
&lt;h3 id=&quot;IPv4&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#IPv4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/ce123_zhouwei/article/details/17453033&quot;&gt;IPv4&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/tcp-model-knowledge-summary/ipv4.jpg&quot; alt=&quot;IPv4头&quot;&gt;&lt;br&gt;
IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。&lt;br&gt;
IP层会丢弃传输中损坏的数据报，但是不产生错误消息，由上层去检测和重传。但是如果发生了分片，IP层应该能保证原子性。&lt;br&gt;
在IP层下面的每一种数据链路层都有自己的帧格式，其中包括帧格式中的数据字段的最大长度，即最大传送单元 MTU (Maximum Transfer Unit)。当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）最好不能超过下面的数据链路层的MTU值，否则要分片。&lt;br&gt;
增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销，实际上这些选项很少被使用。新的IP版本IPv6就将IP数据报的首部长度做成固定的。&lt;br&gt;
IP包中只有首部检验和，由TCP和UDP报文各自包含自身的数据校验和。&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://xnerv.wang/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="网络协议" scheme="https://xnerv.wang/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="TCP" scheme="https://xnerv.wang/tags/TCP/"/>
    
    <category term="IP" scheme="https://xnerv.wang/tags/IP/"/>
    
    <category term="UDP" scheme="https://xnerv.wang/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>线程同步与原子操作</title>
    <link href="https://xnerv.wang/thread-synchronization-and-atomic-operation/"/>
    <id>https://xnerv.wang/thread-synchronization-and-atomic-operation/</id>
    <published>2019-09-25T15:25:00.000Z</published>
    <updated>2023-08-21T02:40:00.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile"><a class="header-anchor" href="#volatile"></a>volatile</h2><ul><li>volatile使得代码每次在读写volatile变量时都需要从内存读写，而不能使用寄存器中缓存的值。并且也禁止编译器对volatible做编译优化。volatile本身并不是用于线程同步，也不保证原子读写（例如volatile a++这种需要几个指令才能完成的操作）。volatile主要用于access to memory mapped devices和variables in signal handlers and between setjmp and longjmp。C++标准禁止编译器reorder同一个线程内的volatile变量的读写，但不同线程则没有限制。non-volatile变量则有可能发生reorder（<a href="https://sites.google.com/site/kjellhedstrom2/stay-away-from-volatile-in-threaded-code">Stay away from Volatile in threaded code?</a>）。</li><li>而根据<a href="https://blog.csdn.net/dm_vincent/article/details/79604716">为什么volatile++不是原子性的？</a>中的说法，volatile的读操作后会插入LoadLoad和LoadStore屏障，避免volatile读操作与后面的普通读写发生reorder。而volatile的写操作前会插入StoreLoad和StoreStore屏障，避免volatile写操作与后面的普通读写发生reorder（我不太确定这种说法的正确性，毕竟在wikipedia<a href="https://en.wikipedia.org/wiki/Volatile_(computer_programming)">volatile (computer programming)</a>中并没有提到volatile会插入内存屏障，或者只有Java等语言才会这样做？）。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C">内存屏障</a>中有提到<blockquote><p>C与C++语言中，volatile关键字意图允许内存映射的I/O操作。这要求编译器对此的数据读写按照程序中的先后顺序执行，不能对volatile内存的读写重排序。因此关键字volatile并不保证是一个内存屏障。[4]<br>对于Visual Studio 2003，编译器保证对volatile的操作是有序的，但是不能保证处理器的乱序执行。因此，可以使用InterlockedCompareExchange或InterlockedExchange函数。<br>对于Visual Studio 2005及以后版本，编译器对volatile变量的读操作使用acquire semantics，对写操作使用release semantics。</p></blockquote></li></ul><span id="more"></span><ul><li>volatile跟const一样属于变量修饰符，因此也和const一样必须弄清楚修饰的是指针还是变量自身（或者甚至是第几级指针）。例如<code>uchar * volatile reg;</code>说明指针reg本身是volatile的，而<code>volatile uchar *reg;</code>说明*reg（也就是reg指向的变量）是volatile的。而且volatile也可以和const同时使用。</li><li><a href="https://blog.csdn.net/hanchaoman/article/details/41116251">volatile陷阱</a>一文中有提到几种volatile的陷阱和误用。</li><li><a href="https://mcuoneclipse.com/2013/08/14/volatile-can-be-harmful/">“Volatile” can be harmful…</a>中提到可以将函数参数标记为volatile避免编译器优化，从而便于debug。</li></ul><h2 id="临界区块（Critical-section）"><a class="header-anchor" href="#临界区块（Critical-section）"></a>临界区块（Critical section）</h2><ul><li>Windows的<a href="https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">CRITICAL_SECTION</a>首先会在用户态自旋尝试几次获取锁，如果最终还是失败的话就会内核模式等待。</li></ul><h2 id="内存屏障（Memory-barrier）"><a class="header-anchor" href="#内存屏障（Memory-barrier）"></a>内存屏障（Memory barrier）</h2><ul><li>首先要明白的一点，reorder不仅可以发生在编译时，也可以发生在运行时。CPU流水线也可以重排某些指令顺序。所以即使是同一段编译好的程序，不同的CPU内核也可能执行不同的指令顺序。（<a href="http://jpbempel.blogspot.com/2013/05/volatile-and-memory-barriers.html">Volatile and memory barriers</a>）</li><li>根据<a href="https://en.wikipedia.org/wiki/Memory_barrier">Memory barrier</a>，如果只有单个CPU，即使发生reorder也不会有什么问题，问题都是发生在多个线程之间。而且内存屏障只在运行时生效？？？而编译时需要用volatile？并且这篇wiki也提到volatile并不能阻止volatile变量和non-volatile变量的reorder。本质上，C/C++标准中volatile是通过控制编译器而实现的（虽然编译器实现有可能引入内存屏障来实现volatile），而内存屏障是通过特殊CPU指令实现的）。</li><li><a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">How do I Understand Read Memory Barriers and Volatile</a>中将对内存的操作比喻成有一个queue（因为CPU比内存快），所以Acquire操作就是flush all read requests in the queue（实际上并不是flush，而只是加一个标记，所以叫做内存屏障），而Release操作就是flush all write requests in the queue。因此在Acquire(lfence)之前的read requests一定会完成在Acquire之前，而Release(sfence)之前的write requests一定会完成在Release之后。类似于“半透膜”的效果。（那也就是说Acquire是LoadLoad屏障，而Release是WriteWrite屏障？）而full barrier (or full fence, mfence)就是禁止在此之前的所有read/write操作被reorder到本操作之后。</li><li>而C++11中的Acquire和Release定义则与上面的回答不同。C++11中的Acquire是LoadLoad+StoreLoad，Release是LoadStore+StoreStore。结合<a href="https://twistoy.com/post/cpp11-memory-model">C++11内存模型</a>，<a href="https://www.jianshu.com/p/a26763dd9b0e">内存屏障与内存模型</a>，<a href="http://lday.me/2017/12/02/0018_cpp_atomic_summary/">C++内存屏障（内存顺序）总结</a>，<a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering">std::memory_order</a>等文章，6中内存屏障级别的区别是：<blockquote><p>（建议仔细再阅读最后一篇文章。不太明白的是，当论及other thread acquire/release the same atomic时，是指代码上有acquire/release操作的线程，还是指在某一个时刻瞬间进行了acquire/release的线程？就目前看来前者的可能性更大一些）</p></blockquote></li></ul><h2 id="条件变量（Condition-Variable）"><a class="header-anchor" href="#条件变量（Condition-Variable）"></a>条件变量（Condition Variable）</h2><ul><li>C++11的条件变量跟win32的Event有一个区别，就是必须在wait之后signal，否则就必须结合预测条件（从而检查是否在wait之前已经signal）。<a href="https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables">C++ Core Guidelines: Be Aware of the Traps of Condition Variables</a></li></ul><h2 id="Atomic"><a class="header-anchor" href="#Atomic"></a>Atomic</h2><ul><li><a href="https://stackoverflow.com/questions/19900524/does-the-c-11-standard-guarantees-that-stdatomic-is-implemented-as-a-lock">Does the C++ 11 standard guarantees that std::atomic&lt;&gt; is implemented as a lock-free operation?</a>，C++11不保证std::atomic<T>是lock-free的，而是由数据类型长度等因素决定的，可以用std::atomic<T>::is_lock_free()来判断该类型是否lock-free。</li><li><a href="https://stackoverflow.com/questions/25740388/what-is-the-difference-between-explicit-atomic-load-store-and-usual-operator-an">What is the difference between explicit atomic load/store and usual operator= and operator T?</a>，两者是相等的，后者使用默认的memory_order_seq_cst级别内存屏障。</li></ul><hr><p><strong>本文地址：<a href="http://xnerv.wang/thread-synchronization-and-atomic-operation/">http://xnerv.wang/thread-synchronization-and-atomic-operation/</a></strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;volatile&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;volatile使得代码每次在读写volatile变量时都需要从内存读写，而不能使用寄存器中缓存的值。并且也禁止编译器对volatible做编译优化。volatile本身并不是用于线程同步，也不保证原子读写（例如volatile a++这种需要几个指令才能完成的操作）。volatile主要用于access to memory mapped devices和variables in signal handlers and between setjmp and longjmp。C++标准禁止编译器reorder同一个线程内的volatile变量的读写，但不同线程则没有限制。non-volatile变量则有可能发生reorder（&lt;a href=&quot;https://sites.google.com/site/kjellhedstrom2/stay-away-from-volatile-in-threaded-code&quot;&gt;Stay away from Volatile in threaded code?&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;而根据&lt;a href=&quot;https://blog.csdn.net/dm_vincent/article/details/79604716&quot;&gt;为什么volatile++不是原子性的？&lt;/a&gt;中的说法，volatile的读操作后会插入LoadLoad和LoadStore屏障，避免volatile读操作与后面的普通读写发生reorder。而volatile的写操作前会插入StoreLoad和StoreStore屏障，避免volatile写操作与后面的普通读写发生reorder（我不太确定这种说法的正确性，毕竟在wikipedia&lt;a href=&quot;https://en.wikipedia.org/wiki/Volatile_(computer_programming)&quot;&gt;volatile (computer programming)&lt;/a&gt;中并没有提到volatile会插入内存屏障，或者只有Java等语言才会这样做？）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C&quot;&gt;内存屏障&lt;/a&gt;中有提到
&lt;blockquote&gt;
&lt;p&gt;C与C++语言中，volatile关键字意图允许内存映射的I/O操作。这要求编译器对此的数据读写按照程序中的先后顺序执行，不能对volatile内存的读写重排序。因此关键字volatile并不保证是一个内存屏障。[4]&lt;br&gt;
对于Visual Studio 2003，编译器保证对volatile的操作是有序的，但是不能保证处理器的乱序执行。因此，可以使用InterlockedCompareExchange或InterlockedExchange函数。&lt;br&gt;
对于Visual Studio 2005及以后版本，编译器对volatile变量的读操作使用acquire semantics，对写操作使用release semantics。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://xnerv.wang/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="原创" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%88%9B/"/>
    
    <category term="操作系统" scheme="https://xnerv.wang/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="线程同步" scheme="https://xnerv.wang/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    
    <category term="原子操作" scheme="https://xnerv.wang/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
    <category term="volatile" scheme="https://xnerv.wang/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 常用SQL语句的MDL加锁源码分析（转载）</title>
    <link href="https://xnerv.wang/analysis-of-mdl-source-code-for-common-sql-statements/"/>
    <id>https://xnerv.wang/analysis-of-mdl-source-code-for-common-sql-statements/</id>
    <published>2018-03-22T02:40:00.000Z</published>
    <updated>2023-08-21T02:40:00.083Z</updated>
    
    <content type="html"><![CDATA[<section class="post"><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>MySQL5.5版本开始引入了MDL锁用来保护元数据信息，让MySQL能够在并发环境下多DDL、DML同时操作下保持元数据的一致性。本文用MySQL5.7源码分析了常用SQL语句的MDL加锁实现。</p><h4 id="MDL锁粒度"><a class="header-anchor" href="#MDL锁粒度"></a>MDL锁粒度</h4><p>MDL_key由namespace、db_name、name组成。</p><p>namespace包含：</p><ul><li><p>GLOBAL。用于global read lock，例如FLUSH TABLES WITH READ LOCK。</p></li><li><p>TABLESPACE/SCHEMA。用于保护tablespace/schema。</p></li><li><p>FUNCTION/PROCEDURE/TRIGGER/EVENT。用于保护function/procedure/trigger/event。</p></li><li><p>COMMIT。主要用于global read lock后，阻塞事务提交。（在DML的commit阶段也会获取COMMIT锁）</p></li><li><p>USER_LEVEL_LOCK。用于<a href="https://dev.mysql.com/doc/internals/en/user-level-locks.html">user level lock函数</a>的实现，GET_LOCK(str,timeout)， RELEASE_LOCK(str)。</p></li><li><p>LOCKING_SERVICE。用于<a href="https://dev.mysql.com/doc/refman/5.7/en/locking-service.html">locking service</a>的实现。</p></li></ul><span id="more"></span><h3 id="MDL锁类型"><a class="header-anchor" href="#MDL锁类型"></a>MDL锁类型</h3><ul><li><p>MDL_INTENTION_EXCLUSIVE(IX) 意向排他锁，锁定一个范围，用在GLOBAL/SCHEMA/COMMIT粒度。</p></li><li><p>MDL_SHARED(S) 用在只访问元数据信息，不访问数据。例如CREATE TABLE t LIKE t1;</p></li><li><p>MDL_SHARED_HIGH_PRIO(SH) 也是用于只访问元数据信息，但是优先级比排他锁高，用于访问information_schema的表。例如：select * from information_schema.tables;</p></li><li><p>MDL_SHARED_READ(SR) 访问表结构并且读表数据，例如：SELECT * FROM t1; LOCK TABLE t1 READ LOCAL;</p></li><li><p>MDL_SHARED_WRITE(SW) 访问表结构且写表数据， 例如：INSERT/DELETE/UPDATE t1 … ;SELECT * FROM t1 FOR UPDATE;LOCK TALE t1 WRITE</p></li><li><p>MDL_SHARED_WRITE_LOW_PRIO(SWLP) 优先级低于MDL_SHARED_READ_ONLY。语句INSER/DELETE/UPDATE LOW_PRIORITY t1 …; LOCK TABLE t1 WRITE LOW_PRIORITY。</p></li><li><p>MDL_SHARED_UPGRADABLE(SU) 可升级锁，允许并发update/read表数据。持有该锁可以同时读取表metadata和表数据，但不能修改数据。可以升级到SNW、X锁。用在alter table的第一阶段，使alter table的时候不阻塞DML，防止其他DDL。（是mysql 5.6引入的新的metadata lock，在alter table/create index/drop index会加该锁，可以说是为了online ddl才引入的。特点是允许DML，防止DDL。）</p></li><li><p>MDL_SHARED_READ_ONLY(SRO) 持有该锁可读取表数据，同时阻塞所有表结构和表数据的修改操作，用于LOCK TABLE t1 READ。</p></li><li><p>MDL_SHARED_NO_WRITE(SNW) 持有该锁可以读取表metadata和表数据，同时阻塞所有的表数据修改操作，允许读。可以升级到X锁。用在ALTER TABLE第一阶段，拷贝原始表数据到新表，允许读但不允许更新。</p></li><li><p>MDL_SHARED_NO_READ_WRITE(SNRW) 可升级锁，允许其他连接读取表结构但不可以读取数据，阻塞所有表数据的读写操作，允许INFORMATION_SCHEMA访问和SHOW语句。持有该锁的的连接可以读取表结构，修改和读取表数据。可升级为X锁。使用在LOCK TABLE WRITE语句。</p></li><li><p>MDL_EXCLUSIVE(X) 排他锁，持有该锁连接可以修改表结构和表数据，使用在CREATE/DROP/RENAME/ALTER TABLE 语句。</p></li></ul><h3 id="MDL锁持有时间"><a class="header-anchor" href="#MDL锁持有时间"></a>MDL锁持有时间</h3><ul><li><p>MDL_STATEMENT 语句中持有，语句结束自动释放</p></li><li><p>MDL_TRANSACTION 事务中持有，事务结束时释放</p></li><li><p>MDL_EXPLICIT 需要显示释放</p></li></ul><h3 id="MDL锁兼容性"><a class="header-anchor" href="#MDL锁兼容性"></a>MDL锁兼容性</h3><p>Scope锁活跃锁和请求锁兼容性矩阵如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">         | Type of active   |</span><br><span class="line">Request  |   scoped lock    |</span><br><span class="line">type     | IS(*)  IX   S  X |</span><br><span class="line">---------+------------------+</span><br><span class="line">IS       |  +      +   +  + |</span><br><span class="line">IX       |  +      +   -  - |</span><br><span class="line">S        |  +      -   +  - |</span><br><span class="line">X        |  +      -   -  - |</span><br><span class="line"></span><br><span class="line">+号表示请求的锁可以满足。</span><br><span class="line">-号表示请求的锁无法满足需要等待。</span><br></pre></td></tr></table></figure><p>Scope锁等待锁和请求锁优先级矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         |    Pending      |</span><br><span class="line">Request  |  scoped lock    |</span><br><span class="line">type     | IS(*)  IX  S  X |</span><br><span class="line">---------+-----------------+</span><br><span class="line">IS       |  +      +  +  + |</span><br><span class="line">IX       |  +      +  -  - |</span><br><span class="line">S        |  +      +  +  - |</span><br><span class="line">X        |  +      +  +  + |</span><br><span class="line">+号表示请求的锁可以满足。</span><br><span class="line">-号表示请求的锁无法满足需要等待。</span><br></pre></td></tr></table></figure><p>object上已持有锁和请求锁的兼容性矩阵如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Request   |  Granted requests for lock                  |</span><br><span class="line"> type     | S  SH  SR  SW  SWLP  SU  SRO  SNW  SNRW  X  |</span><br><span class="line">----------+---------------------------------------------+</span><br><span class="line">S         | +   +   +   +    +    +   +    +    +    -  |</span><br><span class="line">SH        | +   +   +   +    +    +   +    +    +    -  |</span><br><span class="line">SR        | +   +   +   +    +    +   +    +    -    -  |</span><br><span class="line">SW        | +   +   +   +    +    +   -    -    -    -  |</span><br><span class="line">SWLP      | +   +   +   +    +    +   -    -    -    -  |</span><br><span class="line">SU        | +   +   +   +    +    -   +    -    -    -  |</span><br><span class="line">SRO       | +   +   +   -    -    +   +    +    -    -  |</span><br><span class="line">SNW       | +   +   +   -    -    -   +    -    -    -  |</span><br><span class="line">SNRW      | +   +   -   -    -    -   -    -    -    -  |</span><br><span class="line">X         | -   -   -   -    -    -   -    -    -    -  |</span><br></pre></td></tr></table></figure><p>object上等待锁和请求锁的优先级矩阵如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Request   |         Pending requests for lock          |</span><br><span class="line"> type     | S  SH  SR  SW  SWLP  SU  SRO  SNW  SNRW  X |</span><br><span class="line">----------+--------------------------------------------+</span><br><span class="line">S         | +   +   +   +    +    +   +    +     +   - |</span><br><span class="line">SH        | +   +   +   +    +    +   +    +     +   + |</span><br><span class="line">SR        | +   +   +   +    +    +   +    +     -   - |</span><br><span class="line">SW        | +   +   +   +    +    +   +    -     -   - |</span><br><span class="line">SWLP      | +   +   +   +    +    +   -    -     -   - |</span><br><span class="line">SU        | +   +   +   +    +    +   +    +     +   - |</span><br><span class="line">SRO       | +   +   +   -    +    +   +    +     -   - |</span><br><span class="line">SNW       | +   +   +   +    +    +   +    +     +   - |</span><br><span class="line">SNRW      | +   +   +   +    +    +   +    +     +   - |</span><br><span class="line">X         | +   +   +   +    +    +   +    +     +   + |</span><br></pre></td></tr></table></figure><h3 id="常用语句MDL锁加锁分析"><a class="header-anchor" href="#常用语句MDL锁加锁分析"></a>常用语句MDL锁加锁分析</h3><p>使用performance_schema可以辅助分析加锁。利用下面语句打开MDL锁分析，可以看到在只有当前session访问的时候，SELECT语句对metadata_locks表加了TRANSACTION周期的SHARED_READ锁，即锁粒度、时间范围和锁类型分别为：TABLE, TRANSACTION, SHARED_READ，在代码位置sql_parse.cc:5996初始化锁。后面的锁分析也按照锁粒度-时间范围-锁类型介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UPDATE performance_schema.setup_consumers SET ENABLED = &#x27;YES&#x27; WHERE NAME =&#x27;global_instrumentation&#x27;;</span><br><span class="line">UPDATE performance_schema.setup_instruments SET ENABLED = &#x27;YES&#x27; WHERE NAME =&#x27;wait/lock/metadata/sql/mdl&#x27;;</span><br><span class="line">select * from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: TABLE</span><br><span class="line">        OBJECT_SCHEMA: performance_schema</span><br><span class="line">          OBJECT_NAME: metadata_locks</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 46995934864720</span><br><span class="line">            LOCK_TYPE: SHARED_READ</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: sql_parse.cc:5996</span><br><span class="line">      OWNER_THREAD_ID: 26</span><br><span class="line">       OWNER_EVENT_ID: 163</span><br></pre></td></tr></table></figure><p>使用performance_schema很难完整分析语句执行中所有的加锁过程，可以借助gdb分析，在 MDL_context::acquire_lock设置断点。</p><p>下面会结合performance_schema和gdb分析常用语句的MDL加锁源码实现。</p><h4 id="FLUSH-TABLES-WITH-READ-LOCK"><a class="header-anchor" href="#FLUSH-TABLES-WITH-READ-LOCK"></a>FLUSH TABLES WITH READ LOCK</h4><p>语句执行会加锁GLOBAL-EXPLICIT-SHARED和COMMIT-EXPLICIT-SHARED。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">select * from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: GLOBAL</span><br><span class="line">        OBJECT_SCHEMA: NULL</span><br><span class="line">          OBJECT_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 46996001973424</span><br><span class="line">            LOCK_TYPE: SHARED</span><br><span class="line">        LOCK_DURATION: EXPLICIT</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: lock.cc:1110</span><br><span class="line">      OWNER_THREAD_ID: 27</span><br><span class="line">       OWNER_EVENT_ID: 92</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">          OBJECT_TYPE: COMMIT</span><br><span class="line">        OBJECT_SCHEMA: NULL</span><br><span class="line">          OBJECT_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 46996001973616</span><br><span class="line">            LOCK_TYPE: SHARED</span><br><span class="line">        LOCK_DURATION: EXPLICIT</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: lock.cc:1194</span><br><span class="line">      OWNER_THREAD_ID: 27</span><br><span class="line">       OWNER_EVENT_ID: 375</span><br></pre></td></tr></table></figure><p>相关源码实现剖析。当FLUSH语句是FLUSH TABLES WITH READ LOCK的时候，lex-&gt;type会添加REFRESH_TABLES和REFRESH_READ_LOCK标记，当没有指定表即进入reload_acl_and_cache函数，通过调用lock_global_read_lock和make_global_read_lock_block_commit加对应锁，通过对应的锁来阻止元数据修改和表数据更改。DDL语句执行时会请求GLOBAL的INTENTION_EXCLUSIVE锁，事务提交和外部XA需要记录binlog的语句执行会请求COMMIT的INTENTION_EXCLUSIVE锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">sql/sql_yacc.yy</span><br><span class="line">flush_options:</span><br><span class="line">          table_or_tables</span><br><span class="line">          &#123;</span><br><span class="line">            Lex-&gt;type|= REFRESH_TABLES;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              Set type of metadata and table locks for</span></span><br><span class="line"><span class="comment">              FLUSH TABLES table_list [WITH READ LOCK].</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            YYPS-&gt;m_lock_type= TL_READ_NO_INSERT;</span><br><span class="line">            YYPS-&gt;m_mdl_type= MDL_SHARED_HIGH_PRIO;</span><br><span class="line">          &#125;</span><br><span class="line">          opt_table_list &#123;&#125;</span><br><span class="line">          opt_flush_lock &#123;&#125;</span><br><span class="line">        | flush_options_list</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">opt_flush_lock:</span><br><span class="line">          <span class="comment">/* empty */</span> &#123;&#125;</span><br><span class="line">        | WITH READ_SYM LOCK_SYM</span><br><span class="line">          &#123;</span><br><span class="line">            TABLE_LIST *tables= Lex-&gt;query_tables;</span><br><span class="line">            Lex-&gt;type|= REFRESH_READ_LOCK;</span><br><span class="line"></span><br><span class="line">sql/sql_parse.cc</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> SQLCOM_FLUSH:</span><br><span class="line">    <span class="keyword">if</span> (first_table &amp;&amp; lex-&gt;type &amp; REFRESH_READ_LOCK)<span class="comment">//当指定表的时候，对指定表加锁。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">flush_tables_with_read_lock</span>(thd, all_tables))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">reload_acl_and_cache</span>(thd, lex-&gt;type, first_table, &amp;write_to_binlog))</span><br><span class="line"></span><br><span class="line">sql/sql_reload.cc</span><br><span class="line">reload_acl_and_cache</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (options &amp; (REFRESH_TABLES | REFRESH_READ_LOCK))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((options &amp; REFRESH_READ_LOCK) &amp;&amp; thd)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (thd-&gt;global_read_lock.<span class="built_in">lock_global_read_lock</span>(thd))<span class="comment">//当未指定表的时候，加全局锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (thd-&gt;global_read_lock.<span class="built_in">make_global_read_lock_block_commit</span>(thd))<span class="comment">//当未指定表的时候，加COMMIT锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对GLOBAL加EXPLICIT的S锁。</span></span><br><span class="line">sql/lock.<span class="function">cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Global_read_lock::lock_global_read_lock</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                 MDL_key::GLOBAL, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_SHARED, MDL_EXPLICIT);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对COMMIT加EXPLICIT的S锁。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Global_read_lock::make_global_read_lock_block_commit</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                 MDL_key::COMMIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_SHARED, MDL_EXPLICIT);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sql/handler.cc</span><br><span class="line">事务提交和外部XA事务的commit\rollback\prepare均需要加COMMIT的IX锁.</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ha_commit_trans</span><span class="params">(THD *thd, <span class="type">bool</span> all, <span class="type">bool</span> ignore_global_read_lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (rw_trans &amp;&amp; !ignore_global_read_lock) <span class="comment">//对于内部表slave status table的更新可以忽略global read lock</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                 MDL_key::COMMIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                 MDL_EXPLICIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DBUG_PRINT</span>(<span class="string">&quot;debug&quot;</span>, (<span class="string">&quot;Acquire MDL commit lock&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">acquire_lock</span>(&amp;mdl_request,</span><br><span class="line">                                  thd-&gt;variables.lock_wait_timeout))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">sql/xa.<span class="function">cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Sql_cmd_xa_commit::trans_xa_commit</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  MDL_request mdl_request;</span><br><span class="line">  <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                   MDL_key::COMMIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                   MDL_STATEMENT);</span><br><span class="line">  <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">acquire_lock</span>(&amp;mdl_request,</span><br><span class="line">                                    thd-&gt;variables.lock_wait_timeout))</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Sql_cmd_xa_rollback::trans_xa_rollback</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  MDL_request mdl_request;</span><br><span class="line">  <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                   MDL_key::COMMIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                   MDL_STATEMENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Sql_cmd_xa_prepare::trans_xa_prepare</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  MDL_request mdl_request;</span><br><span class="line">  <span class="built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request,</span><br><span class="line">                   MDL_key::COMMIT, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                   MDL_STATEMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入语句的执行和DDL执行需要GLOBAL的IX锁，这与S锁不兼容。</span></span><br><span class="line">sql/sql_base.<span class="function">cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">open_table</span><span class="params">(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (table_list-&gt;mdl_request.<span class="built_in">is_write_lock_request</span>() &amp;&amp;</span><br><span class="line">  &#123;</span><br><span class="line">    MDL_request protection_request;</span><br><span class="line">    MDL_deadlock_handler <span class="built_in">mdl_deadlock_handler</span>(ot_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;global_read_lock.<span class="built_in">can_acquire_protection</span>())</span><br><span class="line">      <span class="built_in">DBUG_RETURN</span>(TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(&amp;protection_request,</span><br><span class="line">                     MDL_key::GLOBAL, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                     MDL_STATEMENT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="built_in">lock_table_names</span>(THD *thd,</span><br><span class="line">                 TABLE_LIST *tables_start, TABLE_LIST *tables_end,</span><br><span class="line">                 ulong lock_wait_timeout, uint flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (need_global_read_lock_protection)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Protect this statement against concurrent global read lock</span></span><br><span class="line"><span class="comment">      by acquiring global intention exclusive lock with statement</span></span><br><span class="line"><span class="comment">      duration.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;global_read_lock.<span class="built_in">can_acquire_protection</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(&amp;global_request,</span><br><span class="line">                     MDL_key::GLOBAL, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                     MDL_STATEMENT);</span><br><span class="line">    mdl_requests.<span class="built_in">push_front</span>(&amp;global_request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LOCK-TABLE-t-READ-LOCAL"><a class="header-anchor" href="#LOCK-TABLE-t-READ-LOCAL"></a>LOCK TABLE t READ [LOCAL]</h4><p>LOCK TABLE t READ LOCAL会加锁TABLE-TRANSACTION-SHARED_READ。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select * from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: TABLE</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: t</span><br><span class="line">            LOCK_TYPE: SHARED_READ</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: sql_parse.cc:5996</span><br></pre></td></tr></table></figure><p>LOCK TABLE t READ会加锁TABLE-TRANSACTION-SHARED_READ_ONLY。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select * from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: TABLE</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: t</span><br><span class="line">            LOCK_TYPE: SHARED_READ_ONLY</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: sql_parse.cc:5996</span><br></pre></td></tr></table></figure><p>这两个的区别是对于MyISAM引擎，LOCAL方式的加锁与insert写入不冲突，而没有LOCAL的时候SHARED_READ_ONLY会阻塞写入。不过对于InnoDB引擎两种方式是一样的，带有LOCAL的语句执行后面会升级为SHARED_READ_ONLY。</p><p>源码分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">table_lock:</span><br><span class="line">          table_ident opt_table_alias lock_option</span><br><span class="line">          &#123;</span><br><span class="line">            thr_lock_type lock_type= (thr_lock_type) $<span class="number">3</span>;</span><br><span class="line">            enum_mdl_type mdl_lock_type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lock_type &gt;= TL_WRITE_ALLOW_WRITE)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* LOCK TABLE ... WRITE/LOW_PRIORITY WRITE */</span></span><br><span class="line">              mdl_lock_type= MDL_SHARED_NO_READ_WRITE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lock_type == TL_READ)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* LOCK TABLE ... READ LOCAL */</span></span><br><span class="line">              mdl_lock_type= MDL_SHARED_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* LOCK TABLE ... READ */</span></span><br><span class="line">              mdl_lock_type= MDL_SHARED_READ_ONLY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Select-&gt;<span class="built_in">add_table_to_list</span>(YYTHD, $<span class="number">1</span>, $<span class="number">2</span>, <span class="number">0</span>, lock_type,</span><br><span class="line">                                           mdl_lock_type))</span><br><span class="line">              MYSQL_YYABORT;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">lock_option:</span><br><span class="line">          READ_SYM               &#123; $= TL_READ_NO_INSERT; &#125;</span><br><span class="line">        | WRITE_SYM              &#123; $= TL_WRITE_DEFAULT; &#125;</span><br><span class="line">        | LOW_PRIORITY WRITE_SYM</span><br><span class="line">          &#123;</span><br><span class="line">            $= TL_WRITE_LOW_PRIORITY;</span><br><span class="line">            <span class="built_in">push_deprecated_warn</span>(YYTHD, <span class="string">&quot;LOW_PRIORITY WRITE&quot;</span>, <span class="string">&quot;WRITE&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        | READ_SYM LOCAL_SYM     &#123; $= TL_READ; &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">sql/sql_parse.<span class="function">cc</span></span><br><span class="line"><span class="function">TABLE_LIST *<span class="title">st_select_lex::add_table_to_list</span><span class="params">(THD *thd,</span></span></span><br><span class="line"><span class="params"><span class="function">               Table_ident *table,</span></span></span><br><span class="line"><span class="params"><span class="function">               LEX_STRING *alias,</span></span></span><br><span class="line"><span class="params"><span class="function">               ulong table_options,</span></span></span><br><span class="line"><span class="params"><span class="function">               thr_lock_type lock_type,</span></span></span><br><span class="line"><span class="params"><span class="function">               enum_mdl_type mdl_type,</span></span></span><br><span class="line"><span class="params"><span class="function">               List&lt;Index_hint&gt; *index_hints_arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             List&lt;String&gt; *partition_names,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             LEX_STRING *option)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Pure table aliases do not need to be locked:</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">MY_TEST</span>(table_options &amp; TL_OPTION_ALIAS))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(&amp; ptr-&gt;mdl_request,</span><br><span class="line">                     MDL_key::TABLE, ptr-&gt;db, ptr-&gt;table_name, mdl_type,</span><br><span class="line">                     MDL_TRANSACTION);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于Innodb引擎</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">lock_tables_open_and_lock_tables</span><span class="params">(THD *thd, TABLE_LIST *tables)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (table-&gt;lock_type == TL_READ &amp;&amp;</span><br><span class="line">           ! table-&gt;prelocking_placeholder &amp;&amp;</span><br><span class="line">           table-&gt;table-&gt;file-&gt;<span class="built_in">ha_table_flags</span>() &amp; HA_NO_READ_LOCAL_LOCK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      In case when LOCK TABLE ... READ LOCAL was issued for table with</span></span><br><span class="line"><span class="comment">      storage engine which doesn&#x27;t support READ LOCAL option and doesn&#x27;t</span></span><br><span class="line"><span class="comment">      use THR_LOCK locks we need to upgrade weak SR metadata lock acquired</span></span><br><span class="line"><span class="comment">      in open_tables() to stronger SRO metadata lock.</span></span><br><span class="line"><span class="comment">      This is not needed for tables used through stored routines or</span></span><br><span class="line"><span class="comment">      triggers as we always acquire SRO (or even stronger SNRW) metadata</span></span><br><span class="line"><span class="comment">      lock for them.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">bool</span> result= thd-&gt;mdl_context.<span class="built_in">upgrade_shared_lock</span>(</span><br><span class="line">                                    table-&gt;table-&gt;mdl_ticket,</span><br><span class="line">                                    MDL_SHARED_READ_ONLY,</span><br><span class="line">                                    thd-&gt;variables.lock_wait_timeout);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LOCK-TABLE-t-WITH-WRITE"><a class="header-anchor" href="#LOCK-TABLE-t-WITH-WRITE"></a>LOCK TABLE t WITH WRITE</h4><p>LOCK TABLE t WITH WRITE会加锁：GLOBAL-STATEMENT-INTENTION_EXCLUSIVE，SCHEMA-TRANSACTION-INTENTION_EXCLUSIVE，TABLE-TRANSACTION-SHARED_NO_READ_WRITE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select OBJECT_TYPE,OBJECT_SCHEMA,OBJECT_NAME,LOCK_TYPE,LOCK_DURATION,SOURCE from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: GLOBAL</span><br><span class="line">        OBJECT_SCHEMA: NULL</span><br><span class="line">          OBJECT_NAME: NULL</span><br><span class="line">            LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">        LOCK_DURATION: STATEMENT</span><br><span class="line">               SOURCE: sql_base.cc:5497</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">          OBJECT_TYPE: SCHEMA</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: NULL</span><br><span class="line">            LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">               SOURCE: sql_base.cc:5482</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">          OBJECT_TYPE: TABLE</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: ti</span><br><span class="line">            LOCK_TYPE: SHARED_NO_READ_WRITE</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">               SOURCE: sql_parse.cc:5996</span><br></pre></td></tr></table></figure><p>相关源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lock_table_names</span><span class="params">(THD *thd,</span></span></span><br><span class="line"><span class="params"><span class="function">                 TABLE_LIST *tables_start, TABLE_LIST *tables_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ulong lock_wait_timeout, uint flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> ((table= it++))</span><br><span class="line">  &#123;</span><br><span class="line">    MDL_request *schema_request= <span class="built_in">new</span> (thd-&gt;mem_root) MDL_request;</span><br><span class="line">    <span class="keyword">if</span> (schema_request == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(schema_request,</span><br><span class="line">                     MDL_key::SCHEMA, table-&gt;db, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                     MDL_TRANSACTION);</span><br><span class="line">    mdl_requests.<span class="built_in">push_front</span>(schema_request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (need_global_read_lock_protection)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Protect this statement against concurrent global read lock</span></span><br><span class="line"><span class="comment">      by acquiring global intention exclusive lock with statement</span></span><br><span class="line"><span class="comment">      duration.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;global_read_lock.<span class="built_in">can_acquire_protection</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">MDL_REQUEST_INIT</span>(&amp;global_request,</span><br><span class="line">                     MDL_key::GLOBAL, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                     MDL_STATEMENT);</span><br><span class="line">    mdl_requests.<span class="built_in">push_front</span>(&amp;global_request);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Phase 3: Acquire the locks which have been requested so far.</span></span><br><span class="line">  <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">acquire_locks</span>(&amp;mdl_requests, lock_wait_timeout))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在open_table中也会请求锁。</span><br><span class="line"></span><br><span class="line">SHARED_NO_READ_WRITE的加锁源码参考LOCK TABLE WITH READ的源码分析。</span><br></pre></td></tr></table></figure><h4 id="SELECT查询语句的执行"><a class="header-anchor" href="#SELECT查询语句的执行"></a>SELECT查询语句的执行</h4><p>SELECT语句的执行加锁TABLE-TRANSACTION-SHARED_READ锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select * from performance_schema.metadata_locks\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">          OBJECT_TYPE: TABLE</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: t1</span><br><span class="line">            LOCK_TYPE: SHARED_READ</span><br><span class="line">        LOCK_DURATION: TRANSACTION</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">               SOURCE: sql_parse.cc:5996</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Yacc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    yacc_yyss= <span class="literal">NULL</span>;</span><br><span class="line">    yacc_yyvs= <span class="literal">NULL</span>;</span><br><span class="line">    yacc_yyls= <span class="literal">NULL</span>;</span><br><span class="line">    m_lock_type= TL_READ_DEFAULT;</span><br><span class="line">    m_mdl_type= MDL_SHARED_READ;</span><br><span class="line">    m_ha_rkey_mode= HA_READ_KEY_EXACT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用add_table_to_list初始化锁，调用open_table_get_mdl_lock获取锁。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">open_table_get_mdl_lock</span><span class="params">(THD *thd, Open_table_context *ot_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                        TABLE_LIST *table_list, uint flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        MDL_ticket **mdl_ticket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">bool</span> result= thd-&gt;mdl_context.<span class="built_in">acquire_lock</span>(mdl_request,</span><br><span class="line">                                           ot_ctx-&gt;<span class="built_in">get_timeout</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="INSERT-UPDATE-DELETE语句"><a class="header-anchor" href="#INSERT-UPDATE-DELETE语句"></a>INSERT/UPDATE/DELETE语句</h4><p>在open table阶段会获取GLOBAL-STATEMENT-INTENTION_EXCLUSIVE，TABLE-TRANSACTION-SHARED_WRITE。</p><p>在commit阶段获取COMMIT-MDL_EXPLICIT-INTENTION_EXCLUSIVE锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">select OBJECT_TYPE,OBJECT_SCHEMA,OBJECT_NAME,LOCK_TYPE,LOCK_DURATION,SOURCE from performance_schema.metadata_locks\G</span><br><span class="line">OBJECT_TYPE: GLOBAL</span><br><span class="line">OBJECT_SCHEMA: NULL</span><br><span class="line">OBJECT_NAME: NULL</span><br><span class="line">  LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">LOCK_DURATION: STATEMENT</span><br><span class="line">     SOURCE: sql_base.cc:3190</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">OBJECT_TYPE: TABLE</span><br><span class="line">OBJECT_SCHEMA: test</span><br><span class="line">OBJECT_NAME: ti</span><br><span class="line">  LOCK_TYPE: SHARED_WRITE</span><br><span class="line">LOCK_DURATION: TRANSACTION</span><br><span class="line">     SOURCE: sql_parse.cc:5996</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">OBJECT_TYPE: COMMIT</span><br><span class="line">OBJECT_SCHEMA: NULL</span><br><span class="line">OBJECT_NAME: NULL</span><br><span class="line">  LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">LOCK_DURATION: EXPLICIT</span><br><span class="line">     SOURCE: handler.cc:1758</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">sql/sql_yacc.yy</span><br><span class="line">insert_stmt:</span><br><span class="line">          INSERT                       <span class="comment">/* #1 */</span></span><br><span class="line">          insert_lock_option           <span class="comment">/* #2 */</span></span><br><span class="line"></span><br><span class="line">          insert_lock_option:</span><br><span class="line">                    <span class="comment">/* empty */</span>   &#123; $= TL_WRITE_CONCURRENT_DEFAULT; &#125;</span><br><span class="line">                  | LOW_PRIORITY  &#123; $= TL_WRITE_LOW_PRIORITY; &#125;</span><br><span class="line">                  | DELAYED_SYM</span><br><span class="line">                  &#123;</span><br><span class="line">                    $= TL_WRITE_CONCURRENT_DEFAULT;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">push_warning_printf</span>(YYTHD, Sql_condition::SL_WARNING,</span><br><span class="line">                                        ER_WARN_LEGACY_SYNTAX_CONVERTED,</span><br><span class="line">                                        <span class="built_in">ER</span>(ER_WARN_LEGACY_SYNTAX_CONVERTED),</span><br><span class="line">                                        <span class="string">&quot;INSERT DELAYED&quot;</span>, <span class="string">&quot;INSERT&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  | HIGH_PRIORITY &#123; $= TL_WRITE; &#125;</span><br><span class="line">                  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DELETE语句</span></span><br><span class="line">delete_stmt:</span><br><span class="line">          DELETE_SYM</span><br><span class="line">          opt_delete_options</span><br><span class="line"></span><br><span class="line"><span class="comment">//UPDATE</span></span><br><span class="line">update_stmt:</span><br><span class="line">  UPDATE_SYM            <span class="comment">/* #1 */</span></span><br><span class="line">  opt_low_priority      <span class="comment">/* #2 */</span></span><br><span class="line">  opt_ignore            <span class="comment">/* #3 */</span></span><br><span class="line">  join_table_list       <span class="comment">/* #4 */</span></span><br><span class="line">  SET                   <span class="comment">/* #5 */</span></span><br><span class="line">  update_list           <span class="comment">/* #6 */</span></span><br><span class="line"></span><br><span class="line">opt_low_priority:</span><br><span class="line">          <span class="comment">/* empty */</span> &#123; $= TL_WRITE_DEFAULT; &#125;</span><br><span class="line">        | LOW_PRIORITY &#123; $= TL_WRITE_LOW_PRIORITY; &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">opt_delete_options:</span><br><span class="line">          <span class="comment">/* empty */</span>                          &#123; $= <span class="number">0</span>; &#125;</span><br><span class="line">        | opt_delete_option opt_delete_options &#123; $= $<span class="number">1</span> | $<span class="number">2</span>; &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">opt_delete_option:</span><br><span class="line">          QUICK        &#123; $= DELETE_QUICK; &#125;</span><br><span class="line">        | LOW_PRIORITY &#123; $= DELETE_LOW_PRIORITY; &#125;</span><br><span class="line">        | IGNORE_SYM   &#123; $= DELETE_IGNORE; &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">sql/parse_tree_nodes.<span class="function">cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PT_delete::add_table</span><span class="params">(Parse_context *pc, Table_ident *table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">const</span> enum_mdl_type mdl_type=</span><br><span class="line">  (opt_delete_options &amp; DELETE_LOW_PRIORITY) ? MDL_SHARED_WRITE_LOW_PRIO</span><br><span class="line">                                             : MDL_SHARED_WRITE;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PT_insert::contextualize</span><span class="params">(Parse_context *pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pc-&gt;select-&gt;<span class="built_in">add_table_to_list</span>(pc-&gt;thd, table_ident, <span class="literal">NULL</span>,</span><br><span class="line">                                   TL_OPTION_UPDATING,</span><br><span class="line">                                   yyps-&gt;m_lock_type,</span><br><span class="line">                                   yyps-&gt;m_mdl_type,</span><br><span class="line">                                   <span class="literal">NULL</span>,</span><br><span class="line">                                   opt_use_partition))</span><br><span class="line">   pc-&gt;select-&gt;<span class="built_in">set_lock_for_tables</span>(lock_option);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PT_update::contextualize</span><span class="params">(Parse_context *pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pc-&gt;select-&gt;<span class="built_in">set_lock_for_tables</span>(opt_low_priority);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">st_select_lex::set_lock_for_tables</span><span class="params">(thr_lock_type lock_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">bool</span> for_update= lock_type &gt;= TL_READ_NO_INSERT;</span><br><span class="line">  enum_mdl_type mdl_type= <span class="built_in">mdl_type_for_dml</span>(lock_type);</span><br><span class="line">  ...</span><br><span class="line">  tables-&gt;mdl_request.<span class="built_in">set_type</span>(mdl_type);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">enum</span> enum_mdl_type <span class="title">mdl_type_for_dml</span><span class="params">(<span class="keyword">enum</span> thr_lock_type lock_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lock_type &gt;= TL_WRITE_ALLOW_WRITE ?</span><br><span class="line">         (lock_type == TL_WRITE_LOW_PRIORITY ?</span><br><span class="line">          MDL_SHARED_WRITE_LOW_PRIO : MDL_SHARED_WRITE) :</span><br><span class="line">         MDL_SHARED_READ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最终调用open\_table加锁</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">open_table</span><span class="params">(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (table_list-&gt;mdl_request.<span class="built_in">is_write_lock_request</span>() &amp;&amp;</span><br><span class="line">     ...</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">MDL_REQUEST_INIT</span>(&amp;protection_request,</span><br><span class="line">                  MDL_key::GLOBAL, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, MDL_INTENTION_EXCLUSIVE,</span><br><span class="line">                  MDL_STATEMENT);</span><br><span class="line">     <span class="type">bool</span> result= thd-&gt;mdl_context.<span class="built_in">acquire_lock</span>(&amp;protection_request,</span><br><span class="line">                                                ot_ctx-&gt;<span class="built_in">get_timeout</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">open_table_get_mdl_lock</span>(thd, ot_ctx, table_list, flags, &amp;mdl_ticket) ||</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在commit阶段调用ha_commit_trans函数时加COMMIT的INTENTION_EXCLUSIVE锁，源码如FLUSH TABLES WITH READ LOCK所述。</span><br></pre></td></tr></table></figure><p>如果INSERT/UPDATE/DELETE LOW_PRIORITY语句TABLE上加MDL_SHARED_WRITE_LOW_PRIO锁。</p><h4 id="ALTER-TABLE-ALGORITHM-COPY-INPLACE"><a class="header-anchor" href="#ALTER-TABLE-ALGORITHM-COPY-INPLACE"></a>ALTER TABLE ALGORITHM=COPY[INPLACE]</h4><p>ALTER TABLE ALGORITHM=COPY</p><p>COPY方式ALTER TABLE在open_table阶段加GLOBAL-STATEMENT-INTENTION_EXCLUSIVE锁，SCHEMA-TRANSACTION-INTENTION_EXCLUSIVE锁，TABLE-TRANSACTION-SHARED_UPGRADABLE锁。</p><p>在拷贝数据前将TABLE-TRANSACTION-SHARED_UPGRADABLE锁升级到SHARED_NO_WRITE。</p><p>拷贝完在交换表阶段将SHARED_NO_WRITE锁升级到EXCLUSIVE锁。</p><p>源码解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL、SCHEMA锁初始化位置和LOCK TABLE WRITE位置一致都是在lock_table_names函数中。在open_table中也会请求锁。</span><br><span class="line"></span><br><span class="line">sql/sql_yacc.yy</span><br><span class="line">alter:</span><br><span class="line">          ALTER TABLE_SYM table_ident</span><br><span class="line">          &#123;</span><br><span class="line">            THD *thd= YYTHD;</span><br><span class="line">            LEX *lex= thd-&gt;lex;</span><br><span class="line">            lex-&gt;name.str= <span class="number">0</span>;</span><br><span class="line">            lex-&gt;name.length= <span class="number">0</span>;</span><br><span class="line">            lex-&gt;sql_command= SQLCOM_ALTER_TABLE;</span><br><span class="line">            lex-&gt;duplicates= DUP_ERROR;</span><br><span class="line">            <span class="keyword">if</span> (!lex-&gt;select_lex-&gt;<span class="built_in">add_table_to_list</span>(thd, $<span class="number">3</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                                    TL_OPTION_UPDATING,</span><br><span class="line">                                                    TL_READ_NO_INSERT,</span><br><span class="line">                                                    MDL_SHARED_UPGRADABLE))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mysql_alter_table</span><span class="params">(THD *thd, <span class="type">const</span> <span class="type">char</span> *new_db, <span class="type">const</span> <span class="type">char</span> *new_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       HA_CREATE_INFO *create_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                       TABLE_LIST *table_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Alter_info *alter_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//升级锁</span></span><br><span class="line">  <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">upgrade_shared_lock</span>(mdl_ticket, MDL_SHARED_NO_WRITE,</span><br><span class="line">                                           thd-&gt;variables.lock_wait_timeout)</span><br><span class="line">      || <span class="built_in">lock_tables</span>(thd, table_list, alter_ctx.tables_opened, <span class="number">0</span>))</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">wait_while_table_is_used</span>(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_while_table_is_used</span><span class="params">(THD *thd, TABLE *table,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">enum</span> ha_extra_function function)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">DBUG_ENTER</span>(<span class="string">&quot;wait_while_table_is_used&quot;</span>);</span><br><span class="line">  <span class="built_in">DBUG_PRINT</span>(<span class="string">&quot;enter&quot;</span>, (<span class="string">&quot;table: &#x27;%s&#x27;  share: 0x%lx  db_stat: %u  version: %lu&quot;</span>,</span><br><span class="line">                       table-&gt;s-&gt;table_name.str, (ulong) table-&gt;s,</span><br><span class="line">                       table-&gt;db_stat, table-&gt;s-&gt;version));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">upgrade_shared_lock</span>(</span><br><span class="line">             table-&gt;mdl_ticket, MDL_EXCLUSIVE,</span><br><span class="line">             thd-&gt;variables.lock_wait_timeout))</span><br></pre></td></tr></table></figure><p>ALTER TABLE INPLACE的加锁：</p><p>INPLACE方式在打开表的时候也是加GLOBAL-STATEMENT-INTENTION_EXCLUSIVE锁，SCHEMA-TRANSACTION-INTENTION_EXCLUSIVE锁，TABLE-TRANSACTION-SHARED_UPGRADABLE锁。</p><p>在prepare前将TABLE-TRANSACTION-SHARED_UPGRADABLE升级为TABLE-TRANSACTION-EXCLUSIVE锁。</p><p>在prepare后会再将EXCLUSIVE根据不同引擎支持情况降级为SHARED_NO_WRITE(不允许其他线程写入)或者SHARED_UPGRADABLE锁（其他线程可以读写，InnoDB引擎）。</p><p>在commit前，TABLE上的锁会再次升级到EXCLUSIVE锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">sql/sql_table.<span class="function">cc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">mysql_inplace_alter_table</span><span class="params">(THD *thd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TABLE_LIST *table_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TABLE *table,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TABLE *altered_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Alter_inplace_info *ha_alter_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      enum_alter_inplace_result inplace_supported,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      MDL_request *target_mdl_request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Alter_table_ctx *alter_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||</span><br><span class="line">           inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Storage engine has requested exclusive lock only for prepare phase</span></span><br><span class="line"><span class="comment">      and we are not under LOCK TABLES.</span></span><br><span class="line"><span class="comment">      Don&#x27;t mark TABLE_SHARE as old in this case, as this won&#x27;t allow opening</span></span><br><span class="line"><span class="comment">      of table by other threads during main phase of in-place ALTER TABLE.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;mdl_context.<span class="built_in">upgrade_shared_lock</span>(table-&gt;mdl_ticket, MDL_EXCLUSIVE,</span><br><span class="line">                                             thd-&gt;variables.lock_wait_timeout))</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (table-&gt;file-&gt;<span class="built_in">ha_prepare_inplace_alter_table</span>(altered_table,</span><br><span class="line">                                                ha_alter_info))</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ((inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||</span><br><span class="line">     inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE) &amp;&amp;</span><br><span class="line">    !(thd-&gt;locked_tables_mode == LTM_LOCK_TABLES ||</span><br><span class="line">      thd-&gt;locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES) &amp;&amp;</span><br><span class="line">    (alter_info-&gt;requested_lock != Alter_info::ALTER_TABLE_LOCK_EXCLUSIVE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* If storage engine or user requested shared lock downgrade to SNW. */</span></span><br><span class="line">    <span class="keyword">if</span> (inplace_supported == HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE ||</span><br><span class="line">        alter_info-&gt;requested_lock == Alter_info::ALTER_TABLE_LOCK_SHARED)</span><br><span class="line">      table-&gt;mdl_ticket-&gt;<span class="built_in">downgrade_lock</span>(MDL_SHARED_NO_WRITE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">DBUG_ASSERT</span>(inplace_supported == HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE);</span><br><span class="line">      table-&gt;mdl_ticket-&gt;<span class="built_in">downgrade_lock</span>(MDL_SHARED_UPGRADABLE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Upgrade to EXCLUSIVE before commit.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">wait_while_table_is_used</span>(thd, table, HA_EXTRA_PREPARE_FOR_RENAME))</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (table-&gt;file-&gt;<span class="built_in">ha_commit_inplace_alter_table</span>(altered_table,</span><br><span class="line">                                               ha_alter_info,</span><br><span class="line">                                               <span class="literal">true</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CREATE-TABLE-加锁"><a class="header-anchor" href="#CREATE-TABLE-加锁"></a>CREATE TABLE 加锁</h4><p>CREATE TABLE先加锁GLOBAL-STATEMENT-INTENTION_EXCLUSIVE，SCHEMA-MDL_TRANSACTION-INTENTION_EXCLUSIVE，TABLE-TRANSACTION-SHARED。</p><p>表不存在则升级表上的SHARED锁到EXCLUSIVE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">open_table</span><span class="params">(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!exists)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> wait_result= thd-&gt;mdl_context.<span class="built_in">upgrade_shared_lock</span>(</span><br><span class="line">                         table_list-&gt;mdl_request.ticket,</span><br><span class="line">                         MDL_EXCLUSIVE,</span><br><span class="line">                         thd-&gt;variables.lock_wait_timeout);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DROP-TABLE-加锁"><a class="header-anchor" href="#DROP-TABLE-加锁"></a>DROP TABLE 加锁</h3><p>drop table语句执行加锁GLOBAL-STATEMENT-INTENTION_EXCLUSIVE，SCHEMA-MDL_TRANSACTION-INTENTION_EXCLUSIVE，TABLE-EXCLUSIVE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">drop:</span><br><span class="line">          DROP opt_temporary table_or_tables if_exists</span><br><span class="line">          &#123;</span><br><span class="line">            LEX *lex=Lex;</span><br><span class="line">            lex-&gt;sql_command = SQLCOM_DROP_TABLE;</span><br><span class="line">            lex-&gt;drop_temporary= $<span class="number">2</span>;</span><br><span class="line">            lex-&gt;drop_if_exists= $<span class="number">4</span>;</span><br><span class="line">            YYPS-&gt;m_lock_type= TL_UNLOCK;</span><br><span class="line">            YYPS-&gt;m_mdl_type= MDL_EXCLUSIVE;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>本文地址：<a href="http://xnerv.wang/analysis-of-mdl-source-code-for-common-sql-statements/">http://xnerv.wang/analysis-of-mdl-source-code-for-common-sql-statements/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2018/02/01/">常用SQL语句的MDL加锁源码分析</a></p>]]></content>
    
    
    <summary type="html">&lt;section class=&quot;post&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;MySQL5.5版本开始引入了MDL锁用来保护元数据信息，让MySQL能够在并发环境下多DDL、DML同时操作下保持元数据的一致性。本文用MySQL5.7源码分析了常用SQL语句的MDL加锁实现。&lt;/p&gt;
&lt;h4 id=&quot;MDL锁粒度&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MDL锁粒度&quot;&gt;&lt;/a&gt;MDL锁粒度&lt;/h4&gt;
&lt;p&gt;MDL_key由namespace、db_name、name组成。&lt;/p&gt;
&lt;p&gt;namespace包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GLOBAL。用于global read lock，例如FLUSH TABLES WITH READ LOCK。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TABLESPACE/SCHEMA。用于保护tablespace/schema。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FUNCTION/PROCEDURE/TRIGGER/EVENT。用于保护function/procedure/trigger/event。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;COMMIT。主要用于global read lock后，阻塞事务提交。（在DML的commit阶段也会获取COMMIT锁）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;USER_LEVEL_LOCK。用于&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/user-level-locks.html&quot;&gt;user level lock函数&lt;/a&gt;的实现，GET_LOCK(str,timeout)， RELEASE_LOCK(str)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LOCKING_SERVICE。用于&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/locking-service.html&quot;&gt;locking service&lt;/a&gt;的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="MDL" scheme="https://xnerv.wang/tags/MDL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 利用gdb跟踪MDL加锁过程（转载）</title>
    <link href="https://xnerv.wang/trace-metadata-lock-procedure-using-gdb/"/>
    <id>https://xnerv.wang/trace-metadata-lock-procedure-using-gdb/</id>
    <published>2018-03-22T02:38:00.000Z</published>
    <updated>2023-08-21T02:40:00.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MDL-Meta-Data-LocK-的作用"><a class="header-anchor" href="#MDL-Meta-Data-LocK-的作用"></a>MDL(Meta Data LocK)的作用</h2><p>在MySQL5.1及之前的版本中，如果有未提交的事务trx，当执行DROP/RENAME/ALTER TABLE RENAME操作时，不会被其他事务阻塞住。这会导致如下问题(MySQL bug#989)</p><p>master： 未提交的事务，但SQL已经完成(binlog也准备好了)，表schema发生更改，在commit的时候不会被察觉到.</p><p>slave： 在binlog里是以事务提交顺序记录的，DDL隐式提交，因此在备库先执行DDL，后执行事务trx，由于trx作用的表已经发生了改变，因此trx会执行失败。 在DDL时的主库DML压力越大，这个问题触发的可能性就越高</p><p>在5.5引入了MDL（meta data lock）锁来解决在这个问题</p><span id="more"></span><h2 id="MDL锁的类型"><a class="header-anchor" href="#MDL锁的类型"></a>MDL锁的类型</h2><p>metadata lock也是一种锁。每个metadata lock都会定义锁住的对象，锁的持有时间和锁的类型</p><table><thead><tr><th>属性</th><th>范围</th><th>作用</th></tr></thead><tbody><tr><td>GLOBAL</td><td>全局锁</td><td>主要作用是防止DDL和写操作的过程中执行 set golbal_read_only =on 或flush tables with read lock;</td></tr><tr><td>commit</td><td>提交保护锁</td><td>主要作用是执行flush tables with read lock后，防止已经开始在执行的写事务提交</td></tr><tr><td>SCHEMA</td><td>库锁</td><td>对象</td></tr><tr><td>TABLE</td><td>表锁</td><td>对象</td></tr><tr><td>FUNCTION</td><td>函数锁</td><td>对象</td></tr><tr><td>PROCEDURE</td><td>存储过程锁</td><td>对象</td></tr><tr><td>TRIGGER</td><td>触发器锁</td><td>对象</td></tr><tr><td>EVENT</td><td>事件锁</td><td>对象</td></tr></tbody></table><p>这些锁具有以下层级关系<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9fef60e1111bdbc1e883646a85adeb67.png" alt="MDL_SCOPE.png"></p><h2 id="MDL锁的简单示例"><a class="header-anchor" href="#MDL锁的简单示例"></a>MDL锁的简单示例</h2><p>在实际工作中，最常见的MDL冲突就DDL的操作被没用提交的事务所阻塞。 我们下面通过一个具体的实例来演示DDL加MDL锁的过程。在这个实例中，利用gdb来跟踪DDL申请MDL锁的过程。</p><p>会话1:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> ti(id <span class="type">int</span> <span class="keyword">primary</span> key, c1 <span class="type">int</span>, key(c1)) engine<span class="operator">=</span>InnoDB</span><br><span class="line">stats_auto_recalc<span class="operator">=</span><span class="keyword">default</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> ti <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> transaction;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ti;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> c1   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>再开启第二个会话,利用gdb来跟踪mysql加MDL的过程 会话2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ps -ef|grep mysql</span><br><span class="line">root      3336  2390  0 06:33 pts/2    00:00:01 /u02/mysql/bin/mysqld --basedir=/u02/mysql/ --datadir=/u02/mysql/data</span><br><span class="line">--plugin-dir=/u02/mysql//lib/plugin --user=root</span><br><span class="line">--log-error=/u02/mysql/tmp/error1.log --open-files-limit=10240</span><br><span class="line">--pid-file=/u02/mysql/tmp/mysql.pid</span><br><span class="line">--socket=/u02/mysql/tmp/mysql.sock --port=3306</span><br><span class="line"></span><br><span class="line">[root@localhost mysql]# gdb -p 3336</span><br><span class="line">----在GDB设置以下断点</span><br><span class="line">(gdb) b MDL_context::acquire_lock</span><br><span class="line">Breakpoint 1 at 0x730cab: file /u02/mysql-server-5.6/sql/mdl.cc, line 2187.</span><br><span class="line">(gdb) b lock_rec_lock</span><br><span class="line">Breakpoint 2 at 0xb5ef50: file /u02/mysql-server-5.6/storage/innobase/lock/lock0lock.cc, line 2296.</span><br><span class="line"></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.....</span><br></pre></td></tr></table></figure><p>开启第三个会话</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> ti stats_auto_recalc<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">这个操作被hang住</span><br></pre></td></tr></table></figure><p>在会话2中执行下面的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p mdl_request</span><br><span class="line">$1 = (MDL_request *) 0x7f697d1c3bd0</span><br><span class="line">(gdb) p *mdl_request</span><br><span class="line">$2 = &#123;</span><br><span class="line">type = MDL_INTENTION_EXCLUSIVE, duration = MDL_STATEMENT, next_in_list = 0x7f697002a560, prev_in_list = 0x7f697d1c3df8, ticket = 0x0, key = &#123;m_length = 3, m_db_name_length = 0,</span><br><span class="line">    m_ptr = &#x27;\000&#x27; &lt;repeats 20 times&gt;, &quot;0|\002p\000\000\001\000\060&lt;\034&#125;i\177\000\000&gt;\240\344\000\000\000\000\000\000\t\000pi\177\000\000\000\t\000pi\177\000\000`&gt;\034&#125;i\177\000\000V\312\344\000\000\000\000\000\240&gt;\034&#125;i\177\000\000\333\361\254\000b\001\000\000\a?\000\001&quot;, &#x27;\000&#x27; &lt;repeats 20 times&gt;, &quot;0|\002p\000\000\001\000\220&lt;\034&#125;i\177\000\000&gt;\240\344\000\000\000\000\000\340\236\002pi\177\000\000\333\361\254\000\000\000\000\000\a?\000\001&quot;, &#x27;\000&#x27; &lt;repeats 12 times&gt;&quot;\340, &gt;\034&#125;i\177\000\000\060|\002p\000\000\001\000\350\062\220\003\000\000\000\000\333\361\254\000\000\000\000\000$\226\363&quot;, &#x27;\000&#x27; &lt;repeats 14 times&gt;,</span><br><span class="line">&quot;?\034&#125;i\177\000\000\060|\002p\000\000\001\000\000=\034&#125;i\177\000\000&gt;\240\344\000\000\000\000\000\000&quot;...,</span><br><span class="line">static m_namespace_to_wait_state_name = &#123;</span><br><span class="line">&#123;m_key = 101,</span><br><span class="line">        m_name = 0xf125a2 &quot;Waiting for global read lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 102,</span><br><span class="line">m_name = 0xf125c0 &quot;Waiting for schema metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 103,</span><br><span class="line">        m_name = 0xf125e8 &quot;Waiting for table metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 104,</span><br><span class="line">m_name = 0xf12608 &quot;Waiting for stored function metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 105,</span><br><span class="line">        m_name = 0xf12638 &quot;Waiting for stored procedure metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 106,</span><br><span class="line">m_name = 0xf12668 &quot;Waiting for trigger metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 107,</span><br><span class="line">        m_name = 0xf12690 &quot;Waiting for event metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 108,</span><br><span class="line">m_name = 0xf126b0 &quot;Waiting for commit lock&quot;, m_flags = 0&#125;&#125;&#125;&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>从上面的输出中，我只能看到申请了一个语句级别的MDL_INTENTION_EXCLUSIVE。并没有看到什么其他有意义的信息。我们继续gdb跟踪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *(mdl_request-&gt;next_in_list)</span><br><span class="line">$3 = &#123;type = MDL_INTENTION_EXCLUSIVE, duration = MDL_TRANSACTION, next_in_list = 0x7f697002a388, prev_in_list = 0x7f697d1c3bd8, ticket = 0x0, key = &#123;m_length = 7, m_db_name_length = 4,</span><br><span class="line">    m_ptr = &quot;\001test\000\000\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217\217&quot;,</span><br><span class="line">static m_namespace_to_wait_state_name = &#123;</span><br><span class="line">&#123;m_key = 101,</span><br><span class="line">        m_name = 0xf125a2 &quot;Waiting for global read lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 102,</span><br><span class="line">m_name = 0xf125c0 &quot;Waiting for schema metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 103,</span><br><span class="line">        m_name = 0xf125e8 &quot;Waiting for table metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 104,</span><br><span class="line">m_name = 0xf12608 &quot;Waiting for stored function metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 105,</span><br><span class="line">        m_name = 0xf12638 &quot;Waiting for stored procedure metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 106,</span><br><span class="line">m_name = 0xf12668 &quot;Waiting for trigger metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 107,</span><br><span class="line">        m_name = 0xf12690 &quot;Waiting for event metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 108,</span><br><span class="line">m_name = 0xf126b0 &quot;Waiting for commit lock&quot;, m_flags = 0&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>从上面的输出中，我们看到了需要在test（见输出中的 m_ptr = “\001test）数据库上加一把事务级的MDL_INTENTION_EXCLUSIVE锁。它并没有告诉我们最终的MDL会落在哪个对象上。我们继续跟踪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$4 = &#123;type = MDL_SHARED_UPGRADABLE, duration = MDL_TRANSACTION, next_in_list = 0x0, prev_in_list = 0x7f697002a568, ticket = 0x0, key = &#123;m_length = 9, m_db_name_length = 4,</span><br><span class="line">    m_ptr = &quot;\002test\000ti&quot;, &#x27;\000&#x27; &lt;repeats 378 times&gt;,</span><br><span class="line">static m_namespace_to_wait_state_name = &#123;</span><br><span class="line">&#123;m_key = 101,</span><br><span class="line">m_name = 0xf125a2 &quot;Waiting for global read lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 102,</span><br><span class="line">m_name = 0xf125c0 &quot;Waiting for schema metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 103,</span><br><span class="line">m_name = 0xf125e8 &quot;Waiting for table metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 104,</span><br><span class="line">        m_name = 0xf12608 &quot;Waiting for stored function metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 105,</span><br><span class="line">m_name = 0xf12638 &quot;Waiting for stored procedure metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 106,</span><br><span class="line">        m_name = 0xf12668 &quot;Waiting for trigger metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 107,</span><br><span class="line">m_name = 0xf12690 &quot;Waiting for event metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 108,</span><br><span class="line">        m_name = 0xf126b0 &quot;Waiting for commit lock&quot;, m_flags = 0&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>从上面的输出中，我们可以看出最终是要在test数据库的ti对象上加一把MDL_SHARED_UPGRADABLE锁。在做DDL时会先加MDL_SHARED_UPGRADABLE锁，然后升级到MDL_EXCLUSIVE锁</p><p>我来执行下面的过程 会话1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (5.51 sec)</span><br></pre></td></tr></table></figure><p>会话2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *mdl_request</span><br><span class="line">$5 = &#123;type = MDL_EXCLUSIVE, duration = MDL_TRANSACTION, next_in_list = 0x20302000000, prev_in_list = 0x200000001, ticket = 0x0, key = &#123;m_length = 9, m_db_name_length = 4,</span><br><span class="line">    m_ptr = &quot;\002test\000ti\000\000\000\000@\031\220\003\000\000\000\000\333\361\254\000\000\000\000\000\260&lt;\034&#125;i\177\000\000\302\362\254\000\000\000\000\000\300&lt;\034&#125;i\177\000\000\060|\002pi\177\000\000\320&lt;\034&#125;i\177\000\000\360\236\344\000\000\000\000\000\000\t\000pi\177\000\000(&#125;\002pi\177\000\000\360&lt;\034&#125;i\177\000\000\234\312\344\000\000\000\000\000H\245\002pi\177\000\000\333\361\254\000\000\000\000\000\023\360\000\001&quot;, &#x27;\000&#x27; &lt;repeats 12 times&gt;, &quot;`S\005pi\177\000\000\060|\002p\000\000\001\000\060=\034&#125;i\177\000\000&gt;\240\344\000\000\000\000\000\000\t\000pi\177\000\000\000\t\000pi\177\000\000\200=\034&#125;i\177\000\000\231\310\344\000\000\000\000\000\240=\034&#125;i\177\000\000l-d0t\b\000\000H\344\000\001\000\000\000\000\023\360\000\001\000\000\000\000\226&quot;...,</span><br><span class="line">static m_namespace_to_wait_state_name = &#123;</span><br><span class="line">&#123;m_key = 101,</span><br><span class="line">m_name = 0xf125a2 &quot;Waiting for global read lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 102,</span><br><span class="line">m_name = 0xf125c0 &quot;Waiting for schema metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 103,</span><br><span class="line">        m_name = 0xf125e8 &quot;Waiting for table metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 104,</span><br><span class="line">m_name = 0xf12608 &quot;Waiting for stored function metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 105,</span><br><span class="line">        m_name = 0xf12638 &quot;Waiting for stored procedure metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 106,</span><br><span class="line">m_name = 0xf12668 &quot;Waiting for trigger metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 107,</span><br><span class="line">        m_name = 0xf12690 &quot;Waiting for event metadata lock&quot;, m_flags = 0&#125;,</span><br><span class="line">&#123;m_key = 108,</span><br><span class="line">m_name = 0xf126b0 &quot;Waiting for commit lock&quot;, m_flags = 0&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>从上面的输出中，我们看到了最终是在test.ti上申请了事务级别的MDL_EXCLUSIVE锁。</p><p>会话3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> ti stats_auto_recalc<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">22</span> min <span class="number">58.99</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2><p>本例只是简单的演示了，在同一个事务的不同时期加的不同的MDL的锁。MYSQL中DDL的操作不属于事务操作的范围。这就给mysql主备基于语句级别同步带来了困难。mysql主备在同步的过程中，为了保证主备结构一致性，而引入了MDL机制。为了尽可能的降低MDL带来的影响。请在业务低谷的时候，执行DDL操作。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/trace-metadata-lock-procedure-using-gdb/">http://xnerv.wang/trace-metadata-lock-procedure-using-gdb/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2017/09/06/">利用gdb跟踪MDL加锁过程</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MDL-Meta-Data-LocK-的作用&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MDL-Meta-Data-LocK-的作用&quot;&gt;&lt;/a&gt;MDL(Meta Data LocK)的作用&lt;/h2&gt;
&lt;p&gt;在MySQL5.1及之前的版本中，如果有未提交的事务trx，当执行DROP/RENAME/ALTER TABLE RENAME操作时，不会被其他事务阻塞住。这会导致如下问题(MySQL bug#989)&lt;/p&gt;
&lt;p&gt;master： 未提交的事务，但SQL已经完成(binlog也准备好了)，表schema发生更改，在commit的时候不会被察觉到.&lt;/p&gt;
&lt;p&gt;slave： 在binlog里是以事务提交顺序记录的，DDL隐式提交，因此在备库先执行DDL，后执行事务trx，由于trx作用的表已经发生了改变，因此trx会执行失败。 在DDL时的主库DML压力越大，这个问题触发的可能性就越高&lt;/p&gt;
&lt;p&gt;在5.5引入了MDL（meta data lock）锁来解决在这个问题&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="MDL" scheme="https://xnerv.wang/tags/MDL/"/>
    
    <category term="gdb" scheme="https://xnerv.wang/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 跟踪Metadata lock（转载）</title>
    <link href="https://xnerv.wang/trace-metadata-lock/"/>
    <id>https://xnerv.wang/trace-metadata-lock/</id>
    <published>2018-03-22T02:32:00.000Z</published>
    <updated>2023-08-21T02:40:00.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><p>MySQL 从5.5.3版本，对Metadata lock进行了调整，主要是MDL锁持有的周期从语句变成了事务， 其原因主要是解决两个问题：</p><p><strong>问题1: 破坏事务隔离级别</strong> 在repeatable read的隔离级别下，多次的select语句执行过程中，会因为其它session的DDL语句，而导致select语句执行的结果不相同，破坏了RR的隔离级别。</p><p><strong>问题2: 破坏binlog的顺序</strong> 在对表的DML过程中，会因为其它session的DDL语句，导致binlog里的event顺序在备库执行的结果和主库不一致。</p><p>从MySQL 5.5.3开始，MDL锁的持有周期变成了事务，解决了上面提到的两个问题，但在autocommit=off的情况下，也大大增加了阻塞的可能性。DBA对于阻塞的case，处理起来又比较麻烦，原因就是MDL锁的阻塞情况没有暴露明确的信息。</p><p>从MySQL 5.7.6开始，可以通过performance schema来查询MDL锁的持有情况。</p><p>在开始介绍5.7的跟踪Metadata lock之前， 小编还想讨论一下前面提到的这两个问题，在Oracle数据库中是如何处理的。</p><span id="more"></span><h2 id="Oracle的处理方式"><a class="header-anchor" href="#Oracle的处理方式"></a>Oracle的处理方式</h2><p>首先，Oracle只实现了两种隔离级别，即read committed和serializable，我们来看下serializable级别下，怎么来处理问题1:</p><p>先看如下的case:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">session <span class="number">1</span>:                                                 session <span class="number">2</span>:</span><br><span class="line"><span class="comment">--                                                         create table t1(id number);</span></span><br><span class="line"><span class="comment">--                                                         insert into t1 values(1);</span></span><br><span class="line"><span class="comment">--                                                         commit;</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;              <span class="comment">--</span></span><br><span class="line">TEST<span class="operator">/</span>TEST<span class="variable">@ORCL</span><span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;                           <span class="comment">--</span></span><br><span class="line">        ID</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">         <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> selected.</span><br><span class="line"><span class="comment">--                                                         alter table t1 add col number;</span></span><br><span class="line">TEST<span class="operator">/</span>TEST<span class="variable">@ORCL</span><span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;                           <span class="comment">--</span></span><br><span class="line"></span><br><span class="line">        ID        COL</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         <span class="number">1</span></span><br><span class="line"><span class="comment">--                                                         alter table t1 add col1 number default 10;</span></span><br><span class="line">TEST<span class="operator">/</span>TEST<span class="variable">@ORCL</span><span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;                           <span class="comment">--</span></span><br><span class="line">        ID        COL       COL1</span><br><span class="line"><span class="comment">---------- ---------- ----------</span></span><br><span class="line">         <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，虽然session是serializable隔离级别，但并没有产生阻塞的情况，Oracle保证了session1的多次select查询的返回结果是一样的， 但t1表数据字典的变化是马上可见的，这个也是符合serializable的要求的，因为隔离级别只定义了数据的可见性，而没有定义数据字典的可见性。</p><p>那MySQL能否不要MDL锁，来达到这样的效果？</p><p>答案是否定的，因为Oracle是堆表，alter的操作只更改了数据字典，数据记录没有发生变化，纵使加了default值，也是在原记录上进行的update，完全可以使用scn号来构建一致性读版本，这样就不会产生阻塞。 而MySQL是IOT表，alter的过程进行了表重建，无法完成read view的构建。</p><p>那我们再来看问题2，Oracle的处理方式:</p><p>对于redo日志，Oracle的处理方式和InnoDB的处理方式一致，也就是当使用redo的时候，日志的写入并不和事务的提交与否有必然的关系，也不用和提交的顺序保持一致。这一点就和binlog区别开来，也就是物理日志是可以避免使用逻辑日志(binlog)带来的问题。</p><p>MySQL如果要避免这两个问题，而不引入Metadata lock，可以有以下两个思路：</p><ol><li>DDL只更改数据字典，行记录的变更在原记录上进行，这样能够实现多版本，也就是我们常说的在线加字段；</li><li>使用物理redo日志，避免使用binlog。</li></ol><p>这两种都会对现有的MySQL架构带来调整，仅供参考。</p><p>下面我们回来看下对5.7 MDL的tracing。</p><h2 id="MySQL-5-7"><a class="header-anchor" href="#MySQL-5-7"></a>MySQL 5.7</h2><p>首先，打开metadata locks的tracing功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> performance_schema.setup_consumers <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;global_instrumentation&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span> Changed: <span class="number">0</span> Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> performance_schema.setup_instruments <span class="keyword">SET</span> ENABLED <span class="operator">=</span> <span class="string">&#x27;YES&#x27;</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;wait/lock/metadata/sql/mdl&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span> Changed: <span class="number">0</span> Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>打开两个session，一个select，一个truncate。因为MDL锁的情况，select会阻塞truncate的操作。</p><p>session 1: 操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@autocommit</span>, @<span class="variable">@tx_isolation</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@autocommit</span> <span class="operator">|</span> @<span class="variable">@tx_isolation</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> READ<span class="operator">-</span>COMMITTED <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> val <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>session 2: 操作如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure><p>结果看到的就是session2被阻塞， 接下来check一下performance schema的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.metadata_locks\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1</span>\. <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">OBJECT_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">OBJECT_SCHEMA: test</span><br><span class="line">OBJECT_NAME: t</span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140450128308592</span></span><br><span class="line">LOCK_TYPE: SHARED_READ</span><br><span class="line">LOCK_DURATION: TRANSACTION</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">SOURCE: sql_parse.cc:<span class="number">5585</span></span><br><span class="line">OWNER_THREAD_ID: <span class="number">27</span></span><br><span class="line">OWNER_EVENT_ID: <span class="number">17</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2</span>\. <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">OBJECT_TYPE: <span class="keyword">GLOBAL</span></span><br><span class="line">OBJECT_SCHEMA: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140450195436144</span></span><br><span class="line">LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">LOCK_DURATION: STATEMENT</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">SOURCE: sql_base.cc:<span class="number">5224</span></span><br><span class="line">OWNER_THREAD_ID: <span class="number">30</span></span><br><span class="line">OWNER_EVENT_ID: <span class="number">8</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3</span>\. <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">OBJECT_TYPE: SCHEMA</span><br><span class="line">OBJECT_SCHEMA: test</span><br><span class="line">OBJECT_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140450195434272</span></span><br><span class="line">LOCK_TYPE: INTENTION_EXCLUSIVE</span><br><span class="line">LOCK_DURATION: TRANSACTION</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">SOURCE: sql_base.cc:<span class="number">5209</span></span><br><span class="line">OWNER_THREAD_ID: <span class="number">30</span></span><br><span class="line">OWNER_EVENT_ID: <span class="number">8</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4</span>\. <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">OBJECT_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">OBJECT_SCHEMA: test</span><br><span class="line">OBJECT_NAME: t</span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140450195434368</span></span><br><span class="line">LOCK_TYPE: EXCLUSIVE</span><br><span class="line">LOCK_DURATION: TRANSACTION</span><br><span class="line">LOCK_STATUS: PENDING</span><br><span class="line">SOURCE: sql_parse.cc:<span class="number">5585</span></span><br><span class="line">OWNER_THREAD_ID: <span class="number">30</span></span><br><span class="line">OWNER_EVENT_ID: <span class="number">8</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">5</span>\. <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">OBJECT_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">OBJECT_SCHEMA: performance_schema</span><br><span class="line">OBJECT_NAME: metadata_locks</span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">140450128262384</span></span><br><span class="line">LOCK_TYPE: SHARED_READ</span><br><span class="line">LOCK_DURATION: TRANSACTION</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">SOURCE: sql_parse.cc:<span class="number">5585</span></span><br><span class="line">OWNER_THREAD_ID: <span class="number">27</span></span><br><span class="line">OWNER_EVENT_ID: <span class="number">18</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如上所示，在t表上，持有一个SHARE_READ lock，而且还有一个EXCULSIVE lock请求是pending状态，也就是我们被阻塞的session 2。</p><p>在5.7之前，我们可以通过show processlist，来查看MDL阻塞的情况，但无法获取session 1的信息:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, LOCK_STATUS, THREAD_ID, PROCESSLIST_ID, PROCESSLIST_INFO <span class="keyword">FROM</span> performance_schema.metadata_locks <span class="keyword">INNER</span> <span class="keyword">JOIN</span> performance_schema.threads <span class="keyword">ON</span> THREAD_ID <span class="operator">=</span> OWNER_THREAD_ID <span class="keyword">WHERE</span> PROCESSLIST_ID <span class="operator">&lt;&gt;</span> CONNECTION_ID();</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+-------------+---------------------+-------------+-----------+----------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> OBJECT_TYPE <span class="operator">|</span> OBJECT_SCHEMA <span class="operator">|</span> OBJECT_NAME <span class="operator">|</span> LOCK_TYPE <span class="operator">|</span> LOCK_STATUS <span class="operator">|</span> THREAD_ID <span class="operator">|</span> PROCESSLIST_ID <span class="operator">|</span> PROCESSLIST_INFO <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+-------------+---------------------+-------------+-----------+----------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GLOBAL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> GRANTED <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> <span class="keyword">truncate</span> <span class="keyword">table</span> t <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> SCHEMA <span class="operator">|</span> test <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> INTENTION_EXCLUSIVE <span class="operator">|</span> GRANTED <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> <span class="keyword">truncate</span> <span class="keyword">table</span> t <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">TABLE</span> <span class="operator">|</span> test <span class="operator">|</span> t <span class="operator">|</span> EXCLUSIVE <span class="operator">|</span> PENDING <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> <span class="keyword">truncate</span> <span class="keyword">table</span> t <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+-------------+---------------------+-------------+-----------+----------------+------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+------+---------+------+---------------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> Host <span class="operator">|</span> db <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State <span class="operator">|</span> Info <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+------+---------+------+---------------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> test <span class="operator">|</span> Query <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span> starting <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> root <span class="operator">|</span> localhost <span class="operator">|</span> test <span class="operator">|</span> Query <span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> Waiting <span class="keyword">for</span> <span class="keyword">table</span> metadata lock <span class="operator">|</span> <span class="keyword">truncate</span> <span class="keyword">table</span> t <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----------+------+---------+------+---------------------------------+------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>接下来当事务提交了后，释放MDL锁再查询，就看不到MDL锁的信息了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, LOCK_STATUS, THREAD_ID, PROCESSLIST_ID, PROCESSLIST_INFO <span class="keyword">FROM</span> performance_schema.metadata_locks <span class="keyword">INNER</span> <span class="keyword">JOIN</span> performance_schema.threads <span class="keyword">ON</span> THREAD_ID <span class="operator">=</span> OWNER_THREAD_ID <span class="keyword">WHERE</span> PROCESSLIST_ID <span class="operator">&lt;&gt;</span> CONNECTION_ID();</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>MySQL 5.7可以通过performance schema来检索MDL锁阻塞情况，方便DBA来诊断问题。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/trace-metadata-lock/">http://xnerv.wang/trace-metadata-lock/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2015/10/02/">跟踪Metadata lock</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;MySQL 从5.5.3版本，对Metadata lock进行了调整，主要是MDL锁持有的周期从语句变成了事务， 其原因主要是解决两个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题1: 破坏事务隔离级别&lt;/strong&gt; 在repeatable read的隔离级别下，多次的select语句执行过程中，会因为其它session的DDL语句，而导致select语句执行的结果不相同，破坏了RR的隔离级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题2: 破坏binlog的顺序&lt;/strong&gt; 在对表的DML过程中，会因为其它session的DDL语句，导致binlog里的event顺序在备库执行的结果和主库不一致。&lt;/p&gt;
&lt;p&gt;从MySQL 5.5.3开始，MDL锁的持有周期变成了事务，解决了上面提到的两个问题，但在autocommit=off的情况下，也大大增加了阻塞的可能性。DBA对于阻塞的case，处理起来又比较麻烦，原因就是MDL锁的阻塞情况没有暴露明确的信息。&lt;/p&gt;
&lt;p&gt;从MySQL 5.7.6开始，可以通过performance schema来查询MDL锁的持有情况。&lt;/p&gt;
&lt;p&gt;在开始介绍5.7的跟踪Metadata lock之前， 小编还想讨论一下前面提到的这两个问题，在Oracle数据库中是如何处理的。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="MDL" scheme="https://xnerv.wang/tags/MDL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - InnoDB mini transation（转载）</title>
    <link href="https://xnerv.wang/what-innodb-mini-transation/"/>
    <id>https://xnerv.wang/what-innodb-mini-transation/</id>
    <published>2018-03-17T23:42:00.000Z</published>
    <updated>2023-08-21T02:40:00.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>InnoDB有两个非常重要的日志，undo log 和 redo log；通过undo log可以看到数据较早版本，实现MVCC，或回滚事务等功能；redo log用来保证事务持久性</p><p>本文以一条insert语句为线索介绍 mini transaction</p><h2 id="mini-transaction-简介"><a class="header-anchor" href="#mini-transaction-简介"></a>mini transaction 简介</h2><p>mini transation 主要用于innodb redo log 和 undo log写入，保证两种日志的ACID特性</p><p>mini-transaction遵循以下三个协议:</p><ol><li><p>The FIX Rules</p></li><li><p>Write-Ahead Log</p></li><li><p>Force-log-at-commit</p></li></ol><span id="more"></span><h4 id="The-FIX-Rules"><a class="header-anchor" href="#The-FIX-Rules"></a>The FIX Rules</h4><p>修改一个页需要获得该页的x-latch</p><p>访问一个页是需要获得该页的s-latch或者x-latch</p><p>持有该页的latch直到修改或者访问该页的操作完成</p><h4 id="Write-Ahead-Log"><a class="header-anchor" href="#Write-Ahead-Log"></a>Write-Ahead Log</h4><p>持久化一个数据页之前，必须先将内存中相应的日志页持久化</p><p>每个页有一个LSN,每次页修改需要维护这个LSN,当一个页需要写入到持久化设备时，要求内存中小于该页LSN的日志先写入到持久化设备中</p><h4 id="Force-log-at-commit"><a class="header-anchor" href="#Force-log-at-commit"></a>Force-log-at-commit</h4><p>一个事务可以同时修改了多个页，Write-AheadLog单个数据页的一致性，无法保证事务的持久性</p><p>Force -log-at-commit要求当一个事务提交时，其产生所有的mini-transaction日志必须刷到持久设备中</p><p>这样即使在页数据刷盘的时候宕机，也可以通过日志进行redo恢复</p><h4 id="代码简介"><a class="header-anchor" href="#代码简介"></a>代码简介</h4><p>本文使用 MySQL 5.6.16 版本进行分析</p><p>mini transation 相关代码路径位于 storage/innobase/mtr/ 主要有 <a href="http://mtr0mtr.cc">mtr0mtr.cc</a> 和 <a href="http://mtr0log.cc">mtr0log.cc</a> 两个文件</p><p>另有部分代码在 storage/innobase/include/ 文件名以 mtr0 开头</p><p>mini transaction 的信息保存在结构体 mtr_t 中，结构体成员描述如下</p><table><thead><tr><th>成员属性</th><th>描述</th></tr></thead><tbody><tr><td>state</td><td>mini transaction所处状态 MTR_ACTIVE, MTR_COMMITTING, MTR_COMMITTED</td></tr><tr><td>memo</td><td>mtr 持有锁的栈</td></tr><tr><td>log</td><td>mtr产生的日志</td></tr><tr><td>inside_ibuf</td><td>insert buffer 是否修改</td></tr><tr><td>modifications</td><td>是否修改buffer pool pages</td></tr><tr><td>made_dirty</td><td>是否产生buffer pool脏页</td></tr><tr><td>n_log_recs</td><td>log 记录数</td></tr><tr><td>n_freed_pages</td><td>释放page数</td></tr><tr><td>log_mode</td><td>日志模式，默认MTR_LOG_ALL</td></tr><tr><td>start_lsn</td><td>lsn 起始值</td></tr><tr><td>end_lsn</td><td>lsn 结束值</td></tr><tr><td>magic_n</td><td>魔术字</td></tr></tbody></table><p>一个 mini transaction 从 mtr_start(mtr)开始，到 mtr_commit(mtr)结束</p><h2 id="一条insert语句涉及的-mini-transaction"><a class="header-anchor" href="#一条insert语句涉及的-mini-transaction"></a>一条insert语句涉及的 mini transaction</h2><p>下面涉及 mtr 的嵌套，在代码中，每个 mtr_t 对象变量名都叫 mtr，本文中为了区分不同 mtr，给不同的对象加编号</p><p>下面一般省略 mtr_t 以外的参数</p><p>第一个 mtr 从 row_ins_clust_index_entry_low 开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">mtr_start(mtr_1) // mtr_1 贯穿整条insert语句</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_s_lock(dict_index_get_lock(index), mtr_1) // 对index加s锁</span><br><span class="line">btr_cur_search_to_nth_level</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_1) // buffer RW_NO_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">btr_cur_search_to_nth_level</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_1) // page RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">btr_block_get_func</span><br><span class="line">btr_cur_latch_leaves</span><br><span class="line">btr_cur_search_to_nth_level</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_start(mtr_2) // mtr_2 用于记录 undo log</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_start(mtr_3) // mtr_3 分配或复用一个 undo log</span><br><span class="line">trx_undo_assign_undo</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_3) // 对复用（也可能是分配）的 undo log page 加 RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">trx_undo_page_get</span><br><span class="line">trx_undo_reuse_cached // 这里先尝试复用，如果复用失败，则分配新的 undo log</span><br><span class="line">trx_undo_assign_undo</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line"></span><br><span class="line"> trx_undo_insert_header_reuse(mtr_3) // 写 undo log header</span><br><span class="line">trx_undo_reuse_cached</span><br><span class="line">trx_undo_assign_undo</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line"></span><br><span class="line">trx_undo_header_add_space_for_xid(mtr_3) // 在 undo header 中预留 XID 空间</span><br><span class="line">trx_undo_reuse_cached</span><br><span class="line">trx_undo_assign_undo</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line"></span><br><span class="line">mtr_commit(mtr_3) // 提交 mtr_3</span><br><span class="line">trx_undo_assign_undo</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_2) // 即将写入的 undo log page 加 RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">trx_undo_page_report_insert(mtr_2) // undo log 记录 insert 操作</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">mtr_commit(mtr_2) // 提交 mtr_2</span><br><span class="line">trx_undo_report_row_operation</span><br><span class="line">btr_cur_ins_lock_and_undo</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line">row_ins_clust_index_entry_low</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">mtr_2 提交后开始执行 insert 操作</span><br><span class="line">page_cur_insert_rec_low 具体执行 insert 操作</span><br><span class="line">在该函数末尾调用 page_cur_insert_rec_write_log 写 redo log</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">page_cur_insert_rec_write_log(mtr_1) // insert 操作写 redo log</span><br><span class="line">page_cur_insert_rec_lowpage_cur_tuple_insert</span><br><span class="line">btr_cur_optimistic_insert</span><br><span class="line"></span><br><span class="line">mtr_commit(mtr_1) // 提交 mtr_1</span><br><span class="line">row_ins_clust_index_entry_low</span><br></pre></td></tr></table></figure><p>至此 insert 语句执行结束后</p><p>一条 insert 是一个单语句事务，事务提交时也会涉及 mini transaction</p><p>提交事务时，第一个 mtr 从 trx_prepare 开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">mtr_start(mtr_4) // mtr_4 用于 prepare transaction</span><br><span class="line">trx_prepare</span><br><span class="line">trx_prepare_for_mysql</span><br><span class="line">innobase_xa_prepare</span><br><span class="line">ha_prepare_low</span><br><span class="line">MYSQL_BIN_LOG::prepare</span><br><span class="line">ha_commit_trans</span><br><span class="line">trans_commit_stmt</span><br><span class="line">mysql_execute_command</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_4) // undo page 加 RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">trx_undo_page_get</span><br><span class="line">trx_undo_set_state_at_prepare</span><br><span class="line">trx_prepare</span><br><span class="line"></span><br><span class="line">mlog_write_ulint(seg_hdr + TRX_UNDO_STATE, undo-&gt;state, MLOG_2BYTES, mtr_4) 写入TRX_UNDO_STATE</span><br><span class="line">trx_undo_set_state_at_prepare</span><br><span class="line">trx_prepare</span><br><span class="line"></span><br><span class="line">mlog_write_ulint(undo_header + TRX_UNDO_XID_EXISTS, TRUE, MLOG_1BYTE, mtr_4) 写入 TRX_UNDO_XID_EXISTS</span><br><span class="line">trx_undo_set_state_at_prepare</span><br><span class="line">trx_prepare</span><br><span class="line"></span><br><span class="line">trx_undo_write_xid(undo_header, &amp;undo-&gt;xid, mtr_4) undo 写入 xid</span><br><span class="line">trx_undo_set_state_at_prepare</span><br><span class="line">trx_prepare</span><br><span class="line"></span><br><span class="line">mtr_commit(mtr_4) // 提交 mtr_4</span><br><span class="line">trx_prepare</span><br><span class="line"></span><br><span class="line">mtr_start(mtr_5) // mtr_5 用于 commit transaction</span><br><span class="line">trx_commit</span><br><span class="line">trx_commit_for_mysql</span><br><span class="line">innobase_commit_low</span><br><span class="line">innobase_commit</span><br><span class="line">ha_commit_low</span><br><span class="line">MYSQL_BIN_LOG::process_commit_stage_queue</span><br><span class="line">MYSQL_BIN_LOG::ordered_commit</span><br><span class="line">MYSQL_BIN_LOG::commit</span><br><span class="line">ha_commit_trans</span><br><span class="line">trans_commit_stmt</span><br><span class="line">mysql_execute_command</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_5) // undo page 加 RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">trx_undo_page_get</span><br><span class="line">trx_undo_set_state_at_finish</span><br><span class="line">trx_write_serialisation_history</span><br><span class="line">trx_commit_low</span><br><span class="line">trx_commit</span><br><span class="line"></span><br><span class="line">trx_undo_set_state_at_finish(mtr_5) // set undo state， 这里是 TRX_UNDO_CACHED</span><br><span class="line">trx_write_serialisation_history</span><br><span class="line">trx_commit_low</span><br><span class="line">trx_commit</span><br><span class="line"></span><br><span class="line">mtr_memo_push(mtr_5) // 系统表空间 transaction system header page 加 RW_X_LATCH 入栈</span><br><span class="line">buf_page_get_gen</span><br><span class="line">trx_sysf_get</span><br><span class="line">trx_sys_update_mysql_binlog_offset</span><br><span class="line">trx_write_serialisation_history</span><br><span class="line">trx_commit_low</span><br><span class="line">trx_commit</span><br><span class="line"></span><br><span class="line">trx_sys_update_mysql_binlog_offset // 更新偏移量信息到系统表空间</span><br><span class="line">trx_write_serialisation_history</span><br><span class="line">trx_commit_low</span><br><span class="line">trx_commit</span><br><span class="line"></span><br><span class="line">mtr_commit(mtr_5) // 提交 mtr_5</span><br><span class="line">trx_commit_low</span><br><span class="line">trx_commit</span><br></pre></td></tr></table></figure><p>至此 insert 语句涉及的 mini transaction 全部结束</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>上面可以看到加锁、写日志到 mlog 等操作在 mini transaction 过程中进行</p><p>解锁、把日志刷盘等操作全部在 mtr_commit 中进行，和事务类似</p><p>mini transaction 没有回滚操作， 因为只有在 mtr_commit 才将修改落盘，如果宕机，内存丢失，无需回滚；如果落盘过程中宕机，崩溃恢复时可以看出落盘过程不完整，丢弃这部分修改</p><p>mtr_commit 主要包含以下步骤</p><ol><li>mlog 中日志刷盘</li><li>释放 mtr 持有的锁，锁信息保存在 memo 中，以栈形式保存，后加的锁先释放</li><li>清理 mtr 申请的内存空间，memo 和 log</li><li>mtr—&gt;state 设置为 MTR_COMMITTED</li></ol><p>上面的步骤 1. 中，日志刷盘策略和 innodb_flush_log_at_trx_commit 有关</p><ul><li>当设置该值为1时，每次事务提交都要做一次fsync，这是最安全的配置，即使宕机也不会丢失事务</li><li>当设置为2时，则在事务提交时只做write操作，只保证写到系统的page cache，因此实例crash不会丢失事务，但宕机则可能丢失事务</li><li>当设置为0时，事务提交不会触发redo写操作，而是留给后台线程每秒一次的刷盘操作，因此实例crash将最多丢失1秒钟内的事务</li></ul><hr><p><strong>本文地址：<a href="http://xnerv.wang/what-innodb-mini-transation/">http://xnerv.wang/what-innodb-mini-transation/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2017/10/03/">InnoDB mini transation</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;InnoDB有两个非常重要的日志，undo log 和 redo log；通过undo log可以看到数据较早版本，实现MVCC，或回滚事务等功能；redo log用来保证事务持久性&lt;/p&gt;
&lt;p&gt;本文以一条insert语句为线索介绍 mini transaction&lt;/p&gt;
&lt;h2 id=&quot;mini-transaction-简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#mini-transaction-简介&quot;&gt;&lt;/a&gt;mini transaction 简介&lt;/h2&gt;
&lt;p&gt;mini transation 主要用于innodb redo log 和 undo log写入，保证两种日志的ACID特性&lt;/p&gt;
&lt;p&gt;mini-transaction遵循以下三个协议:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FIX Rules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write-Ahead Log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Force-log-at-commit&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://xnerv.wang/tags/InnoDB/"/>
    
    <category term="MTR" scheme="https://xnerv.wang/tags/MTR/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 信号处理机制分析（转载）</title>
    <link href="https://xnerv.wang/what-analysis-of-signal-processing-mechanism/"/>
    <id>https://xnerv.wang/what-analysis-of-signal-processing-mechanism/</id>
    <published>2018-03-17T23:32:00.000Z</published>
    <updated>2023-08-21T02:40:00.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><p>在 <a href="https://github.com/alibaba/AliSQL/issues/68">AliSQL</a> 上面有人提交了一个 bug，在使用主备的时候 service stop mysql 不能关闭主库，一直显示 shutting down mysql …，到底怎么回事呢，先来看一下 service stop mysql 是怎么停止数据库的。配置 MySQL 在系统启动时启动需要把 MYSQL_BASEDIR/support-files 目录下的脚本 mysql.sever 放到 /etc/init.d/ 目录下，脚本来控制 mysqld 的启动和停止。看一下脚本中的代码 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if test -s &quot;$mysqld_pid_file_path&quot;</span><br><span class="line">     then</span><br><span class="line">       mysqld_pid=`cat &quot;$mysqld_pid_file_path&quot;`</span><br><span class="line"></span><br><span class="line">       if (kill -0 $mysqld_pid 2&gt;/dev/null)</span><br><span class="line">       then</span><br><span class="line">         echo $echo_n &quot;Shutting down MySQL&quot;</span><br><span class="line">         kill $mysqld_pid</span><br><span class="line">         # mysqld should remove the pid file when it exits, so wait for it.</span><br><span class="line">         wait_for_pid removed &quot;$mysqld_pid&quot; &quot;$mysqld_pid_file_path&quot;; return_value=$?</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>实际上的关闭动作就是向 mysqld 进程发送一个 kill pid 的信号，也就是 TERM ， wait_for_pid 函数中就是不断检测 $MYSQL_DATADIR 下面的 pid 文件是否存在，并且打印 ‘.’，所以上述问题应该是 mysqld 没有正确处理接收到的信号。</p><span id="more"></span><h2 id="信号处理机制"><a class="header-anchor" href="#信号处理机制"></a>信号处理机制</h2><h3 id="多线程信号处理"><a class="header-anchor" href="#多线程信号处理"></a>多线程信号处理</h3><p>进程中的信号处理是异步的，当信号发送给进程之后，就会中断进程当前的执行流程，跳到注册的对应信号处理函数中，执行完毕后再返回进程的执行流程。在多线程信号处理中，一般采用一个单独的线程阻塞的等待信号集，然后处理信号，重新阻塞等待。线程的信号处理有以下几个特点：</p><ul><li>每个线程都有自己的信号屏蔽字（单个线程可以屏蔽某些信号）</li><li>信号的处理是整个进程中所有线程共享的（某个线程修改信号处理行为后，也会影响其它线程）</li><li>进程中的信号是递送到单个线程的，如果一个信号和硬件故障相关，那么该信号就会被递送到引起该事件的线程，否是是发送到任意一个线程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> * restrict set, <span class="type">sigset_t</span> *restrict oset)</span></span>;</span><br></pre></td></tr></table></figure><p>在进程中使用 sigprocmask 设置信号屏蔽字，在线程中使用 pthread_sigmask，他们的基本相同，pthread_sigmask 工作在线程中，失败时返回错误码，而 sigprocmask 会设置 errno 并返回 -1。参数 how 控制设置屏蔽字的行为，值为 SIG_BLOCK（把信号集添加到现有信号集中，取并集）, SIG_SET_MASK（设置信号集为 set）, SIG_UNBLOCK（从信号集中移除 set 中的信号）。set 表示需要操纵的信号集合。oset 返回设置之前的信号屏蔽字，如果设置 set 为 NULL，可以通过 oset 获得当前的信号屏蔽字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> \*restrict set, <span class="type">int</span> \*restrict sig)</span></span></span><br></pre></td></tr></table></figure><p>sigwait 将会挂起调用线程，直到接收到 set 中设置的信号，具体的信号将会通过 sig 返回，同时会从 set 中删除 sig 信号。 在调用 sigwait 之前，必须阻塞那些它正在等待的信号，否则在调用的时间窗口就可能接收到信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span></span></span><br></pre></td></tr></table></figure><p>发送信号到指定线程，如果 sig 为 0，可以用来判断线程是否还活着。</p><p>man pthread_sigmask 里面给了一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Simple error handling functions */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error_en(en, msg) \</span></span><br><span class="line"><span class="meta">    do &#123; errno = en; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">sig_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> *set = (<span class="type">sigset_t</span> *) arg;</span><br><span class="line">    <span class="type">int</span> s, sig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        s = <span class="built_in">sigwait</span>(set, &amp;sig);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">handle_error_en</span>(s, <span class="string">&quot;sigwait&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Signal handling thread got signal %d\n&quot;</span>, sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">/* Block SIGINT; other threads created by main() will inherit</span></span><br><span class="line"><span class="comment">     *               a copy of the signal mask. */</span></span><br><span class="line">    <span class="comment">/* Block SIGINT; other threads created by main() will inherit</span></span><br><span class="line"><span class="comment">     *               a copy of the signal mask. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGQUIT);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGUSR1);</span><br><span class="line">    s = <span class="built_in">pthread_sigmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//s = sigprocmask(SIG_BLOCK, &amp;set, NULL);</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">handle_error_en</span>(s, <span class="string">&quot;pthread_sigmask&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, &amp;sig_thread, (<span class="type">void</span> *) &amp;set);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">handle_error_en</span>(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main thread carries on to create other threads and/or do</span></span><br><span class="line"><span class="comment">     *               other work */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pause</span>();            <span class="comment">/* Dummy pause so we can test program */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out &amp;</span><br><span class="line">[1] 5423</span><br><span class="line">$ <span class="built_in">kill</span> -QUIT %1</span><br><span class="line">Signal handling thread got signal 3</span><br><span class="line">$ <span class="built_in">kill</span> -USR1 %1</span><br><span class="line">Signal handling thread got signal 10</span><br><span class="line">$ <span class="built_in">kill</span> -TERM %1</span><br><span class="line">[1]+  Terminated              ./a.out</span><br></pre></td></tr></table></figure><p>测试了一下，把上面代码的 pthread_sigmask 替换成 sigprocmask ，同样能够正确执行，说明线程也能够继承原进程的屏蔽字，不过还是尽量使用 pthread_sigmask, 表述清楚点，而且说不定还有其它坑。</p><h3 id="MySQL-信号处理"><a class="header-anchor" href="#MySQL-信号处理"></a>MySQL 信号处理</h3><p>MySQL 是典型的多线程处理，它的信号处理形式和上一小节介绍的差不多，在 mysqld 启动的时候调用 my_init_signal 初始化信号屏蔽字，把需要信号处理线程处理的信号屏蔽起来，然后启动信号处理函数，入口是 signal_hand 。</p><p>在 my_init_signal 函数中，设置 SIGSEGC, SIGABORT, SIGBUS, SIGILL, SIGFPE 的处理函数为 handle_fatal_signal，把 SIGPIPE，SIGQUIT, SIGHUP, SIGTERM, SIGTSTP 加入到信号屏蔽字里，调用 sigprocmask 和 pthread_sigmask 设置屏蔽字。这一系列动作是在 mysql 启动其它辅助线程之前完成的动作，意图很明显，就是让之后的线程都继承设置的信号屏蔽字，把所有的信号交给信号处理线程去处理。</p><p>signal_hand 函数首先把需要处理的信号放到信号集合里去，然后完成 create_pid_file ，data 目录下的 pid 文件实际上是由信号处理线程创建的。接着等待 mysqld 完成启动，各个线程之间需要同步，核心代码是一个死循环，通过 my_sigwait 调用 sigwait 阻塞的等待信号的到来。我们目前主要关心 SIGTERM 的处理，和 SIGQUIT, SIGKILL 处理方式相同，都是调用 kill_server 关闭整个数据库。</p><h2 id="Bug-Fix"><a class="header-anchor" href="#Bug-Fix"></a>Bug Fix</h2><p>文中开头的链接中提到 loose-rpl_semi_sync_master_enabled = 0 关闭就不会有问题， 如果为 1 就会出现无法关闭的情况，顺着这个线索寻找，rpl_semi_sync_master_enabled 在主备使用 semisync 情况下控制启动 Master 节点的 Ack Receiver 线程，初始化阶段的调用堆栈为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init_common_variables</span><br><span class="line">|</span><br><span class="line">|----- ReplSemiSyncMaster::initObject</span><br><span class="line">|</span><br><span class="line">|----- Ack_receiver::start</span><br></pre></td></tr></table></figure><p>而 init_common_variables 的调用是在 my_init_signal 之前，也就是 Ack Receiver 线程没有办法继承信号屏蔽字，不会屏蔽 SIGTERM 信号。在 my_init_signal 中还有一段这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fix signals if blocked by parents (can happen on Mac OS X) */</span></span><br><span class="line">  ....</span><br><span class="line">  sa.sa_handler = print_signal_warning;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTERM, &amp;sa, (<span class="keyword">struct</span> sigaction\*) <span class="number">0</span>);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>对于信号的修改的作用于整个进程的，也就是说之前启动的 Ack Receiver 线程没有信号屏蔽字，而且注册了信号处理函数。当 SIGTERM 发生后，信号处理线程和 Ack Receiver 线程都可以接收信号处理，信号被随机的分发（测试高概率都是发给 Ack Receiver），print_signal_warning 仅仅打印信息到 errlog，就出现了无法关闭 mysqld 的情况了。</p><p>修改也比较简单，把 initObject 的操作放到 my_init_signal 之后就好，注意不能把 init_common_variables 整个移到 my_init_signal 之前，因为 my_init_signal 里面还有要初始化的变量呢。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/what-analysis-of-signal-processing-mechanism/">http://xnerv.wang/what-analysis-of-signal-processing-mechanism/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2017/10/10/">信号处理机制分析</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/alibaba/AliSQL/issues/68&quot;&gt;AliSQL&lt;/a&gt; 上面有人提交了一个 bug，在使用主备的时候 service stop mysql 不能关闭主库，一直显示 shutting down mysql …，到底怎么回事呢，先来看一下 service stop mysql 是怎么停止数据库的。配置 MySQL 在系统启动时启动需要把 MYSQL_BASEDIR/support-files 目录下的脚本 mysql.sever 放到 /etc/init.d/ 目录下，脚本来控制 mysqld 的启动和停止。看一下脚本中的代码 ：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if test -s &amp;quot;$mysqld_pid_file_path&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       mysqld_pid=`cat &amp;quot;$mysqld_pid_file_path&amp;quot;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       if (kill -0 $mysqld_pid 2&amp;gt;/dev/null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         echo $echo_n &amp;quot;Shutting down MySQL&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         kill $mysqld_pid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         # mysqld should remove the pid file when it exits, so wait for it.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         wait_for_pid removed &amp;quot;$mysqld_pid&amp;quot; &amp;quot;$mysqld_pid_file_path&amp;quot;; return_value=$?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上的关闭动作就是向 mysqld 进程发送一个 kill pid 的信号，也就是 TERM ， wait_for_pid 函数中就是不断检测 $MYSQL_DATADIR 下面的 pid 文件是否存在，并且打印 ‘.’，所以上述问题应该是 mysqld 没有正确处理接收到的信号。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="Signal" scheme="https://xnerv.wang/tags/Signal/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - InnoDB Adaptive hash index介绍（转载）</title>
    <link href="https://xnerv.wang/mysql-introduction-innodb-adaptive-hash-index/"/>
    <id>https://xnerv.wang/mysql-introduction-innodb-adaptive-hash-index/</id>
    <published>2018-03-17T23:26:00.000Z</published>
    <updated>2023-08-21T02:40:00.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>我们知道InnoDB的索引组织结构为Btree。通常情况下，我们需要根据查询条件，从根节点开始寻路到叶子节点，找到满足条件的记录。为了减少寻路开销，InnoDB本身做了几点优化。</p><p>首先，对于连续记录扫描，InnoDB在满足比较严格的条件时采用row cache的方式连续读取8条记录（并将记录格式转换成MySQL Format），存储在线程私有的<code>row_prebuilt_t::fetch_cache</code>中；这样一次寻路就可以获取多条记录，在server层处理完一条记录后，可以直接从cache中取数据而无需再次寻路，直到cache中数据取完，再进行下一轮。</p><p>另一种方式是，当一次进入InnoDB层获得数据后，在返回server层前，当前在btree上的cursor会被暂时存储到<code>row_prebuilt_t::pcur</code>中，当再次返回InnoDB层捞数据时，如果对应的Block没有发生任何修改，则可以继续沿用之前存储的cursor，无需重新定位。</p><p>上面这两种方式都是为了减少了重新寻路的次数，而对于一次寻路的开销，则使用Adaptive hash index来解决。AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。</p><span id="more"></span><p>本文代码分析基于MySQL 5.7.7-rc，描述的逻辑适用于5.7.7之前及5.6版本。但在即将发布的MySQL-5.7.8版本中， InnoDB根据索引id对AHI进行了分区处理，以此来降低btr_search_latch读写锁竞争，由于尚未发布，本文暂不覆盖相关内容。</p><p>我们以一个干净启动的实例作为起点，分析下如何进行AHI构建的过程。</p><h2 id="初始化"><a class="header-anchor" href="#初始化"></a>初始化</h2><p>AHI在内存中表现就是一个普通的哈希表对象，存储在<code>btr_search_sys_t::hash_index</code>中，对AHI的查删改操作都是通过一个全局读写锁<code>btr_search_latch</code>来保护。</p><p>在实例启动，完成buffer pool初始化后，会初始化AHI子系统相关对象，并分配AHI内存，大小为buffer pool的1/64。</p><p>参考函数：<code>btr_search_sys_create</code></p><p>Tips：MySQL 5.7已经开始支持InnoDB buffer pool的动态调整，其策略是buffer pool的大小改变超过1倍，就重新分配AHI Hash内存（<code>btr_search_sys_resize</code>）。</p><h2 id="触发AHI信息统计"><a class="header-anchor" href="#触发AHI信息统计"></a>触发AHI信息统计</h2><p>在系统刚启动时，索引对象上没有足够的信息来启发是否适合进行AHI缓存，因此开始有个信息搜集的阶段，在索引对象上维护了<code>dict_index_t::search_info</code>，类型为<code>btr_search_t</code>，用于跟踪当前索引使用AHI的关键信息。</p><p>在第一次执行SQL时，需要从btree的root节点开始，当寻址到匹配的叶子节点时，会走如下逻辑：</p><p>btr_cur_search_to_nth_level：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (btr_search_enabled &amp;&amp; !index-&gt;disable_ahi) &#123;</span><br><span class="line">        <span class="built_in">btr_search_info_update</span>(index, cursor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会判断脏读AHI开关（btr_search_enabled）是否打开，以及<code>index-&gt;diable_ahi</code>是否为false。第二个条件是MySQL5.7对临时表的优化，避免临时表操作对全局对象的影响，针对临时表不做AHI构建。</p><p>我们看看函数btr_search_info_update的逻辑：</p><ol><li>对<code>info-&gt;hash_analysis++</code>，当<code>info-&gt;hash_analysis</code>值超过<code>BTR_SEARCH_HASH_ANALYSIS</code>（17）时，也就是说对该索引寻路到叶子节点17次后，才会去做AHI分析（进入步骤2）</li><li>进入函数<code>btr_search_info_update_slow</code></li></ol><p>在连续执行17次对相同索引的操作后，满足<code>info-&gt;hash_analysis</code>大于等于<code>BTR_SEARCH_HASH_ANALYSIS</code>的条件，就会调用函数<code>btr_search_info_update_slow</code>来更新search_info，这主要是为了避免频繁的索引查询分析产生的过多CPU开销。</p><p>InnoDB通过索引条件构建一个可用于查询的tuple，而AHI需要根据tuple定位到叶子节点上记录的位置，既然AHI是构建在Btree索引上的索引，它的键值就是通过索引的前N列的值计算的来，所有的信息搜集统计都是为了确定一个合适的”Ｎ” ，这个值也是个动态的值，会跟随应用的负载自适应调整并触发block上的AHI重构建。</p><p><code>btr_search_info_update_slow</code>包含三个部分：更新索引查询信息、block上的查询信息以及为当前block构建AHI，下面几小节分别介绍。</p><h2 id="更新索引上的查询信息"><a class="header-anchor" href="#更新索引上的查询信息"></a>更新索引上的查询信息</h2><p>参考函数：<code>btr_search_info_update_hash</code></p><p>这里涉及到的几个search_info变量包括： <code>btr_search_t::n_hash_potential</code> 表示如果使用AHI构建索引，潜在的可能成功的次数； <code>btr_search_t::hash_analysis</code> 若设置了新的建议前缀索引模式，则重置为0，随后的17次查询分析可以忽略更新search_info。</p><p>下面两个字段表示推荐的前缀索引模式： <code>btr_search_t::n_fields</code> 推荐构建AHI的索引列数； <code>btr_search_t::left_side</code> 表示是否在相同索引前缀的最左索引记录构建AHI；值为true时，则对于相同前缀索引的记录，只存储最右的那个记录。 通过n_fields和left_side可以指导选择哪些列作为索引前缀来构建（fold, rec）哈希记录。如果用户的SQL的索引前缀列的个数大于等于构建AHI时的前缀索引，就可以用上AHI。</p><p>Tip1：在５.7之前的版本中，还支持索引中的字符串前缀作为构建AHI的键值的一部分，但上游认为带来的好处并不明显，因此将<code>btr_search_t::n_bytes</code> 移除了(参见commit <a href="https://github.com/mysql/mysql-server/commit/6f5f19b338543277a108a97710de8dd59b9dbb60" title="Bug#16852278 SIMPLIFY RECORD COMPARISONS">6f5f19b338543277a108a97710de8dd59b9dbb60</a>, <a href="https://github.com/mysql/mysql-server/commit/42499d9394bf103a27d63cd38b0c3c6bd738a7c7" title="Remove support for byte-level prefix granularity in searches.">42499d9394bf103a27d63cd38b0c3c6bd738a7c7</a>）。 Tip2：然而上游在测试中发现，如果把n_bytes移除，可能在诸如顺序插入这样的场景存在性能退化(参阅commit <a href="https://github.com/mysql/mysql-server/commit/00ec81a9efc1108376813f15935b52c451a268cf" title="Bug#21198396 REINTRODUCE ADAPTIVE HASH INDEX FIELD PREFIXES">00ec81a9efc1108376813f15935b52c451a268cf</a>)，因此在新发布的MySQL5.7.8版本中又重新引入，本文分析代码时统一基于MySQL5.7.7版本。</p><p>两种情况需要构建建议的前缀索引列：</p><ol><li>当前是第一次为该索引做AHI分析，<code>btr_search_t::n_hash_potential</code>值为0，需要构建建议的前缀索引列；</li><li>新的记录匹配模式发生了变化<code>(info-&gt;left_side == (info-&gt;n_fields &lt;=cursor-&gt;low_match))</code>，需要重新设置前缀索引列。</li></ol><p>相关代码段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cursor-&gt;up_match == cursor-&gt;low_match) &#123;</span><br><span class="line">        info-&gt;n_hash_potential = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For extra safety, we set some sensible values here */</span></span><br><span class="line"></span><br><span class="line">        info-&gt;n_fields = <span class="number">1</span>;</span><br><span class="line">        info-&gt;left_side = TRUE;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor-&gt;up_match &gt; cursor-&gt;low_match) &#123;</span><br><span class="line">        info-&gt;n_hash_potential = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cursor-&gt;up_match &gt;= n_unique) &#123;</span><br><span class="line">                info-&gt;n_fields = n_unique;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor-&gt;low_match &lt; cursor-&gt;up_match) &#123;</span><br><span class="line">                info-&gt;n_fields = cursor-&gt;low_match + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;n_fields = cursor-&gt;low_match;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info-&gt;left_side = TRUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        info-&gt;n_hash_potential = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cursor-&gt;low_match &gt;= n_unique) &#123;</span><br><span class="line"></span><br><span class="line">                info-&gt;n_fields = n_unique;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor-&gt;low_match &gt; cursor-&gt;up_match) &#123;</span><br><span class="line"></span><br><span class="line">                info-&gt;n_fields = cursor-&gt;up_match + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;n_fields = cursor-&gt;up_match;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info-&gt;left_side = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看到，在low_match和up_match之间，选择小一点match的索引列数的来进行设置，但不超过唯一确定索引记录值的列的个数：</p><ol><li>当low_match小于up_match时，left_side设置为true，表示相同前缀索引的记录只缓存最左记录；</li><li>当low_match大于up_match时，left_side设置为false，表示相同前缀索引的记录只缓存最右记录。</li></ol><p>如果不是第一次进入seach_info分析，有两种情况会递增<code>btr_search_t::n_hash_potential</code>：</p><ul><li><p>本次查询的up_match和当前推荐的前缀索引都能唯一决定一条索引记录(例如唯一索引)，则根据search_info推荐的前缀索引列构建AHI肯定能命中，递增 <code>info-&gt;n_hash_potential</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info-&gt;n_fields &gt;= n_unique &amp;&amp; cursor-&gt;up_match &gt;= n_unique) &#123;</span><br><span class="line">increment_potential:</span><br><span class="line">        info-&gt;n_hash_potential++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本次查询的tuple可以通过建议的前缀索引列构建的AHI定位到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info-&gt;left_side == (info-&gt;n_fields &lt;= cursor-&gt;up_match)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> increment_potential;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>很显然，如果对同一个索引的查询交替使用不同的查询模式，可能上次更新的search_info很快就会被重新设置，具有固定模式的索引查询将会受益于AHI索引。</p><h2 id="更新block上的查询信息"><a class="header-anchor" href="#更新block上的查询信息"></a>更新block上的查询信息</h2><p>参考函数：<code>btr_search_update_block_hash_info</code></p><p>更新数据页block上的查询信息，涉及到修改的变量包括：</p><p><code>btr_search_info::last_hash_succ</code> 最近一次成功(或可能成功)使用AHI； <code>buf_block_t::n_hash_helps</code> 计数值，如果使用当前推荐的前缀索引列构建AHI可能命中的次数，用于启发构建／重新构建数据页上的AHI记录项； <code>buf_block_t::n_fields</code> 推荐在block上构建AHI的前缀索引列数； <code>buf_block_t::left_side</code> 和search_info上对应字段含义相同。</p><p>函数主要流程包括：</p><ol><li><p>首先设置<code>btr_search_info::last_hash_succ</code> 为FALSE 这会导致在分析过程中无法使用AHI进行检索，感觉这里的设置不是很合理。这意味着每次分析一个新的block，都会导致AHI短暂不可用。</p></li><li><p>初始化或更新block上的查询信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((block-&gt;n_hash_helps &gt; <span class="number">0</span>)</span><br><span class="line">    &amp;&amp; (info-&gt;n_hash_potential &gt; <span class="number">0</span>)</span><br><span class="line">    &amp;&amp; (block-&gt;n_fields == info-&gt;n_fields)</span><br><span class="line">    &amp;&amp; (block-&gt;left_side == info-&gt;left_side)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((block-&gt;index)</span><br><span class="line">            &amp;&amp; (block-&gt;curr_n_fields == info-&gt;n_fields)</span><br><span class="line">            &amp;&amp; (block-&gt;curr_left_side == info-&gt;left_side)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The search would presumably have succeeded using</span></span><br><span class="line"><span class="comment">                the hash index */</span></span><br><span class="line"></span><br><span class="line">                info-&gt;last_hash_succ = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        block-&gt;n_hash_helps++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block-&gt;n_hash_helps = <span class="number">1</span>;</span><br><span class="line">        block-&gt;n_fields = info-&gt;n_fields;</span><br><span class="line">        block-&gt;left_side = info-&gt;left_side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当block第一次被touch到并进入该函数时，设置block上的建议索引列值；以后再进入时，如果和索引上的全局search_info相匹配，则递增<code>block-&gt;n_hash_helps</code>，启发后续的创建或重构建AHI。</p><p>如果当前数据页block上已经构建了AHI记录项，且<code>buf_block_t::curr_n_fields</code>等字段和<code>btr_search_info</code>上对应字段值相同时，则认为当前SQL如果使用AHI索引能够命中，因此将<code>btr_search_info::last_hash_succ</code>设置为true，下次再使用相同索引检索btree时就会尝试使用AHI。</p></li><li><p>在初始化或更新block上的变量后，需要判断是否为整个page构建AHI索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((block-&gt;n_hash_helps &gt; <span class="built_in">page_get_n_recs</span>(block-&gt;frame)</span><br><span class="line">     / BTR_SEARCH_PAGE_BUILD_LIMIT)</span><br><span class="line">    &amp;&amp; (info-&gt;n_hash_potential &gt;= BTR_SEARCH_BUILD_LIMIT)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!block-&gt;index)</span><br><span class="line">            || (block-&gt;n_hash_helps</span><br><span class="line">                &gt; <span class="number">2</span> * <span class="built_in">page_get_n_recs</span>(block-&gt;frame))</span><br><span class="line">            || (block-&gt;n_fields != block-&gt;curr_n_fields)</span><br><span class="line">            || (block-&gt;left_side != block-&gt;curr_left_side)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Build a new hash index on the page */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>(TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，当满足下面三个条件时，就会去为整个block上构建AHI记录项：</p><ul><li>分析使用AHI可以成功查询的次数(<code>buf_block_t::n_hash_helps</code>)超过block上记录数的16(<code>BTR_SEARCH_PAGE_BUILD_LIMIT</code>)分之一；</li><li><code>btr_search_info::n_hash_potential</code>大于等于<code>BTR_SEARCH_BUILD_LIMIT</code> (100)，表示连续100次潜在的成功使用AHI可能性；</li><li>尚未为当前block构造过索引、或者当前block上已经构建了AHI索引且<code>block-&gt;n_hash_helps</code>大于page上记录数的两倍、或者当前block上推荐的前缀索引列发生了变化 。</li></ul></li></ol><h2 id="为数据页构建AHI索引"><a class="header-anchor" href="#为数据页构建AHI索引"></a>为数据页构建AHI索引</h2><p>如果在上一阶段判断认为可以为当前page构建AHI索引（函数<code>btr_search_update_block_hash_info</code>返回值为TRUE），则根据当前推荐的索引前缀进行AHI构建。</p><p>参考函数：<code>btr_search_build_page_hash_index</code></p><p>分为三个阶段：</p><ol><li><p><strong>检查阶段</strong>：加btr_search_latch的S锁，判断AHI开关是否打开；如果block上已经构建了老的AHI但前缀索引列和当前推荐的不同，则清空Block对应的AHI记录项（<code>btr_search_drop_page_hash_index</code>）；检查n_fields和page上的记录数；然后释放btr_search_latch的S锁；</p></li><li><p><strong>搜集阶段</strong>：根据推荐的索引列数计算记录fold值，将对应的数据页记录内存地址到数组里；</p><p>根据left_mode值，相同的前缀索引列值会有不同的行为，举个简单的例子，假设page上记录为 (2,1), (2,2), (5, 3), (5, 4), (7, 5), (8, 6)，n_fields＝１</p><ul><li>若left_most为true，则hash存储的记录为(2,1) , (5, 3), (7, 5), (8,6)</li><li>若left_most为false，则hash存储的记录为(2, 2), (5, 4), (7,5), (8, 6)</li></ul></li><li><p><strong>插入阶段</strong>：加btr_search_latch的X锁，将第二阶段搜集的(fold, rec)插入到AHI中，并更新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!block-&gt;index) &#123;</span><br><span class="line">        index-&gt;search_info-&gt;ref_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block-&gt;n_hash_helps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">block-&gt;curr_n_fields = n_fields;</span><br><span class="line">block-&gt;curr_left_side = left_side;</span><br><span class="line">block-&gt;index = index;</span><br></pre></td></tr></table></figure></li></ol><p>PS：由于第二阶段释放了btr_search_latch锁，这里还得判断block上的AHI信息是否发生了变化，如果block上已经构建了AHI且block-&gt;curr_*几个变量和当前尝试构建的检索模式不同，则放弃本次构建。</p><h2 id="使用AHI"><a class="header-anchor" href="#使用AHI"></a>使用AHI</h2><p>AHI的目的是根据用户提供的查询条件加速定位到叶子节点，一般如果有固定的查询pattern，都可以通过AHI受益，尤其是Btree高度比较大的时候。</p><p>入口函数：<code>btr_cur_search_to_nth_level</code></p><p>相关代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Use of AHI is disabled for intrinsic table as these tables re-use</span></span><br><span class="line"><span class="comment">        the index-id and AHI validation is based on index-id. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">rw_lock_get_writer</span>(&amp;btr_search_latch) == RW_LOCK_NOT_LOCKED</span><br><span class="line">            &amp;&amp; latch_mode &lt;= BTR_MODIFY_LEAF</span><br><span class="line">            &amp;&amp; info-&gt;last_hash_succ</span><br><span class="line">            &amp;&amp; !index-&gt;disable_ahi</span><br><span class="line">            &amp;&amp; !estimate</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> PAGE_CUR_LE_OR_EXTENDS</span></span><br><span class="line">            &amp;&amp; mode != PAGE_CUR_LE_OR_EXTENDS</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* PAGE_CUR_LE_OR_EXTENDS */</span></span></span><br><span class="line">            &amp;&amp; !<span class="built_in">dict_index_is_spatial</span>(index)</span><br><span class="line">            <span class="comment">/* If !has_search_latch, we do a dirty read of</span></span><br><span class="line"><span class="comment">            btr_search_enabled below, and btr_search_guess_on_hash()</span></span><br><span class="line"><span class="comment">            will have to check it again. */</span></span><br><span class="line">            &amp;&amp; <span class="built_in">UNIV_LIKELY</span>(btr_search_enabled)</span><br><span class="line">            &amp;&amp; !modify_external</span><br><span class="line">            &amp;&amp; <span class="built_in">btr_search_guess_on_hash</span>(index, info, tuple, mode,</span><br><span class="line">                                        latch_mode, cursor,</span><br><span class="line">                                        has_search_latch, mtr)) &#123;</span><br></pre></td></tr></table></figure><p>从代码段可以看出，需要满足如下条件才能够使用AHI：</p><ul><li>没有加btr_search_latch写锁。如果加了写锁，可能操作时间比较耗时，走AHI检索记录就得不偿失了；</li><li>latch_mode &lt;= BTR_MODIFY_LEAF，表明本次只是一次不变更BTREE结构的DML或查询（包括等值、RANGE等查询）操作；</li><li><code>btr_search_info::last_hash_succ</code>为true表示最近一次使用AHI成功（或可能成功）了；</li><li>打开AHI开关；</li><li>查询优化阶段的估值操作，例如计算range范围等，典型的堆栈包括：<code>handler::multi_range_read_info_const</code>　–&gt; <code>ha_innobase::records_in_range</code> –&gt; <code>btr_estimate_n_rows_in_range</code> –&gt; <code>btr_cur_search_to_nth_level</code>；</li><li>不是spatial索引；</li><li>调用者无需分配外部存储页(BTR_MODIFY_EXTERNAL，主要用于辅助写入大的blob数据，参考struct btr_blob_log_check_t)。</li></ul><p>当满足上述条件时，进入函数<code>btr_search_guess_on_hash</code>，根据当前的查询tuple对象计算fold，并查询AHI；只有当前检索使用的tuple列的个数大于等于构建AHI的列的个数时，才能够使用AHI索引。</p><p><code>btr_search_guess_on_hash</code>：</p><ul><li>首先用户提供的前缀索引查询条件必须大于等于构建AHI时的前缀索引列数，这里存在一种可能性：索引上的search_info的n_fields 和block上构建AHI时的cur_n_fields值已经不相同了，但是我们并不知道本次查询到底落在哪个block上，这里一致以search_info上的n_fields为准来计算fold，去查询AHI；</li><li>在检索AHI时需要加&amp;btr_search_latch的S锁；</li><li>如果本次无法命中AHI，就会将<code>btr_search_info::last_hash_succ</code>设置为false，这意味着随后的查询都不会去使用AHI了，只能等待下一路查询信息分析后才可能再次启动（<code>btr_search_failure</code>）；</li><li>对于从ahi中获得的记录指针，还需要根据当前的查询模式检查是否是正确的记录位置（<code>btr_search_check_guess</code>）。</li></ul><p>如果本次查询使用了AHI，但查询失败了（<code>cursor-&gt;flag == BTR_CUR_HASH_FAIL</code>），并且当前block构建AHI索引的curr_n_fields等字段和btr_search_info上的相符合，则根据当前cursor定位到的记录插入AHI。参考函数：<code>btr_search_update_hash_ref</code>。</p><p>从上述分析可见，AHI如其名，完全是自适应的，如果检索模式不固定，很容易就出现无法用上AHI或者AHI失效的情况。</p><h2 id="维护AHI"><a class="header-anchor" href="#维护AHI"></a>维护AHI</h2><ol><li><p>关闭选项innodb_adaptive_hash_index；</p><ul><li>持有<code>dict_sys-&gt;mutex</code>和<code>btr_search_latch</code>的X锁；</li><li>遍历<code>dict_sys-&gt;table_LRU</code>和<code>dict_sys-&gt;table_non_LRU</code>链表，将每个表上的所有索引的<code>index-&gt;search_info-&gt;ref_count</code>设置为0；</li><li>释放<code>dict_sys-&gt;mutex</code>；</li><li>遍历buffer pool，将block上的index标记(<code>buf_block_t::index</code>)清空为NULL；</li><li>清空AHI中的哈希项，并释放为记录项分配的Heap；</li><li>释放btr_search_latch。</li></ul><p>参考函数：<code>btr_search_disable</code></p></li><li><p><code>index-&gt;search_info</code>的ref_count不为0时，无法从数据集词典cache中将对应的表驱逐，workaround的方式是临时关闭AHI开关；</p><p>参考函数：<code>dict_table_can_be_evicted</code>、<code>dict_index_remove_from_cache_low</code></p></li><li><p>删除索引页上的记录，或者更新的是二级索引、或者更新了主键且影响了排序键值，则需要从AHI上将对应的索引记录删除；</p><p>参考函数：<code>btr_search_update_hash_on_delete</code></p></li><li><p>插入新的记录时，如果本次插入未产生页面重组、操作的page为叶子节点，且本次插入操作使用过AHI定位成功，则先尝试更新再尝试插入，否则直接插入对应的AHI记录项；</p><p>参考函数：<code>btr_search_update_hash_node_on_insert</code>、<code>btr_search_update_hash_on_insert</code></p></li><li><p>涉及索引树分裂或者节点合并，或从LRU中驱逐page（buf_LRU_free_page）时，需要清空AHI对应的page。</p><p>参考函数：<code>btr_search_drop_page_hash_index</code></p></li></ol><h2 id="shortcut查询模式"><a class="header-anchor" href="#shortcut查询模式"></a>shortcut查询模式</h2><p>在<code>row_search_mvcc</code>函数中，首先会去判断在满足一定条件时，使用shortcut模式，利用AHI索引来进行检索。</p><p>只有满足严苛的条件时（例如需要唯一键查询、使用聚集索引、长度不超过八分之一的page size、隔离级别在RC及RC之上、活跃的Read view等等条件，具体的参阅代码），才能使用shortcut：</p><ul><li>加<code>btr_search_latch</code>的S锁；</li><li>然后通过<code>row_sel_try_search_shortcut_for_mysql</code>检索记录；如果找到满足条件的记录，本次查询可以不释放 btr_search_latch，这意味着InnoDB/server层交互期间可能持有AHI锁，但最多在10000次（BTR_SEA_TIMEOUT）交互后释放AHI latch。一旦发现有别的线程在等待AHI X 锁，也会主动释放其拥有的S锁。</li></ul><p>然而， Percona的开发Alexey Kopytov认为这种长时间拥有的<code>btr_search_latch</code>的方式是没有必要的，这种设计方式出现在很久之前加锁、解锁非常昂贵的时代，然而现在的CPU已经很先进了，完全没有必要，在Percona的版本中，一次shortcut的查询操作后都直接释放掉<code>btr_search_latch</code>（参阅<a href="https://bugs.launchpad.net/percona-server/+bug/1218347">bug#1218347</a>）。</p><h2 id="AHI监控项"><a class="header-anchor" href="#AHI监控项"></a>AHI监控项</h2><p>我们可以通过<code>information_schema.innodb_metrics</code>来监控AHI模块的运行状态</p><p>首先打开监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">set</span> <span class="keyword">global</span> innodb_monitor_enable <span class="operator">=</span> module_adaptive_hash;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> status, name, subsystem <span class="keyword">from</span> INNODB_METRICS <span class="keyword">where</span> subsystem <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------------------------------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> status  <span class="operator">|</span> name                                     <span class="operator">|</span> subsystem           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------------------------------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_searches                   <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_searches_btree             <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_pages_added                <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_pages_removed              <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_rows_added                 <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_rows_removed               <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_rows_deleted_no_hash_entry <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> enabled <span class="operator">|</span> adaptive_hash_rows_updated               <span class="operator">|</span> adaptive_hash_index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------------------------------------+---------------------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>重置所有的计数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_monitor_reset_all <span class="operator">=</span> <span class="string">&#x27;adaptive_hash%&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>该表搜集了AHI子系统诸如AHI查询次数，更新次数等信息，可以很好的监控其运行状态，在某些负载下，AHI并不适合打开，关闭AHI可以避免额外的维护开销。当然这取决于你针对具体负载的性能测试。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/mysql-introduction-innodb-adaptive-hash-index/">http://xnerv.wang/mysql-introduction-innodb-adaptive-hash-index/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2015/09/01/">InnoDB Adaptive hash index介绍</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道InnoDB的索引组织结构为Btree。通常情况下，我们需要根据查询条件，从根节点开始寻路到叶子节点，找到满足条件的记录。为了减少寻路开销，InnoDB本身做了几点优化。&lt;/p&gt;
&lt;p&gt;首先，对于连续记录扫描，InnoDB在满足比较严格的条件时采用row cache的方式连续读取8条记录（并将记录格式转换成MySQL Format），存储在线程私有的&lt;code&gt;row_prebuilt_t::fetch_cache&lt;/code&gt;中；这样一次寻路就可以获取多条记录，在server层处理完一条记录后，可以直接从cache中取数据而无需再次寻路，直到cache中数据取完，再进行下一轮。&lt;/p&gt;
&lt;p&gt;另一种方式是，当一次进入InnoDB层获得数据后，在返回server层前，当前在btree上的cursor会被暂时存储到&lt;code&gt;row_prebuilt_t::pcur&lt;/code&gt;中，当再次返回InnoDB层捞数据时，如果对应的Block没有发生任何修改，则可以继续沿用之前存储的cursor，无需重新定位。&lt;/p&gt;
&lt;p&gt;上面这两种方式都是为了减少了重新寻路的次数，而对于一次寻路的开销，则使用Adaptive hash index来解决。AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://xnerv.wang/tags/InnoDB/"/>
    
    <category term="Adaptive hash index" scheme="https://xnerv.wang/tags/Adaptive-hash-index/"/>
    
    <category term="Hash" scheme="https://xnerv.wang/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - set names 都做了什么（转载）</title>
    <link href="https://xnerv.wang/what-set-names-does/"/>
    <id>https://xnerv.wang/what-set-names-does/</id>
    <published>2018-03-17T05:50:00.000Z</published>
    <updated>2023-08-21T02:40:00.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景"></a>背景</h2><p>最近有同事问，set names 时会同时设置了3个session变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client <span class="operator">=</span> charset_name;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="operator">=</span> charset_name;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="operator">=</span> charset_name;</span><br></pre></td></tr></table></figure><p>就从变量名字来看，character_set_client 是设置客户端相关的字符集，character_set_results 是设置返回结果相关的字符集，character_set_connection 这个就有点不太明白了，这个有啥用呢？</p><h2 id="概念说明"><a class="header-anchor" href="#概念说明"></a>概念说明</h2><p>通过<a href="http://dev.mysql.com/doc/refman/5.6/en/charset-connection.html">官方文档</a>来看:</p><ol><li>character_set_client 是指客户端发送过来的语句的编码;</li><li>character_set_connection 是指mysqld收到客户端的语句后，要转换到的编码；</li><li>而 character_set_results 是指server执行语句后，返回给客户端的数据的编码。</li></ol><span id="more"></span><p>对人来说，能够理解的是各种各样的符号，而对计算机来说，只能理解二进制，二进制和符号之间的对应关系就是编码。不同地域国家都有自己的一套符号集合，每个都各自用一组二进制数字表示，从而形成了不同的编码，字符集就可以看作是编码和符号的对应关系集合。同一个二进制数在不同的字符集下可能对应完全不一样的字符，如在GBK字符集中，<code>C4E3</code> 对应的是<code>你</code>，而在big5字符集中对应的是<code>斕</code>，而 <code>你</code>在unicode中的编码是<code>4F60</code>，在<a href="http://collation-charts.org/">Collation-Charts</a> 这个网站有字符集和编码对应关系图，可以非常直观地看到不同编码下二进制数和符号的对应关系。</p><p>set names 设置的3个变量就是设置mysqld和客户端通信时，mysqld应该如何解读client发来的字符，以及返回给客户端什么样的编码。</p><h2 id="实验测试"><a class="header-anchor" href="#实验测试"></a>实验测试</h2><p>环境如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> character_set_client     <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_connection <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_database   <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_filesystem <span class="operator">|</span> <span class="type">binary</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_results    <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_server     <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> character_set_system     <span class="operator">|</span> utf8                                <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>server端的3个编码设置都是utf8。 另外，客户端是标准 mysql client，使用的编码是utf8，和sever端编码是一致的。</p><p>建一张表作为测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(id <span class="type">INT</span>, name <span class="type">VARCHAR</span>(<span class="number">200</span>) CHARSET utf8) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> id, name, hex(name) <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name   <span class="operator">|</span> hex(name)    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> 你好   <span class="operator">|</span> E4BDA0E5A5BD <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------+</span></span><br></pre></td></tr></table></figure><p>下面我们分别改变这3个值，来看下结果会有什么变化</p><p><strong>Case 1 只改变 character_set_client</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client<span class="operator">=</span>gbk;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> id, name, hex(name) <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name      <span class="operator">|</span> hex(name)          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 浣犲ソ    <span class="operator">|</span> E6B5A3E78AB2E382BD <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到返回的数据已经乱码了，并且数据库里存的确实和第一条记录不一样。</p><p><strong>case 2 只改变 character_set_connection</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> names utf8;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="operator">=</span> gbk;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> id, name, hex(name) <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name      <span class="operator">|</span> hex(name)          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 浣犲ソ    <span class="operator">|</span> E6B5A3E78AB2E382BD <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>case 3 只改变 character_set_results</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> names utf8;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="operator">=</span> gbk;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id, name, hex(name) <span class="keyword">from</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name   <span class="operator">|</span> hex(name)          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span>        <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 你好   <span class="operator">|</span> E6B5A3E78AB2E382BD <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>        <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>        <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>再改回原样，看下结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> names utf8;</span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> id, name, hex(name) <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name      <span class="operator">|</span> hex(name)          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 浣犲ソ    <span class="operator">|</span> E6B5A3E78AB2E382BD <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="header-anchor" href="#分析"></a>分析</h2><p>我们先理下字符集在整个过程中是怎样变化的，然后再分析上面的case</p><p>客户发送请求时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A1 客户端发送出语句(总是以utf8)------&gt; A2 sever收到语句解析(按character_set_client指定编码)</span><br><span class="line">                                                                    |</span><br><span class="line">                                                                    v</span><br><span class="line">A4 数据进入mysqld内部存储&lt;--------- A3 sever判断是否需要转换编码(以character_set_connection 目标编码)</span><br></pre></td></tr></table></figure><p>server返回结果时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B1 server返回结果(按character_set_results 指定编码) -----&gt;B2客户端解析编码显示(总是以utf8)</span><br></pre></td></tr></table></figure><p>A3步是否需要转换编码，代码中的逻辑是这样的，在sql_yacc.yy文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LEX_STRING tmp;</span><br><span class="line">THD *thd= YYTHD;</span><br><span class="line"><span class="type">const</span> CHARSET_INFO *cs_con= thd-&gt;variables.collation_connection;</span><br><span class="line"><span class="type">const</span> CHARSET_INFO *cs_cli= thd-&gt;variables.character_set_client;</span><br><span class="line">uint repertoire= thd-&gt;lex-&gt;text_string_is_7bit &amp;&amp;</span><br><span class="line">                 <span class="built_in">my_charset_is_ascii_based</span>(cs_cli) ?</span><br><span class="line">                 MY_REPERTOIRE_ASCII : MY_REPERTOIRE_UNICODE30;</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;charset_is_collation_connection ||</span><br><span class="line">    (repertoire == MY_REPERTOIRE_ASCII &amp;&amp;</span><br><span class="line">     <span class="built_in">my_charset_is_ascii_based</span>(cs_con)))</span><br><span class="line">   tmp= $<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (thd-&gt;<span class="built_in">convert_string</span>(&amp;tmp, cs_con, $<span class="number">1.</span>str, $<span class="number">1.l</span>ength, cs_cli))</span><br><span class="line">      MYSQL_YYABORT;</span><br><span class="line">&#125;</span><br><span class="line">$= <span class="built_in">new</span> (thd-&gt;mem_root) <span class="built_in">Item_string</span>(tmp.str, tmp.length, cs_con,</span><br><span class="line">                                    DERIVATION_COERCIBLE,</span><br><span class="line">                                    repertoire);</span><br><span class="line"><span class="keyword">if</span> ($ == <span class="literal">NULL</span>)</span><br><span class="line">   MYSQL_YYABORT;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 <code>character_set_client</code> 和 <code>character_set_connection</code> 一样，或者当前的字符编码是和ASCII兼容，并且都是ASCII范围内的，就不转换，其它情况就转。</p><p>对于case1 实际上客户端发过来是UTF8的，但A2步骤server认为客户端的编码是GBK的，就按GBK来解析，同时满足A3步骤的转换条件，所以就误将UTF8编码认为是GBK，然后又给转成了UTF8。 <code>你好</code>的UTF8编码是 <code>E4BDA0E5A5BD</code> 6个字节，每个字符3个字节，按GBK来解析的话，因为GBK是固定2个字节，就认为有3个字符，然后转成UTF8，虽然UTF8是变长的，但是这里的3个GBK字符按值都是要占3个字节的，转出来一共9个字节。所以case1看到的实际存储的值一共9个字节，比原来的大。 在返回时，是按UTF8返回的，因为存了3个UTF8字符，所以客户端看到的就是3个。</p><p>对于case2 A2步骤没问题，问题是出在A3，按照转换逻辑，此时需要把UTF8转成GBK，这里因为<code>character_set_client</code>是正确的，所以转换的源不会识别错，转换成GBK自然也不会错，后面存储成UTF8时，再从GBK转成UTF8，也没错，因为UTF8和GBK字符集里都包含 ‘你’和’好’，所以相互转换也不会出错，只是多了2次转换。</p><p>对于case3 错在返回字符集设置的和客户端不匹配，在返回时，server将所有字符转成GBK的，结果客户端一根筋的认为是UTF8，就解析错了。 比较有意思的是第二条记录，即case1错误插进去的，显示出来是对的。 为什么呢，因为在case1中存的时候，是按 <code>UTF8-&gt;强制解析为GBK-&gt;然后转为UTF8</code> 这个逻辑存下去的，而返回的时候，因为server会将存的UTF8又给转回GBK，然后客户端又拿着这个GBK误以为是UTF8解析，实际上是case1的逆向过程，虽然2个方向都是错的，最终显示是好的，所谓的负负得正吧，哈哈。</p><p>对于case2 ，数据从客户端进入server的时候，多做了2次转换，最终显示还是对的，但不是所有场景都是这样，如下面这种</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> names utf8;</span><br><span class="line"><span class="keyword">set</span> character_set_connection  <span class="operator">=</span> latin1;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="keyword">set</span> names utf8;</span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> id, name, hex(name) <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name      <span class="operator">|</span> hex(name)          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 浣犲ソ    <span class="operator">|</span> E6B5A3E78AB2E382BD <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 你好      <span class="operator">|</span> E4BDA0E5A5BD       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> ??        <span class="operator">|</span> <span class="number">3</span>F3F               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----------+--------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>为什么呢，因为在 UTF8转latin1时，信息丢失了，latin1字符编码所能表达的字符集是远小于utf8的，<code>你</code> 和 <code>好</code>就不在其中，这2个字符在转换中被转成了 <code>?</code> 和 <code>?</code>，之后存储转换成UTF8时，<code>?</code>只有一个字节<code>3F</code>，还原回去还是 <code>3F</code>。</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p><code>character_set_client</code> 和 <code>character_set_results</code> 是一定要和客户端一致，不要依赖于负负得正，<code>character_set_connection</code> 设置和<code>character_set_client</code> 不一致，有丢失数据的风险，所以尽量也一致，总之这3个值就是要一样，还要和客户端一致，所以才有了 set names 这个快捷命令。关于为啥要有 <code>character_set_connection</code> 这一步转换，笔者目前还没看出来，以后理解了再更新，如果读者朋友知道的话，请不吝赐教。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/what-set-names-does/">http://xnerv.wang/what-set-names-does/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2015/05/07/">set names 都做了什么</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;最近有同事问，set names 时会同时设置了3个session变量&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; character_set_client &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; charset_name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; character_set_results &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; charset_name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; character_set_connection &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; charset_name;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就从变量名字来看，character_set_client 是设置客户端相关的字符集，character_set_results 是设置返回结果相关的字符集，character_set_connection 这个就有点不太明白了，这个有啥用呢？&lt;/p&gt;
&lt;h2 id=&quot;概念说明&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概念说明&quot;&gt;&lt;/a&gt;概念说明&lt;/h2&gt;
&lt;p&gt;通过&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/charset-connection.html&quot;&gt;官方文档&lt;/a&gt;来看:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;character_set_client 是指客户端发送过来的语句的编码;&lt;/li&gt;
&lt;li&gt;character_set_connection 是指mysqld收到客户端的语句后，要转换到的编码；&lt;/li&gt;
&lt;li&gt;而 character_set_results 是指server执行语句后，返回给客户端的数据的编码。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="MySQL charset" scheme="https://xnerv.wang/tags/MySQL-charset/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - Index Condition Pushdown (ICP)（转载）</title>
    <link href="https://xnerv.wang/mysql-index-condition-pushdown/"/>
    <id>https://xnerv.wang/mysql-index-condition-pushdown/</id>
    <published>2018-03-17T05:46:00.000Z</published>
    <updated>2023-08-21T02:40:00.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p><a href="http://mysql.taobao.org/monthly/2015/11/07/">上一篇文章</a> 提过，我们在之后的文章中会从 optimizer 的选项出发，系统的介绍 optimizer 的各个变量，包括变量的原理、作用以及源码实现等，然后再进一步的介绍优化器的工作过程（SQL 语句扁平化处理、索引选择、代价计算、多表连接顺序选择以及物理执行等内容），本期我们先看一下众所周知的 ICP，官方文档请参考<a href="https://dev.mysql.com/doc/refman/5.6/en/condition-pushdown-optimization.html">这里</a>。</p><h2 id="ICP-测试"><a class="header-anchor" href="#ICP-测试"></a>ICP 测试</h2><p>首先，咱们来看一下打开 ICP 与关闭 ICP 之间的性能区别，以下是测试过程：</p><p>准备数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> icp(id <span class="type">int</span>, age <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">30</span>), memo <span class="type">varchar</span>(<span class="number">600</span>)) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> icp <span class="keyword">add</span> index aind(age, name, memo);</span><br><span class="line"><span class="comment">--let $i= 100000</span></span><br><span class="line">while ($i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">--eval insert into icp values($i, 1, &#x27;a$i&#x27;, repeat(&#x27;a$i&#x27;, 100))</span></span><br><span class="line">  <span class="comment">--dec $i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS: MySQL 有一个叫profile的东东，可以用来监视 SQL 语句在各个阶段的执行情况，咱们可以使用这个工具来观察 SQL 语句在各个阶段的运行情况，关于 profile 的详细说明可以参考<a href="http://dev.mysql.com/doc/refman/5.7/en/show-profile.html">官方文档</a>。</p><span id="more"></span><p>打开 ICP 的性能测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=on&#x27;</span>; （<span class="keyword">default</span> enabled）</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> icp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> memo <span class="keyword">like</span> <span class="string">&#x27;%9999%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">7</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-----------+-----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration  <span class="operator">|</span> CPU_user  <span class="operator">|</span> CPU_system <span class="operator">|</span> Block_ops_in <span class="operator">|</span> Block_ops_out <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-----------+-----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span>  <span class="number">0.000009</span> <span class="operator">|</span>  <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>            <span class="number">0</span> <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">3.225383</span> <span class="operator">|</span> <span class="number">3.507467</span> <span class="operator">|</span>   <span class="number">0.037994</span> <span class="operator">|</span>            <span class="number">0</span> <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-----------+-----------+------------+--------------+---------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> session status <span class="keyword">like</span> <span class="string">&#x27;%handler%&#x27;</span>;<span class="keyword">show</span> session status <span class="keyword">like</span> <span class="string">&#x27;%handler%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Handler_read_next          <span class="operator">|</span> <span class="number">19</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Handler_read_rnd_next      <span class="operator">|</span> <span class="number">30</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+--------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>关闭 ICP 的性能测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> icp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> memo <span class="keyword">like</span> <span class="string">&#x27;%9999%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu, block io <span class="keyword">for</span> query <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span> CPU_user <span class="operator">|</span> CPU_system <span class="operator">|</span> Block_ops_in <span class="operator">|</span> Block_ops_out <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">15.327345</span> <span class="operator">|</span> <span class="number">17.443348</span> <span class="operator">|</span>   <span class="number">0.165975</span> <span class="operator">|</span>            <span class="number">0</span> <span class="operator">|</span>             <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> session status <span class="keyword">like</span> <span class="string">&#x27;%handler%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Handler_read_next          <span class="operator">|</span> <span class="number">100019</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Handler_read_rnd_next      <span class="operator">|</span> <span class="number">47</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+--------+</span></span><br><span class="line"><span class="number">18</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>测试结论：由以上测试情况可以看到，在二级索引是复合索引且前面的条件过滤性较低的情况下，打开 ICP 可以有效的降低 server 层和 engine 层之间交互的次数，从而有效的降低在运行时间。</p><h2 id="ICP-原理"><a class="header-anchor" href="#ICP-原理"></a>ICP 原理</h2><p>5.6 之前，在 SQL 语句的执行过程中，server 层通过 engine 的 api 获取数据，然后再进行 where_cond 的判断（具体判断逻辑在: <code>evaluate_join_record</code>），每一条数据都需要从engine层返回server层做判断。我们回顾一下上面把 ICP 关掉的测试，可以看到 <code>Handler_read_next</code> 的值陡增，其原因是第 1 个字段区分度不高，且 memo 字段无法使用索引，造成了类似 index 扫描的的情况，性能较低。</p><p>5.6 之后，在利用索引扫描的过程中，如果发现 where_cond 中含有这个 index 相关的条件，则将此条件记录在 handler 接口中，在索引扫描的过程中，只有满足索引与handler接口的条件时，才会返回到 server 层做进一步的处理，在前缀索引区分度不够，其它字段区分度高的情况下可以有效的减少 server &amp; engine之间的开销，提升查询性能。</p><h2 id="ICP-源码实现"><a class="header-anchor" href="#ICP-源码实现"></a>ICP 源码实现</h2><p>我们在上小节提到，index condition down 所用的条件是记在handler接口中的，咱们分析一下“记录”的过程是如何实现的。</p><p>首先，优化器计算代价后会生成一个 JOIN_TAB 的左支树，每一个 JOIN_TAB 包含相关表的指针、表的读取方式、访问表所包含的索引等信息，优化器会在 <code>make_join_readinfo</code> 中对JOIN_TAB中表的访问方式进行相应的修正，并进一步将 where cond 中和索引相关的条件记录到 table 的句柄中，堆栈如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0</span>  <span class="built_in">make_cond_for_index</span> (cond=<span class="number">0x2b69680179e8</span>, table=<span class="number">0x2b6968012100</span>, keyno=<span class="number">0</span>, other_tbls_ok=<span class="literal">true</span>)</span><br><span class="line">#<span class="number">1</span>  <span class="function">in <span class="title">push_index_cond</span> <span class="params">(tab=<span class="number">0x2b696802aa48</span>, keyno=<span class="number">0</span>, other_tbls_ok=<span class="literal">true</span>, trace_obj=<span class="number">0x2b696413ec30</span>)</span></span></span><br><span class="line"><span class="function">#2  in <span class="title">make_join_readinfo</span> <span class="params">(join=<span class="number">0x2b6968017db0</span>, options=<span class="number">0</span>, no_jbuf_after=<span class="number">4294967295</span>)</span></span></span><br><span class="line"><span class="function">#3  in <span class="title">JOIN::optimize</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b6968017db0</span>)</span></span></span><br><span class="line"><span class="function">#4  in <span class="title">mysql_execute_select</span> <span class="params">(thd=<span class="number">0x3176760</span>, select_lex=<span class="number">0x3179470</span>, free_join=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>其次， <code>make_cond_for_index</code> 是一个递归的过程，对 where_cond中的每一个条件进行判断，对满足条件的 cond 重新组合成一个新的cond，最后将新的 cond 挂在table-&gt;file 下面（table-&gt;file 指的是操作物理表的接口函数，此变量为thd下私有的，不共享，共享的是tab-&gt;table-&gt;s），详细参考<code>make_cond_for_index</code> 的详细实现，设置的堆栈如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0</span>  ha_innobase::<span class="built_in">idx_cond_push</span> (<span class="keyword">this</span>=<span class="number">0x2b696800e810</span>, keyno=<span class="number">0</span>, idx_cond=<span class="number">0x2b69680179e8</span>)</span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000a60a55</span> <span class="function">in <span class="title">push_index_cond</span> <span class="params">(tab=<span class="number">0x2b696802aa48</span>, keyno=<span class="number">0</span>, other_tbls_ok=<span class="literal">true</span>, trace_obj=<span class="number">0x2b696413ec30</span>)</span></span></span><br><span class="line"><span class="function">#2  0x0000000000a6362f in <span class="title">make_join_readinfo</span> <span class="params">(join=<span class="number">0x2b6968017db0</span>, options=<span class="number">0</span>, no_jbuf_after=<span class="number">4294967295</span>)</span></span></span><br><span class="line"><span class="function">#3  0x0000000000d9b8bd in <span class="title">JOIN::optimize</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b6968017db0</span></span></span></span><br><span class="line"><span class="params"><span class="function">#<span class="number">4</span>  <span class="number">0x0000000000a5b9ae</span> in mysql_execute_select (thd=<span class="number">0x3176760</span>, select_lex=<span class="number">0x3179470</span>, free_join=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><p>再次，server 层根据生成的 JOIN_TAB 读取engine层的内容，在engine读取的时候，会进行<code>index_condition_pushdown</code>的调用，即 ICP 的调用，堆栈如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0</span>  Item_func_like::<span class="built_in">val_int</span> (<span class="keyword">this</span>=<span class="number">0x2b6978005a28</span>)</span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000001187b66</span> <span class="function">in <span class="title">innobase_index_cond</span> <span class="params">(file=<span class="number">0x2b696800e810</span>)</span></span></span><br><span class="line"><span class="function">#2  0x0000000001393566 in <span class="title">row_search_idx_cond_check</span> <span class="params">(mysql_rec=<span class="number">0x2b69680129f0</span>  &lt;incomplete sequence \<span class="number">361</span>&gt;, prebuilt=<span class="number">0x2b69680130f8</span>, rec=<span class="number">0x2b692b56e4cf</span> <span class="string">&quot;\200&quot;</span>, offsets=<span class="number">0x2b697008d450</span>)</span></span></span><br><span class="line"><span class="function">#3  0x0000000001397e2b in <span class="title">row_search_for_mysql</span> <span class="params">(buf=<span class="number">0x2b69680129f0</span>  &lt;incomplete sequence \<span class="number">361</span>&gt;, mode=<span class="number">2</span>, prebuilt=<span class="number">0x2b69680130f8</span>, match_mode=<span class="number">1</span>, direction=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">#4  0x00000000011696b9 in <span class="title">ha_innobase::index_read</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b696800e810</span>, buf=<span class="number">0x2b69680129f0</span>  &lt;incomplete sequence \<span class="number">361</span>&gt;, key_ptr=<span class="number">0x2b697800a660</span> <span class="string">&quot;&quot;</span>, key_len=<span class="number">5</span>, find_flag=HA_READ_KEY_EXACT)</span></span></span><br><span class="line"><span class="function">#5  0x00000000006ecc58 in <span class="title">handler::index_read_map</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b696800e810</span>, buf=<span class="number">0x2b69680129f0</span>  &lt;incomplete sequence \<span class="number">361</span>&gt;, key=<span class="number">0x2b697800a660</span> <span class="string">&quot;&quot;</span>, keypart_map=<span class="number">1</span>, find_flag=HA_READ_KEY_EXACT)</span></span></span><br><span class="line"><span class="function">#6  0x00000000006d6bb4 in <span class="title">handler::ha_index_read_map</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b696800e810</span>, buf=<span class="number">0x2b69680129f0</span>  &lt;incomplete sequence \<span class="number">361</span>&gt;, key=<span class="number">0x2b697800a660</span> <span class="string">&quot;&quot;</span>, keypart_map=<span class="number">1</span>, find_flag=HA_READ_KEY_EXACT)</span></span></span><br><span class="line"><span class="function">#7  0x00000000009a1870 in <span class="title">join_read_always_key</span> <span class="params">(tab=<span class="number">0x2b697800a1b8</span>)</span></span></span><br><span class="line"><span class="function">#8  0x000000000099d480 in <span class="title">sub_select</span> <span class="params">(join=<span class="number">0x2b6978005df0</span>, join_tab=<span class="number">0x2b697800a1b8</span>, end_of_records=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">#9  0x000000000099c6c0 in <span class="title">do_select</span> <span class="params">(join=<span class="number">0x2b6978005df0</span>)</span></span></span><br><span class="line"><span class="function">#10 0x00000000009980a4 in <span class="title">JOIN::exec</span> <span class="params">(<span class="keyword">this</span>=<span class="number">0x2b6978005df0</span>)</span></span></span><br><span class="line"><span class="function">#11 0x0000000000a5bac0 in <span class="title">mysql_execute_select</span> <span class="params">(thd=<span class="number">0x32801a0</span>, select_lex=<span class="number">0x3282eb0</span>, free_join=<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>可见在 ICP 的判断是调用相关item的函数的，虽然同是调用 server 层的函数，但是没有 ICP 的调用需要根据主建找到记录，然后再匹配，而有了 ICP 可以省略一次主键查找数据的过程，进而提升效率。</p><h2 id="ICP-使用限制及问题"><a class="header-anchor" href="#ICP-使用限制及问题"></a>ICP 使用限制及问题</h2><ul><li><p>只支持 select 语句；</p></li><li><p>5.6 中只支持 MyISAM 与 InnoDB 引擎;</p></li><li><p>ICP的优化策略可用于range、ref、eq_ref、ref_or_null 类型的访问数据方法；</p></li><li><p>不支持主建索引的 ICP；</p></li><li><p>当 SQL 使用覆盖索引时但只检索部分数据时，ICP 无法使用，详细的分析可以参考 <a href="http://bugs.mysql.com/bug.php?id=68554">bug#68554</a> 中 Olav Sandstå的分析，代码实现部分可以参考 <code>make_join_readinfo</code>；</p></li><li><p>在查询的时候即使正确的使用索引的前Ｎ个字段（即遵循前缀索引的原则），还是会用到 ICP，无故的多了 ICP 相关的判断，这应该是一个退化的问题，例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from icp where age=1 and name = &#x27;a1&#x27;;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+-------------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref         | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+-------------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | icp   | ref  | aind          | aind | 38      | const,const |    1 | Using index condition |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+-------------+------+-----------------------+</span><br><span class="line">1 row in set (3.26 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>PS: engine condition pushdown 是 NDB 使用的，其它引擎不支持。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/mysql-index-condition-pushdown/">http://xnerv.wang/mysql-index-condition-pushdown/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2015/12/08/">Index Condition Pushdown (ICP)</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://mysql.taobao.org/monthly/2015/11/07/&quot;&gt;上一篇文章&lt;/a&gt; 提过，我们在之后的文章中会从 optimizer 的选项出发，系统的介绍 optimizer 的各个变量，包括变量的原理、作用以及源码实现等，然后再进一步的介绍优化器的工作过程（SQL 语句扁平化处理、索引选择、代价计算、多表连接顺序选择以及物理执行等内容），本期我们先看一下众所周知的 ICP，官方文档请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/condition-pushdown-optimization.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;ICP-测试&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#ICP-测试&quot;&gt;&lt;/a&gt;ICP 测试&lt;/h2&gt;
&lt;p&gt;首先，咱们来看一下打开 ICP 与关闭 ICP 之间的性能区别，以下是测试过程：&lt;/p&gt;
&lt;p&gt;准备数据：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; icp(id &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, age &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, name &lt;span class=&quot;type&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;), memo &lt;span class=&quot;type&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;600&lt;/span&gt;)) engine&lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt;innodb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; icp &lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt; index aind(age, name, memo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--let $i= 100000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while ($i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;--eval insert into icp values($i, 1, &amp;#x27;a$i&amp;#x27;, repeat(&amp;#x27;a$i&amp;#x27;, 100))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;--dec $i&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PS: MySQL 有一个叫profile的东东，可以用来监视 SQL 语句在各个阶段的执行情况，咱们可以使用这个工具来观察 SQL 语句在各个阶段的运行情况，关于 profile 的详细说明可以参考&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/show-profile.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="Index Condition Pushdown" scheme="https://xnerv.wang/tags/Index-Condition-Pushdown/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 事务锁系统简介（转载）</title>
    <link href="https://xnerv.wang/introduction-of-innodb-transaction-lock/"/>
    <id>https://xnerv.wang/introduction-of-innodb-transaction-lock/</id>
    <published>2018-03-17T05:28:00.000Z</published>
    <updated>2023-08-21T02:40:00.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>本文的目的是对 InnoDB 的事务锁模块做个简单的介绍，使读者对这块有初步的认识。本文先介绍行级锁和表级锁的相关概念，再介绍其内部的一些实现；最后以两个有趣的案例结束本文。</p><p>本文所有的代码和示例都是基于当前最新的 MySQL5.7.10 版本。</p><h2 id="行级锁"><a class="header-anchor" href="#行级锁"></a>行级锁</h2><p>InnoDB 支持到行级别粒度的并发控制，本小节我们分析下几种常见的行级锁类型，以及在哪些情况下会使用到这些类型的锁。</p><p><strong>LOCK_REC_NOT_GAP</strong></p><p>锁带上这个 FLAG 时，表示这个锁对象只是单纯的锁在记录上，不会锁记录之前的 GAP。在 RC 隔离级别下一般加的都是该类型的记录锁（但唯一二级索引上的 duplicate key 检查除外，总是加 <code>LOCK_ORDINARY</code> 类型的锁）。</p><span id="more"></span><p><strong>LOCK_GAP</strong></p><p>表示只锁住一段范围，不锁记录本身，通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。可以理解为一种区间锁，一般在RR隔离级别下会使用到GAP锁。</p><p>你可以通过切换到RC隔离级别，或者开启选项<code>innodb_locks_unsafe_for_binlog</code>来避免GAP锁。这时候只有在检查外键约束或者duplicate key检查时才会使用到GAP LOCK。</p><p><strong>LOCK_ORDINARY(Next-Key Lock)</strong></p><p>也就是所谓的 NEXT-KEY 锁，包含记录本身及记录之前的GAP。当前 MySQL 默认情况下使用RR的隔离级别，而NEXT-KEY LOCK正是为了解决RR隔离级别下的幻读问题。所谓幻读就是一个事务内执行相同的查询，会看到不同的行记录。在RR隔离级别下这是不允许的。</p><p>假设索引上有记录1, 4, 5, 8，12 我们执行类似语句：SELECT… WHERE col &gt; 10 FOR UPDATE。如果我们不在(8, 12)之间加上Gap锁，另外一个 Session 就可能向其中插入一条记录，例如9，再执行一次相同的SELECT FOR UPDATE，就会看到新插入的记录。</p><p>这也是为什么插入一条记录时，需要判断下一条记录上是否加锁了。</p><p><strong>LOCK_S（共享锁）</strong></p><p>共享锁的作用通常用于在事务中读取一条行记录后，不希望它被别的事务锁修改，但所有的读请求产生的LOCK_S锁是不冲突的。在InnoDB里有如下几种情况会请求S锁。</p><ol><li><p>普通查询在隔离级别为 SERIALIZABLE 会给记录加 LOCK_S 锁。但这也取决于场景：非事务读（auto-commit）在 SERIALIZABLE 隔离级别下，无需加锁(不过在当前最新的5.7.10版本中，SHOW ENGINE INNODB STATUS 的输出中不会打印只读事务的信息，只能从<code>informationschema.innodb_trx</code>表中获取到该只读事务持有的锁个数等信息)。</p></li><li><p>类似 SQL SELECT … IN SHARE MODE，会给记录加S锁，其他线程可以并发查询，但不能修改。基于不同的隔离级别，行为有所不同:</p><ul><li>RC隔离级别： <code>LOCK_REC_NOT_GAP | LOCK_S</code>；</li><li>RR隔离级别：如果查询条件为唯一索引且是唯一等值查询时，加的是 <code>LOCK_REC_NOT_GAP | LOCK_S</code>；对于非唯一条件查询，或者查询会扫描到多条记录时，加的是<code>LOCK_ORDINARY | LOCK_S</code>锁，也就是记录本身+记录之前的GAP；</li></ul></li><li><p>通常INSERT操作是不加锁的，但如果在插入或更新记录时，检查到 duplicate key（或者有一个被标记删除的duplicate key），对于普通的INSERT/UPDATE，会加LOCK_S锁，而对于类似REPLACE INTO或者INSERT … ON DUPLICATE这样的SQL加的是X锁。而针对不同的索引类型也有所不同：</p><ul><li>对于聚集索引（参阅函数<code>row_ins_duplicate_error_in_clust</code>），隔离级别小于等于RC时，加的是<code>LOCK_REC_NOT_GAP</code>类似的S或者X记录锁。否则加<code>LOCK_ORDINARY</code>类型的记录锁（NEXT-KEY LOCK）；</li><li>对于二级唯一索引，若检查到重复键，当前版本总是加 LOCK_ORDINARY 类型的记录锁(函数 <code>row_ins_scan_sec_index_for_duplicate</code>)。实际上按照RC的设计理念，不应该加GAP锁（<a href="http://bugs.mysql.com/bug.php?id=68021">bug#68021</a>），官方也事实上尝试修复过一次，即对于RC隔离级别加上<code>LOCK_REC_NOT_GAP</code>，但却引入了另外一个问题，导致二级索引的唯一约束失效(<a href="http://bugs.mysql.com/bug.php?id=73170">bug#73170</a>)，感兴趣的可以参阅我写的<a href="http://mysqllover.com/?p=1041">这篇博客</a>，由于这个严重bug，官方很快又把这个fix给revert掉了。</li></ul></li><li><p>外键检查</p><p>当我们删除一条父表上的记录时，需要去检查是否有引用约束(<code>row_pd_check_references_constraints</code>)，这时候会扫描子表(<code>dict_table_t::referenced_list</code>)上对应的记录，并加上共享锁。按照实际情况又有所不同。我们举例说明</p><p>使用RC隔离级别，两张测试表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (a <span class="type">int</span>, b <span class="type">int</span>, <span class="keyword">primary</span> key(a));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (a <span class="type">int</span>, b <span class="type">int</span>, <span class="keyword">primary</span> key (a), key(b), <span class="keyword">foreign</span> key(b) <span class="keyword">references</span> t1(a));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">4</span>,<span class="number">5</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">7</span>,<span class="number">8</span>), (<span class="number">10</span>,<span class="number">11</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>执行SQL：delete from t1 where a = 10;</p><ul><li>在t1表记录10上加 <code>LOCKREC_NOT_GAP|LOCK_X</code></li><li>在t2表的supremum记录（表示最大记录）上加 <code>LOCK_ORDINARY|LOCK_S</code>，即锁住(4, ~)区间</li></ul><p>执行SQL：delete from t1 where a = 2;</p><ul><li>在t1表记录(2,3)上加 <code>LOCK_REC_NOT_GAP|LOCK_X</code></li><li>在t2表记录(1,2)上加 <code>LOCK_REC_NOT_GAP|LOCK_S</code>锁，这里检查到有引用约束，因此无需继续扫描(2,2)就可以退出检查，判定报错。</li></ul><p>执行SQL：delete from t1 where a = 3;</p><ul><li>在t1表记录(3,4)上加 <code>LOCK_REC_NOT_GAP|LOCK_X</code></li><li>在t2表记录(4,4)上加 <code>LOCK_GAP|LOCK_S</code>锁</li></ul><p>另外从代码里还可以看到，如果扫描到的记录被标记删除时，也会加<code>LOCK_ORDINARY|LOCK_S</code> 锁。具体参阅函数<code>row_ins_check_foreign_constraint</code></p></li><li><p>INSERT … SELECT插入数据时，会对SELECT的表上扫描到的数据加LOCK_S锁</p></li></ol><p><strong>LOCK_X（排他锁）</strong></p><p>排他锁的目的主要是避免对同一条记录的并发修改。通常对于UPDATE或者DELETE操作，或者类似SELECT … FOR UPDATE操作，都会对记录加排他锁。</p><p>我们以如下表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>, <span class="keyword">primary</span> key(a), key(b));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>执行SQL（通过二级索引查询）：update t1 set c = c +1 where b = 3;</p><ul><li>RC隔离级别：1. 锁住二级索引记录，为NOT GAP X锁；2.锁住对应的聚集索引记录，也是NOT GAP X锁。</li><li>RR隔离级别下：1.锁住二级索引记录，为<code>LOCK_ORDINARY|LOCK_X</code>锁；2.锁住聚集索引记录，为NOT GAP X锁</li></ul><p>执行SQL（通过聚集索引检索，更新二级索引数据）：update t1 set b = b +1 where a = 2;</p><ul><li>对聚集索引记录加 <code>LOCK_REC_NOT_GAP | LOCK_X</code>锁;</li><li>在标记删除二级索引时，检查二级索引记录上的锁（<code>lock_sec_rec_modify_check_and_lock</code>），如果存在和<code>LOCK_X | LOCK_REC_NOT_GAP</code>冲突的锁对象，则创建锁对象并返回等待错误码；否则无需创建锁对象；</li><li>当到达这里时，我们已经持有了聚集索引上的排他锁，因此能保证别的线程不会来修改这条记录。（修改记录总是先聚集索引，再二级索引的顺序），即使不对二级索引加锁也没有关系。但如果已经有别的线程已经持有了二级索引上的记录锁，则需要等待。</li><li>在标记删除后，需要插入更新后的二级索引记录时，依然要遵循插入意向锁的加锁原则。</li></ul><p>我们考虑上述两种 SQL 的混合场景，一个是先锁住二级索引记录，再锁聚集索引；另一个是先锁聚集索引，再检查二级索引冲突，因此在这类并发更新场景下，可能会发生死锁。</p><p>不同场景，不同隔离级别下的加锁行为都有所不同，例如在RC隔离级别下，不符合WHERE条件的扫描到的记录，会被立刻释放掉，但RR级别则会持续到事务结束。你可以通过GDB，断点函数<code>lock_rec_lock</code>来查看某条SQL如何执行加锁操作。</p><p><strong>LOCK_INSERT_INTENTION(插入意向锁)</strong></p><p>INSERT INTENTION锁是GAP锁的一种，如果有多个session插入同一个GAP时，他们无需互相等待，例如当前索引上有记录4和8，两个并发session同时插入记录6，7。他们会分别为(4,8)加上GAP锁，但相互之间并不冲突（因为插入的记录不冲突）。</p><p>当向某个数据页中插入一条记录时，总是会调用函数<code>lock_rec_insert_check_and_lock</code>进行锁检查（构建索引时的数据插入除外），会去检查当前插入位置的下一条记录上是否存在锁对象，这里的下一条记录不是指的物理连续，而是按照逻辑顺序的下一条记录。 如果下一条记录上不存在锁对象：若记录是二级索引上的，先更新二级索引页上的最大事务ID为当前事务的ID；直接返回成功。</p><p>如果下一条记录上存在锁对象，就需要判断该锁对象是否锁住了GAP。如果GAP被锁住了，并判定和插入意向GAP锁冲突，当前操作就需要等待，加的锁类型为<code>LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION</code>，并进入等待状态。但是插入意向锁之间并不互斥。这意味着在同一个GAP里可能有多个申请插入意向锁的会话。</p><p><strong>锁表更新</strong></p><p>我们知道GAP锁是在一个记录上描述的，表示记录及其之前的记录之间的GAP。但如果记录之前发生了插入或者删除操作，之前描述的GAP就会发生变化，InnoDB需要对锁表进行更新。</p><p>对于数据插入，假设我们当前在记录[3,9]之间有会话持有锁(不管是否和插入意向锁冲突)，现在插入一条新的记录5，需要调用函数<code>lock_update_insert</code>。这里会遍历所有在记录9上的记录锁，如果这些锁不是插入意向锁并且是LOCK_GAP或者NEXT-KEY LOCK（没有设置<code>LOCK_REC_NOT_GAP</code>标记)(<code>lock_rec_inherit_to_gap_if_gap_lock</code>)，就会为这些会话的事务增加一个新的锁对象，锁的类型为<code>LOCK_REC | LOCK_GAP</code>，锁住的GAP范围在本例中为(3,5)。所有符合条件的会话都继承了这个新的GAP，避免之前的GAP锁失效。</p><p>对于数据删除操作，调用函数<code>lock_update_delete</code>，这里会遍历在被删除记录上的记录锁，当符合如下条件时，需要为这些锁对应的事务增加一个新的GAP锁，锁的Heap No为被删除记录的下一条记录：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lock_rec_inherit_to_gap</span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(lock = lock_rec_get_first(lock_sys-&gt;rec_hash, block, heap_no);</span></span></span><br><span class="line"><span class="params"><span class="function">             lock != <span class="literal">NULL</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">             lock = lock_rec_get_next(heap_no, lock))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">lock_rec_get_insert_intention</span>(lock)</span><br><span class="line">                    &amp;&amp; !((srv_locks_unsafe_for_binlog</span><br><span class="line">                          || lock-&gt;trx-&gt;isolation_level</span><br><span class="line">                          &lt;= TRX_ISO_READ_COMMITTED)</span><br><span class="line">                         &amp;&amp; <span class="built_in">lock_get_mode</span>(lock) ==</span><br><span class="line">                         (lock-&gt;trx-&gt;duplicates ? LOCK_S : LOCK_X))) &#123;</span><br><span class="line">                        <span class="built_in">lock_rec_add_to_queue</span>(</span><br><span class="line">                                LOCK_REC | LOCK_GAP | <span class="built_in">lock_get_mode</span>(lock),</span><br><span class="line">                                heir_block, heir_heap_no, lock-&gt;index,</span><br><span class="line">                                lock-&gt;trx, FALSE);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上述判断可以看出，即使在RC隔离级别下，也有可能继承LOCK GAP锁，这也是当前版本InnoDB唯一的意外：判断Duplicate key时目前容忍GAP锁。上面这段代码实际上在最近的版本中才做过更新，更早之前的版本可能存在二级索引损坏，感兴趣的可以阅读我的<a href="http://mysqllover.com/?p=1477">这篇博客</a></p><p>完成GAP锁继承后，会将所有等待该记录的锁对象全部唤醒(<code>lock_rec_reset_and_release_wait</code>)。</p><p><strong>LOCK_PREDICATE</strong></p><p>从 MySQL5.7 开始MySQL整合了<code>boost.geometry</code>库以更好的支持空间数据类型，并支持在在Spatial数据类型的列上构建索引，在InnoDB内，这个索引和普通的索引有所不同，基于R-TREE的结构，目前支持对2D数据的描述，暂不支持3D.</p><p>R-TREE和BTREE不同，它能够描述多维空间，而多维数据并没有明确的数据顺序，因此无法在RR隔离级别下构建NEXT-KEY锁以避免幻读，因此InnoDB使用称为Predicate Lock的锁模式来加锁，会锁住一块查询用到的被称为MBR(minimum boundingrectangle/box)的数据区域。 因此这个锁不是锁到某个具体的记录之上的，可以理解为一种Page级别的锁。</p><p>Predicate Lock和普通的记录锁或者表锁（如上所述）存储在不同的lock hash中，其相互之间不会产生冲突。</p><p>Predicate Lock相关代码见<code>lock/lock0prdt.cc</code>文件</p><p>关于Predicate Lock的设计参阅官方<a href="http://dev.mysql.com/worklog/task/?id=6609">WL#6609</a>。</p><p><em>由于这块的代码量比较庞大，目前小编对InnoDB的spatial实现了解有限，本文暂不对此展开，将在后面单独专门介绍spatial index时，再细细阐述这块内容。</em></p><p><strong>隐式锁</strong></p><p>InnoDB 通常对插入操作无需加锁，而是通过一种“隐式锁”的方式来解决冲突。聚集索引记录中存储了事务id，如果另外有个session查询到了这条记录，会去判断该记录对应的事务id是否属于一个活跃的事务，并协助这个事务创建一个记录锁，然后将自己置于等待队列中。该设计的思路是基于大多数情况下新插入的记录不会立刻被别的线程并发修改，而创建锁的开销是比较昂贵的，涉及到全局资源的竞争。</p><p>关于隐式锁转换，上一期的月报<a href="http://mysql.taobao.org/monthly/2015/12/01/">InnoDB 事务子系统介绍</a>我们已经介绍过了，这里不再赘述。</p><p><strong>锁的冲突判定</strong></p><p>锁模式的兼容性矩阵通过如下数组进行快速判定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> byte lock_compatibility_matrix[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line"><span class="comment">/** IS IX S X AI /</span></span><br><span class="line"><span class="comment">/ IS / &#123; TRUE, TRUE, TRUE, FALSE, TRUE&#125;,</span></span><br><span class="line"><span class="comment">/ IX / &#123; TRUE, TRUE, FALSE, FALSE, TRUE&#125;,</span></span><br><span class="line"><span class="comment">/ S / &#123; TRUE, FALSE, TRUE, FALSE, FALSE&#125;,</span></span><br><span class="line"><span class="comment">/ X / &#123; FALSE, FALSE, FALSE, FALSE, FALSE&#125;,</span></span><br><span class="line"><span class="comment">/ AI / &#123; TRUE, TRUE, FALSE, FALSE, FALSE&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>对于记录锁而言，锁模式只有LOCK_S 和LOCK_X，其他的 FLAG 用于锁的描述，如前述 LOCK_GAP、LOCK_REC_NOT_GAP 以及 LOCK_ORDINARY、LOCK_INSERT_INTENTION 四种描述。在比较两个锁是否冲突时，即使不满足兼容性矩阵，在如下几种情况下，依然认为是相容的，无需等待（参考函数<code>lock_rec_has_to_wait</code>）</p><ul><li>对于GAP类型（锁对象建立在supremum上或者申请的锁类型为LOCK_GAP）且申请的不是插入意向锁时，无需等待任何锁，这是因为不同Session对于相同GAP可能申请不同类型的锁，而GAP锁本身设计为不互相冲突；</li><li>LOCK_ORDINARY 或者LOCK_REC_NOT_GAP类型的锁对象，无需等待LOCK_GAP类型的锁；</li><li>LOCK_GAP类型的锁无需等待LOCK_REC_NOT_GAP类型的锁对象；</li><li>任何锁请求都无需等待插入意向锁。</li></ul><h2 id="表级锁"><a class="header-anchor" href="#表级锁"></a>表级锁</h2><p>InnoDB的表级别锁包含五种锁模式：LOCK_IS、LOCK_IX、LOCK_X、LOCK_S以及LOCK_AUTO_INC锁，锁之间的相容性遵循数组<code>lock_compatibility_matrix</code>中的定义。</p><p>InnoDB表级锁的目的是为了防止DDL和DML的并发问题。但从5.5版本开始引入MDL锁后，InnoDB层的表级锁的意义就没那么大了，MDL锁本身已经覆盖了其大部分功能。以下我们介绍下几种InnoDB表锁类型。</p><p><strong>LOCK_IS/LOCK_IX</strong></p><p>也就是所谓的意向锁，这实际上可以理解为一种“暗示”未来需要什么样行级锁，IS表示未来可能需要在这个表的某些记录上加共享锁，IX表示未来可能需要在这个表的某些记录上加排他锁。意向锁是表级别的，IS和IX锁之间相互并不冲突，但与表级S/X锁冲突。</p><p>在对记录加S锁或者X锁时，必须保证其在相同的表上有对应的意向锁或者锁强度更高的表级锁。</p><p><strong>LOCK_X</strong></p><p>当加了LOCK_X表级锁时，所有其他的表级锁请求都需要等待。通常有这么几种情况需要加X锁：</p><ul><li>DDL操作的最后一个阶段(<code>ha_innobase::commit_inlace_alter_table</code>)对表上加LOCK_X锁，以确保没有别的事务持有表级锁。通常情况下Server层MDL锁已经能保证这一点了，在DDL的commit 阶段是加了排他的MDL锁的。但诸如外键检查或者刚从崩溃恢复的事务正在进行某些操作，这些操作都是直接InnoDB自治的，不走server层，也就无法通过MDL所保护；</li><li>当设置会话的autocommit变量为OFF时，执行<code>LOCK TABLE tbname WRITE</code>这样的操作会加表级的LOCK_X锁(<code>ha_innobase::external_lock</code>)；</li><li>对某个表空间执行discard或者import操作时，需要加LOCK_X锁(<code>ha_innobase::discard_or_import_tablespace</code>)。</li></ul><p><strong>LOCK_S</strong></p><ul><li><p>在DDL的第一个阶段，如果当前DDL不能通过ONLINE的方式执行，则对表加LOCK_S锁(<code>prepare_inplace_alter_table_dict</code>)；</p></li><li><p>设置会话的autocommit为OFF，执行LOCK TABLE tbname READ时，会加LOCK_S锁(<code>ha_innobase::external_lock</code>)。</p></li></ul><p>从上面的描述我们可以看到LOCK_X及LOCK_S锁在实际的大部分负载中都很少会遇到。主要还是互相不冲突的LOCK_IS及LOCK_IX锁。一个有趣的问题是，每次加表锁时，却总是要扫描表上所有的表级锁对象，检查是否有冲突的锁。很显然，如果我们在同一张表上的更新并发度很高，这个链表就会非常长。</p><p>基于大多数表锁不冲突的事实，我们在RDS MYSQL中对各种表锁对象进行计数，在检查是否有冲突时，例如当前申请的是意向锁，如果此时LOCK_S和LOCK_X的锁计数都是0，就可以认为没有冲突，直接忽略检查。由于检查是在持有全局大锁<code>lock_sys-&gt;mutex</code>下进行的。在单表大并发下，这个优化的效果还是非常明显的，可以减少持有全局大锁的时间。</p><p><strong>LOCK_AUTO_INC</strong></p><p>AUTO_INC锁加在表级别，和AUTO_INC、表级S锁以及X锁不相容。锁的范围为SQL级别，SQL结束后即释放。AUTO_INC的加锁逻辑和InnoDB的锁模式相关，这里在简单介绍一下。</p><p>通常对于自增列，我们既可以显式指定该值，也可以直接用NULL，系统将自动递增并填充该列。我们还可以在批量插入时混合使用者两种方式。不同的分配方式，其具体行为受到参数<code>innodb_autoinc_lock_mode</code>的影响。但在基于STATEMENT模式复制时，可能会影响到复制的数据一致性，<a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html">官方文档</a> 有详细描述，不再赘述，只说明下锁的影响。</p><p>自增锁模式通过参数<code>innodb_autoinc_lock_mode</code>来控制，加锁选择参阅函数<code>ha_innobase::innobase_lock_autoinc</code></p><p>具体的，有以下几个值：</p><p><code>AUTOINC_OLD_STYLE_LOCKING</code>（0）</p><p>也就是所谓的传统加锁模式（在5.1版本引入这个参数之前的策略），在该策略下，会在分配前加上AUTO_INC锁，并在SQL结束时释放掉。该模式保证了在STATEMENT复制模式下，备库执行类似INSERT … SELECT这样的语句时的一致性，因为这样的语句在执行时无法确定到底有多少条记录，只有在执行过程中不允许别的会话分配自增值，才能确保主备一致。</p><p>很显然这种锁模式非常影响并发插入的性能，但却保证了一条SQL内自增值分配的连续性。</p><p><code>AUTOINC_NEW_STYLE_LOCKING</code>（1）</p><p>这是InnoDB的默认值。在该锁模式下</p><ul><li><p>普通的 INSERT 或 REPLACE 操作会先加一个<code>dict_table_t::autoinc_mutex</code>，然后去判断表上是否有别的线程加了LOCK_AUTO_INC锁，如果有的话，释放autoinc_mutex，并使用OLD STYLE的锁模式。否则，在预留本次插入需要的自增值之后，就快速的将autoinc_mutex释放掉。很显然，对于普通的并发INSERT操作，都是无需加LOCK_AUTO_INC锁的。因此大大提升了吞吐量；</p></li><li><p>但是对于一些批量插入操作，例如LOAD DATA，INSERT …SELECT 等还是使用OLD STYLE的锁模式，SQL执行期间加LOCK_AUTO_INC锁。</p></li></ul><p>和传统模式相比，这种锁模式也能保证STATEMENT模式下的复制安全性，但却无法保证一条插入语句内的自增值的连续性，并且在执行一条混合了显式指定自增值和使用系统分配两种方式的插入语句时，可能存在一定的自增值浪费。</p><p>例如执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,’d’）</span><br></pre></td></tr></table></figure><p>假设当前AUTO_INCREMENT值为101，在传统模式下执行完后，下一个自增值为103，而在新模式下，下一个可用的自增值为105，因为在开始执行SQL时，会先预取了[101, 104] 4个自增值，这和插入行的个数相匹配，然后将AUTO_INCREMENT设为105，导致自增值103和104被浪费掉。</p><p><code>AUTOINC_NO_LOCKING</code>（2）</p><p>这种模式下只在分配时加个mutex即可，很快就释放，不会像NEW STYLE那样在某些场景下会退化到传统模式。因此设为2不能保证批量插入的复制安全性。</p><p><strong>关于自增锁的小BUG</strong></p><p>这是Mariadb的Jira上报的一个小bug，在row模式下，由于不走parse的逻辑，我们不知道行记录是通过什么批量导入还是普通INSERT产生的，因此command类型为SQLCOM_END，而在判断是否加自增锁时的逻辑时，是通过COMMAND类型是否为SQLCOM_INSERT或者SQLCOM_REPLACE来判断是否忽略加AUTO_INC锁。这个额外的锁开销，会导致在使用ROW模式时，InnoDB总是加AUTO_INC锁，加AUTO_INC锁又涉及到全局事务资源的开销，从而导致性能下降。</p><p>修复的方式也比较简单，将SQLCOM_END这个command类型也纳入考虑。</p><p>具体参阅<a href="https://mariadb.atlassian.net/browse/MDEV-7578">Jira链接</a>。</p><h2 id="事务锁管理"><a class="header-anchor" href="#事务锁管理"></a>事务锁管理</h2><p>InnoDB 所有的事务锁对象都是挂在全局对象lock_sys上，同时每个事务对象上也维持了其拥有的事务锁，每个表对象(<code>dict_table_t</code>)上维持了构建在其上的表级锁对象。</p><p>如下图所示：</p><center><img src="http://mysql.taobao.org/monthly/pic/2016-01-01/innodb_lock.png" alt="innodb 锁"/><span>innodb 锁</span></center><p><strong>加表级锁</strong></p><ul><li>首先从当前事务的<code>trx_lock_t::table_locks</code>中查找是否已经加了等同或更高级别的表锁，如果已经加锁了，则直接返回成功（<code>lock_table_has</code>）；</li><li>检查当前是否有和正在申请的锁模式冲突的表级锁对象（<code>lock_table_other_has_incompatible</code>）；<ul><li>直接遍历链表<code>dict_table_t::locks</code>链表</li></ul></li><li>如果存在冲突的锁对象，则需要进入等待队列（<code>lock_table_enqueue_waiting</code>）<ul><li>创建等待锁对象 （<code>lock_table_create</code>）</li><li>检查是否存在死锁（<code>DeadlockChecker::check_and_resolve</code>），当存在死锁时：如果当前会话被选作牺牲者，就移除锁请求(<code>lock_table_remove_low</code>)，重置当前事务的wait_lock为空，并返回错误码DB_DEADLOCK；若被选成胜利者，则锁等待解除，可以认为当前会话已经获得了锁，返回成功；</li><li>若没有发生死锁，设置事务对象的相关变量后，返回错误码DB_LOCK_WAIT，随后进入锁等待状态</li></ul></li><li>如果不存在冲突的锁，则直接创建锁对象（<code>lock_table_create</code>），加入队列。</li></ul><p><code>lock_table_create</code>: 创建锁对象</p><ul><li>当前请求的是AUTO-INC锁时；<ul><li>递增<code>dict_table_t::n_waiting_or_granted_auto_inc_locks</code>。前面我们已经提到过，当这个值非0时，对于自增列的插入操作就会退化到OLD-STYLE;</li><li>锁对象直接引用已经预先创建好的<code>dict_table_t::autoinc_lock</code>，并加入到<code>trx_t::autoinc_locks</code>集合中;</li></ul></li><li>对于非AUTO-INC锁，则从一个pool中分配锁对象<ul><li>在事务对象<code>trx_t::lock</code>中，维持了两个pool，一个是<code>trx_lock_t::rec_pool</code>，预分配了一组锁对象用于记录锁分配，另外一个是<code>trx_lock_t::table_pool</code>，用于表级锁的锁对象分配。通过预分配内存的方式，可以避免在持有全局大锁时(<code>lock_sys-&gt;mutex</code>)进行昂贵的内存分配操作。rec_pool和table_pool预分配的大小都为8个锁对象。（<code>lock_trx_alloc_locks</code>）;</li><li>如果table_pool已经用满，则走内存分配，创建一个锁对象；</li></ul></li><li>构建好的锁对象分别加入到事务的<code>trx_t::lock.trx_locks</code>链表上以及表对象的<code>dict_table_t::locks</code>链表上；</li><li>构建好的锁对象加入到当前事务的<code>trx_t::lock.table_locks</code>集合中。</li></ul><p>可以看到锁对象会加入到不同的集合或者链表中，通过挂载到事务对象上，可以快速检查当前事务是否已经持有表锁；通过挂到表对象的锁链表上，可以用于检查该表上的全局冲突情况。</p><p><strong>加行级锁</strong></p><p>行级锁加锁的入口函数为<code>lock_rec_lock</code>，其中第一个参数impl如果为TRUE，则当当前记录上已有的锁和<code>LOCK_X | LOCK_REC_NOT_GAP</code>不冲突时，就无需创建锁对象。（见上文关于记录锁LOCK_X相关描述部分），为了描述清晰，下文的流程描述，默认impl为FALSE。</p><p><code>lock_rec_lock</code>：</p><ul><li>首先尝试fast lock的方式，对于冲突少的场景，这是比较普通的加锁方式(<code>lock_rec_lock_fast</code>), 符合如下情况时，可以走fast lock:<ul><li>记录所在的page上没有任何记录锁时，直接创建锁对象，加入rec_hash，并返回成功;</li><li>记录所在的page上只存在一个记录锁，并且属于当前事务，且这个记录锁预分配的bitmap能够描述当前的heap no（预分配的bit数为创建锁对象时的page上记录数 + 64，参阅函数<code>RecLock::lock_size</code>），则直接设置对应的bit位并返回;</li></ul></li><li>无法走fast lock时，再调用slow lock的逻辑(<code>lock_rec_lock_slow</code>)<ul><li>判断当前事务是否已经持有了一个优先级更高的锁，如果是的话，直接返回成功（<code>lock_rec_has_expl</code>）;</li><li>检查是否存在和当前申请锁模式冲突的锁（<code>lock_rec_other_has_conflicting</code>），如果存在的话，就创建一个锁对象（<code>RecLock::RecLock</code>），并加入到等待队列中（<code>RecLock::add_to_waitq</code>），这里会进行死锁检测;</li><li>如果没有冲突的锁，则入队列（<code>lock_rec_add_to_queue</code>）：已经有在同一个Page上的锁对象且没有别的会话等待相同的heap no时，可以直接设置对应的bitmap（<code>lock_rec_find_similar_on_page</code>）；否则需要创建一个新的锁对象;</li></ul></li><li>返回错误码，对于DB_LOCK_WAIT, DB_DEADLOCK等错误码，会在上层进行处理。</li></ul><p><strong>等待及死锁判断</strong></p><p>当发现有冲突的锁时，调用函数<code>RecLock::add_to_waitq</code>进行判断</p><ul><li>如果持有冲突锁的线程是内部的后台线程（例如后台dict_state线程），这个线程不会被一个高优先级的事务取消掉，因为总是优先保证内部线程正常执行；</li><li>比较当前会话和持有锁的会话的事务优先级，调用函数trx_arbitrate 返回被选作牺牲者的事务；<ul><li>当前发起请求的会话是后台线程，但持有锁的会话设置了高优先级时，选择当前线程作为牺牲者；</li><li>持有锁的线程为后台线程时，在第一步已经判断了，不会选作牺牲者；</li><li>如果两个会话都设置了优先级，低优先级的被选做牺牲者，优先级相同时，请求者被选做牺牲者(<code>thd_tx_arbitrate</code>)；</li><li>PS: 目前最新版本的5.7还不支持用户端设置线程优先级（但增加一个配置session变量的接口非常容易)；</li></ul></li><li>如果当前会话的优先级较低，或者另外一个持有锁的会话为后台线程，这时候若当前会话设置了优先级，直接报错，并返回错误码DB_DEADLOCK；<ul><li>默认不设置优先级时，请求锁的会话也会被选作victim_trx，但只创建锁等待对象，不会直接返回错误；</li></ul></li><li>当持有锁的会话被选作牺牲者时，说明当前会话肯定设置了高优先级，这时候会走<code>RecLock::enqueue_priority</code>的逻辑；<ul><li>如果持有锁的会话在等待另外一个不同的锁时，或者持有锁的事务不是readonly的，当前会话会被回滚掉；</li><li>开始跳队列，直到当前会话满足加锁条件（<code>RecLock::jump_queue</code>）；<ul><li>请求的锁对象跳过阻塞它的锁对象，直接操作hash链表，将锁对象往前挪；</li><li>从当前lock，向前遍历链表，逐个判断是否有别的会话持有了相同记录上的锁（<code>RecLock::is_on_row</code>），并将这些会话标记为回滚（<code>mark_trx_for_rollback</code>）,同时将这些事务对象搜集下来，以待后续处理（但直接阻塞当前会话的事务会被立刻回滚掉）；</li></ul></li><li>高优先级的会话非常具有杀伤力，其他低优先级会话即使拿到了锁，也会被它所干掉。</li></ul></li></ul><p>不过实际场景中，我们并没有多少机会去设置事务的优先级，这里先抛开这个话题，只考虑默认的场景，即所有的事务优先级都未设置。</p><p>在创建了一个处于WAIT状态的锁对象后，我们需要进行死锁检测（<code>RecLock::deadlock_check</code>），死锁检测采用深度优先遍历的方式，通过事务对象上的<code>trx_t::lock.wait_lock</code>构造事务的wait-for graph进行判断，当最终发现一个锁请求等待闭环时，可以判定发生了死锁。另外一种情况是，如果检测深度过长（即锁等待的会话形成的检测链路非常长），也会认为发生死锁，最大深度默认为<code>LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK</code>，值为200。</p><p>当发生死锁时，需要选择一个牺牲者（<code>DeadlockChecker::select_victim()</code>）来解决死锁，通常事务权重低的回滚（<code>trx_weight_ge</code>）。</p><ul><li>修改了非事务表的会话具有更高的权重；</li><li>如果两个表都修改了、或者都没有修改事务表，那么就根据的事务的undo数量加上持有的事务锁个数来决定权值（TRX_WEIGHT）；</li><li>低权重的事务被回滚，高权重的获得锁对象。</li></ul><p>Tips：对于一个经过精心设计的应用，我们可以从业务上避免死锁，而死锁检测本身是通过持有全局大锁来进行的，代价非常高昂，在阿里内部的应用中，由于有专业的团队来保证业务SQL的质量，我们可以选择性的禁止掉死锁检测来提升性能，尤其是在热点更新场景，带来的性能提升非常明显，极端高并发下，甚至能带来数倍的提升。</p><p>当无法立刻获得锁时，会将错误码传到上层进行处理（<code>row_mysql_handle_errors</code>）</p><ul><li><code>DB_LOCK_WAIT</code>：<ul><li>具有高优先级的事务已经搜集了会阻塞它的事务链表，这时候会统一将这些事务回滚掉（<code>trx_kill_blocking</code>）；</li><li>将当前的线程挂起（<code>lock_wait_suspend_thread</code>），等待超时时间取决于session级别配置（<code>innodb_lock_wait_timeout</code>），默认为50秒；</li><li>如果当前会话的状态设置为running，一种是被选做死锁检测的牺牲者，需要回滚当前事务，另外一种是在进入等待前已经获得了事务锁，也无需等待；</li><li>获得等待队列的一个空闲slot。（<code>lock_wait_table_reserve_slot</code>）<ul><li>系统启动时，已经创建好了足够用的slot数组，类型为<code>srv_slot_t</code>，挂在<code>lock_sys-&gt;waiting_threads</code>上；</li><li>分配slot时，从slot数组的第一个元素开始遍历，直到找到一个空闲的slot。注意这里存在的一个性能问题是，如果挂起的线程非常多，每个新加入挂起等待的线程都需要遍历直到找到一个空闲的slot。 实际上如果每次遍历都从上次分配的位置往后找，到达数组末尾在循环到数组头，这样可以在高并发高锁冲突场景下获得一定的性能提升；</li></ul></li><li>如果会话在innodb层（通常为true），则强制从InnoDB层退出，确保其不占用<code>innodb_thread_concurrency</code>的槽位。然后进入等待状态。被唤醒后，会再次强制进入InnoDB层；</li><li>被唤醒后，释放slot（<code>lock_wait_table_release_slot</code>）；</li><li>若被选作死锁的牺牲者了，返回上层回滚事务；若等待超时了，则根据参数<code>innodb_rollback_on_timeout</code>的配置，默认为OFF只回滚当前SQL，设置为ON表示回滚整个事务。</li></ul></li><li><code>DB_DEADLOCK</code>: 直接回滚当前事务</li></ul><p><strong>释放锁及唤醒</strong></p><p>大多数情况下事务锁都是在事务提交时释放，但有两种意外：</p><ul><li>AUTO-INC锁在SQL结束时直接释放（<code>innobase_commit --&gt; lock_unlock_table_autoinc</code>）；</li><li>在RC隔离级别下执行DML语句时，从引擎层返回到Server层的记录，如果不满足where条件，则需要立刻unlock掉（<code>ha_innobase::unlock_row</code>）。</li></ul><p>除这两种情况外，其他的事务锁都是在事务提交时释放的(<code>lock_trx_release_locks --&gt; lock_release</code>)。事务持有的所有锁都维护在链表<code>trx_t::lock.trx_locks</code>上，依次遍历释放即可。</p><p>对于行锁，从全局hash中删除后，还需要判断别的正在等待的会话是否可以被唤醒（<code>lock_rec_dequeue_from_page</code>）。例如如果当前释放的是某个记录的X锁，那么所有的S锁请求的会话都可以被唤醒。</p><p>这里的移除锁和检查的逻辑开销比较大，尤其是大量线程在等待少量几个锁时。当某个锁从hash链上移除时，InnoDB实际上通过遍历相同page上的所有等待的锁，并判断这些锁等待是否可以被唤醒。而判断唤醒的逻辑又一次遍历，这是因为当前的链表维护是基于&lt;space, page no&gt;的，并不是基于Heap no构建的。关于这个问题的讨论，可以参阅<a href="http://bugs.mysql.com/bug.php?id=53825">bug#53825</a>。官方开发Sunny也提到虽然使用&lt;space, page no, heap no&gt;来构建链表，移除Bitmap会浪费更多的内存，但效率更高，而且现在的内存也没有以前那么昂贵。</p><p>对于表锁，如果表级锁的类型不为LOCK_IS，且当前事务修改了数据，就将表对象的<code>dict_table_t::query_cache_inv_id</code>设置为当前最大的事务id。在检查是否可以使用该表的Query Cache时会使用该值进行判断（<code>row_search_check_if_query_cache_permitted</code>），如果某个用户会话的事务对象的low_limit_id（即最大可见事务id）比这个值还小，说明它不应该使用当前table cache的内容，也不应该存储到query cache中。</p><p>表级锁对象的释放调用函数<code>lock_table_dequeue</code>。</p><p>注意在释放锁时，如果该事务持有的锁对象太多，每释放1000（<code>LOCK_RELEASE_INTERVAL</code>）个锁对象，会暂时释放下<code>lock_sys-&gt;mutex</code>再重新持有，防止InnoDB hang住。</p><h2 id="两个有趣的案例"><a class="header-anchor" href="#两个有趣的案例"></a>两个有趣的案例</h2><p>本小节我们来分析几个比较有趣的死锁案例。</p><p><strong>普通的并发插入导致的死锁</strong></p><p><code>create table t1 (a int primary key);</code> 开启三个会话执行： <code>insert into t1(a) values (2);</code></p><table><thead><tr><th>session 1</th><th>session 2</th><th>session 3</th></tr></thead><tbody><tr><td>BEGIN; INSERT…</td><td></td><td></td></tr><tr><td></td><td>INSERT (block),为session1创建X锁，并等待S锁</td><td></td></tr><tr><td></td><td></td><td>INSERT (block， 同上等待S锁)</td></tr><tr><td>ROLLBACK，释放锁</td><td></td><td></td></tr><tr><td></td><td>获得S锁</td><td>获得S锁</td></tr><tr><td></td><td>申请插入意向X锁，等待session3</td><td></td></tr><tr><td></td><td></td><td>申请插入意向X锁，等待session2</td></tr></tbody></table><p>上述描述了互相等待的场景，因为插入意向X锁和S锁是不相容的。这也是一种典型的锁升级导致的死锁。如果session1执行COMMIT的话，则另外两个线程都会因为duplicate key失败。</p><p>这里需要解释下为何要申请插入意向锁，因为ROLLBACK时原记录回滚时是被标记删除的。而我们尝试插入的记录和这个标记删除的记录是相邻的(键值相同)，根据插入意向锁的规则，插入位置的下一条记录上如果存在与插入意向X锁冲突的锁时，则需要获取插入意向X锁。</p><p>另外一种类似（但产生死锁的原因不同）的场景是在一张同时存在聚集索引和唯一索引的表上，通过replace into的方式插入冲突的唯一键，可能会产生死锁，在3月份的月报，我已经专门描述过这个问题，感兴趣的可以<a href="http://mysql.taobao.org/index.php?title=MySQL%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5_2015.03#MySQL_.C2.B7_.E7.AD.94.E7.96.91.E9.87.8A.E6.83.91.C2.B7_.E5.B9.B6.E5.8F.91Replace_into.E5.AF.BC.E8.87.B4.E7.9A.84.E6.AD.BB.E9.94.81.E5.88.86.E6.9E.90">延伸阅读下</a>。</p><p><strong>又一个并发插入的死锁现象</strong></p><p>两个会话参与。在RR隔离级别下</p><p>例表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (a <span class="type">int</span> <span class="keyword">primary</span> key ,b <span class="type">int</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">11</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>begin;select * from t1 where a = 5 for update;(获取记录(11,22)上的GAP X锁)</td><td></td></tr><tr><td></td><td>begin;select * from t1 where a = 5 for update; (同上,GAP锁之间不冲突</td></tr><tr><td>insert into t1 values (4,5); (block，等待session1)</td><td></td></tr><tr><td></td><td>insert into t1 values (4,5);（需要等待session2，死锁）</td></tr></tbody></table><p>引起这个死锁的原因是非插入意向的GAP X锁和插入意向X锁之间是冲突的。</p><hr><p><strong>本文地址：<a href="http://xnerv.wang/introduction-of-innodb-transaction-lock/">http://xnerv.wang/introduction-of-innodb-transaction-lock/</a></strong><br>转载自：<a href="http://mysql.taobao.org/monthly/2016/01/01/">InnoDB 事务锁系统简介</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;本文的目的是对 InnoDB 的事务锁模块做个简单的介绍，使读者对这块有初步的认识。本文先介绍行级锁和表级锁的相关概念，再介绍其内部的一些实现；最后以两个有趣的案例结束本文。&lt;/p&gt;
&lt;p&gt;本文所有的代码和示例都是基于当前最新的 MySQL5.7.10 版本。&lt;/p&gt;
&lt;h2 id=&quot;行级锁&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#行级锁&quot;&gt;&lt;/a&gt;行级锁&lt;/h2&gt;
&lt;p&gt;InnoDB 支持到行级别粒度的并发控制，本小节我们分析下几种常见的行级锁类型，以及在哪些情况下会使用到这些类型的锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOCK_REC_NOT_GAP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁带上这个 FLAG 时，表示这个锁对象只是单纯的锁在记录上，不会锁记录之前的 GAP。在 RC 隔离级别下一般加的都是该类型的记录锁（但唯一二级索引上的 duplicate key 检查除外，总是加 &lt;code&gt;LOCK_ORDINARY&lt;/code&gt; 类型的锁）。&lt;/p&gt;</summary>
    
    
    
    <category term="DBMS" scheme="https://xnerv.wang/categories/DBMS/"/>
    
    
    <category term="转载" scheme="https://xnerv.wang/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="DBMS" scheme="https://xnerv.wang/tags/DBMS/"/>
    
    <category term="MySQL" scheme="https://xnerv.wang/tags/MySQL/"/>
    
    <category term="Transaction" scheme="https://xnerv.wang/tags/Transaction/"/>
    
    <category term="InnoDB" scheme="https://xnerv.wang/tags/InnoDB/"/>
    
    <category term="Lock" scheme="https://xnerv.wang/tags/Lock/"/>
    
  </entry>
  
</feed>
